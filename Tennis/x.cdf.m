(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Needs["DifferentialEquations`NDSolveProblems`"];
Needs["DifferentialEquations`NDSolveUtilities`"];
Needs["DifferentialEquations`InterpolatingFunctionAnatomy`"];
Needs["Graphics`"];
Needs["GUIKit`"];
Needs["VectorAnalysis`"];
{CoordinateSystem,Coordinates[]};
constants={
g:=9.8(*m/s^2*);
speed100:=44.702(*100 mph to m/sec;*);
pi:=3.14159265359;
airdensity:=1.21;(*# kg/m^3*)
radius:=3.3/100;(*# m*)
area:=\[Pi] radius^2;
mass:=.057;(*# kg*)
inertia:=mass  radius;
courtlength:=23.7744/2;(*# m*)
courtwidth:=8.2296/2;(*# m*)
courtservicelength:=6.4;(*# m*)
courtservicewidth:=courtwidth/2;(*# m*)
netheightmid:=.9144;(*# m*)
netheightside:=1.0668;(*# m*)
netwidth:=courtwidth+.9144 2;
doublesExtra=1;(*check*)
boarder=5;
};
ReboundAce:={coefRebound:=.8,
coefDrag:=.45
};
courtlines={{-(courtwidth),-courtlength,0},
{-courtwidth,courtlength,0},
{courtwidth,courtlength,0},
{courtwidth,-courtlength,0},
{-courtwidth,-courtlength,0}};

doubleslines={{-(courtwidth+doublesExtra),-courtlength,0},
{-(courtwidth+doublesExtra),courtlength,0},
{(courtwidth+doublesExtra),courtlength,0},
{(courtwidth+doublesExtra),-courtlength,0},
{-(courtwidth+doublesExtra),-courtlength,0}};

servicelines={{-courtwidth,-courtservicelength,0},
{courtwidth,-courtservicelength,0},{0,-courtservicelength,0},
{0,0,0},{0,0,netheightmid},{0,0,0},
{0,courtservicelength,0},{courtwidth,courtservicelength,0},
{-courtwidth,courtservicelength,0}
};

courtlines2d=Map[Most[#]&,courtlines];
servicelines2d=Map[Most[#]&,servicelines];
doubleslines2d=Map[Most[#]&,doubleslines];
netlines2d={{-netwidth,0},{netwidth,0}};

netlines={{-netwidth,0,0},{-netwidth,0,netheightside},{0,0,netheightmid},{netwidth,0,netheightside},{netwidth,0,0},{-netwidth,0,0}
};
(* Logical function for in-net condition. *)
NetTop[x_]:=Module[{},
(netheightside -netheightmid)(Abs[x]/netwidth)+netheightmid
];
Net[xyz_]:=Module[{x=xyz[[1]],y=xyz[[2]],z=xyz[[3]]},
List[x," ",y," ",z];
If[Abs[y]<.02 &&z<NetTop[x],1,-1]
]
size=500;
Net[{0,0,.1}]


ReboundAce;
(*Computes velocities after bounce accounting for incident velocity and spin.*)
BounceModel[vel_List,spin_List]:=Module[{v=vel,speedXY,VzVh,angleVzVh,dCOR,COR,dCOD,COD,diffVelXY,spinVel},
speedXY=Norm[v]+.00001;
VzVh=vel[[3]]/speedXY(*vertical to horizontal speed ratio*);
angleVzVh=Abs[(180/\[Pi])ArcTan[speedXY,-vel[[3]]]];
(*adjustment to coefficient of rebound*)
dCOR=If[angleVzVh<30,0.05(30-angleVzVh)/20,0];
COR=coefRebound+dCOR;
dCOD=If[angleVzVh<22,-.35(angleVzVh-22)/12,0];COD=coefDrag+dCOD;
List[speedXY,", ",vel[[3]],", ",dCOR,", ",COR,", ",angleVzVh//N];
(*Add spin correction to rebound calculation*)
spinVel=CrossProduct[spin,{0,0,-1}] radius;(*spin(\[Omega])*)
List[vel,", ",v,",== ",spinVel];
diffVelXY=v+spinVel;
v[[1]]-=(1-COD) diffVelXY[[1]];
v[[2]]-=(1-COD) diffVelXY[[2]];
v[[3]]=-COR vel[[3]];
List[vel,", ",v,",=> ",spinVel];
v
];
BounceModel[{0,3,-3},{4,50,60}]


SpinBounce[vel_List]:=Module[{SpinDirection},
SpinDirection=CrossProduct[vel,{0,0,-1}]
];

Forces[vel_List,spin_List]:=Module[{v=vel,s=spin(*Overscript[\[Omega], \[RightVector]]*),speed,spinspeed,force,Cd,Cl,spinPerpendicular,vspin,drag,magnus},
speed=Norm[v]+.00001;
spinspeed=Norm[s]+.00001;
spinPerpendicular=CrossProduct[s,v]/speed;
vspin=radius Norm[spinPerpendicular]+.00001;
Cd=.55+1/(22.5+4.2(speed/vspin)^2.5)^0.4;
drag=Cd area airdensity DotProduct[v,v]/2;
Cl=1/(2+(speed/vspin));
List["speed/vspin=",speed,", ",vspin//N," ",Cl];
magnusVel=CrossProduct[s,v]/spinspeed;
magnus=Cl area airdensity  magnusVel Norm[magnusVel];
force=-drag v/speed+magnus;
force
];

Spin[t_]:=Module[{},spin];

equations:={
vz'[t]==-g+(Forces[{vx[t],vy[t],vz[t]},Spin[t]][[3]])/mass,
z'[t]==vz[t],
vy'[t]==(Forces[{vx[t],vy[t],vz[t]},Spin[t]][[2]])/mass,
y'[t]==vy[t],
vx'[t]==(Forces[{vx[t],vy[t],vz[t]},Spin[t]][[1]])/mass,
x'[t]==vx[t]
};



