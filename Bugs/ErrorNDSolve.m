(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Needs["DifferentialEquations`NDSolveProblems`"];
Needs["DifferentialEquations`NDSolveUtilities`"];
Needs["DifferentialEquations`InterpolatingFunctionAnatomy`"];
Needs["Graphics`"];
Needs["GUIKit`"];
Needs["VectorAnalysis`"];
{CoordinateSystem,Coordinates[]};
constants={
g:=9.8(*m/s^2*);
speed100:=44.702(*100 mph to m/sec;*);
pi:=3.14159265359;
airdensity:=1.21;(*#kg/m^3*)
radius:=3.3/100;(*#m*)
area:=\[Pi] radius^2;
mass:=.057;(*#kg*)
courtwidth:=8.2296/2;(*#m*)
netheightmid:=.9144;(*#m*)
netheightside:=1.0668;(*#m*)
netwidth:=courtwidth+.9144 2;
};
ReboundAce:={coefRebound:=.8,
coefDrag:=.45
};

(* Logical function for in-net condition. *)
NetTop[x_]:=Module[{},
(netheightside -netheightmid)(Abs[x]/netwidth)+netheightmid
];
Net[xyz_]:=Module[{x=xyz[[1]],y=xyz[[2]],z=xyz[[3]]},
List[x," ",y," ",z];
If[Abs[y]<.02 &&z<NetTop[x],1,-1]
]
ReboundAce;
BounceModel[vel_,spin_]:=Module[{v=vel,speedXY,VzVh,angleVzVh,dCOR,COR,dCOD,COD,diffVelXY,spinVel},
v[[3]]=0;
speedXY=Norm[v]+.00001;
VzVh=vel[[3]]/speedXY(*vertical to horizontal speed ratio*);
angleVzVh=Abs[(180/\[Pi])ArcTan[speedXY,-vel[[3]]]];
(*adjustment to coefficient of rebound*)
dCOR=If[angleVzVh<30,0.05(30-angleVzVh)/20,0];
COR=coefRebound+dCOR;
dCOD=If[angleVzVh<22,-.35(angleVzVh-22)/12,0];COD=coefDrag+dCOD;
List[speedXY,", ",vel[[3]],", ",dCOR,", ",COR,", ",angleVzVh//N];
(*Add spin correction to rebound calculation*)
spinVel=CrossProduct[spin,{0,0,-1}] radius;(*spin(\[Omega])*)
List[vel,", ",v,",== ",spinVel];
diffVelXY=v+spinVel;
v[[1]]-=(1-COD) diffVelXY[[1]];
v[[2]]-=(1-COD) diffVelXY[[2]];
v[[3]]=-COR vel[[3]];
List[vel,", ",v,",=> ",spinVel];
v
];

SpinBounce[vel_]:=Module[{},
SpinDirection=CrossProduct[vel,{0,0,-1}]
];

Forces[vel_,spin_]:=Module[{v=vel,s=spin(*
\!\(\*OverscriptBox["\[Omega]", "\[RightVector]"]\)*),speed,spinspeed,force,Cd,Cl,spinPerpendicular,vspin,drag,magnus},
speed=Norm[v]+.00001;
spinspeed=Norm[s]+.00001;
spinPerpendicular=CrossProduct[s,v]/speed;
vspin=radius Norm[spinPerpendicular]+.00001;
Cd=.55+1/(22.5+4.2(speed/vspin)^2.5)^0.4;
drag=Cd area airdensity DotProduct[v,v]/2;

Cl=1/(2+(speed/vspin));
magnusVel=CrossProduct[s,v]/spinspeed;
magnus=Cl area airdensity  magnusVel Norm[magnusVel];
force=-drag v/speed+magnus;
force
];

Spin[t_]:=Module[{},spin];

equations:={
vz'[t]==-g+(Forces[{vx[t],vy[t],vz[t]},Spin[t]][[3]])/mass,
z'[t]==vz[t],
vy'[t]==(Forces[{vx[t],vy[t],vz[t]},Spin[t]][[2]])/mass,
y'[t]==vy[t],
vx'[t]==(Forces[{vx[t],vy[t],vz[t]},Spin[t]][[1]])/mass,
x'[t]==vx[t]
};
ics:={
vz[0]==.02 speed100,z[0]==2,
vy[0]==.46 speed100,y[0]==-12,
vx[0]==0 speed100 ,x[0]==0
};
spin={-100,300,300};(*rev/sec*)
spin=spin 2 \[Pi] radius(*\[Omega] radius*)

soln=NDSolve[{equations,ics},{vz,z,vy,y,vx,x},{t,0,100},Method->{"EventLocator","Event"->{z[t],Net[{x[t],y[t],z[t]}]},"EventAction":>{Throw[Null, "StopIntegration"],Print["t-net=",t] }},MaxStepSize->.001];
end = InterpolatingFunctionDomain[First[z/.soln]][[1,-1]]



