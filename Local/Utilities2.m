(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
(*Example of simple graphic aids to draw figures on a rectangle.  Define vertices and lines;
vx=Tuples[{{0,1,2,3,4},{1,0,-1}}];
Graphics[MapIndexed[Text[#2,#1]&,vx]];
line={{vx[[1]],vx[[4]]},{vx[[4]],vx[[6]]},{vx[[6]],vx[[3]]},
{vx[[4]],vx[[7]]},{vx[[6]],vx[[9]]},{vx[[7]],vx[[9]]},
{vx[[9]],vx[[12]]},{vx[[7]],vx[[10]]},{vx[[12]],vx[[10]]},
{vx[[13]],vx[[10]]},{vx[[12]],vx[[15]]}
};
Graphics[{Thin,Black,Map[Line[#]&,line],MapIndexed[Text[#2,(#1[[1]]+#1[[2]])/2]&,line]}]
*)

(*  MidArrow[{{x1,y1},{x2,y2}}] draws arrow with symbol in middle  *)
MidArrow[xy_List]:={Arrowheads[Medium],Arrow[{xy[[1]],(xy[[1]]+xy[[2]])/2}],Line[{(xy[[1]]+xy[[2]])/2,xy[[2]]}]}
(*Draws text at mid line.*)
MidLineText[text_,line_List,style_List]:={Text[Style[text,style],(line[[1]]+line[[2]])/2]}
MidLineTextOffset[text_,line_List,style_List,Offset_List]:={Text[Style[text,style],((line[[1]]+Offset)+(line[[2]]+Offset))/2]}

TextOver[text_,xy_List]:={White,Disk[xy,0.2],
Text[Style[text,FontSize->16,Red],xy]};
TextOver[text_,xy_List,font_]:={White,Disk[xy,0.2],
Text[Style[text,FontSize->font,Red],xy]}

(*Contruct array of points and lines to be reference by array indices.*)
tuGraphicPointLines[
nx_(*Number of points X*),
ny_(*Number of points Y*),
linepoints_List(*indices that define lines*),
displayTemplate_:True]:=
Module[{vx,line,vxline},
vx=Tuples[{Range[nx]-1,Range[ny]-1}];
If[Depth[linepoints]==4,
line=linepoints,(*endpoints specified by x,y offset from LowerLeft*)
(*else by vx index*)
line=Map[{vx[[#[[1]]]],vx[[#[[2]]]]}&,linepoints]];
If[displayTemplate,
Print["General graphic definitions for array points and lines."];
Print[
Graphics[{Thick,RGBColor[1,0,1,.7],Map[Line[#]&,line],MapIndexed[Text[Style[#2[[1]],FontSize->30],(#1[[1]]+#1[[2]])/2]&,line],
RGBColor[.66,0,0,.5],MapIndexed[Text[Style[#2[[1]],FontSize->16 ],#1]&,vx]}]]];
{vx,line}(*returns point_List and line_List corresponding to graph numbers*)
];
GraphicPointLines:=tuGraphicPointLines;

(**)
(*Examples of H and X Feymann diagrams.*)
Graphics2H2[c1_,c2_,x_,c3_,c4_]:=Graphics[{Thick,Black,
MidArrow[{{0,-1},{1,0}}],
MidArrow[{{1,0},{0,1}}],
MidArrow[{{3,-1},{2 ,0}}],
MidArrow[{{2 ,0},{3 ,1}}],
Dotted,Line[{{1,0},{2 ,0}}],
TextOver[x,{1.5,0 }],
TextOver[c1,{0,-1}],
TextOver[c2,{3 ,-1}],
TextOver[c3,{0,1}],
TextOver[c4,{3 ,1}]
},ImageSize->Small
];
Graphics2X2[c1_,c2_,x_,c3_,c4_]:=Graphics[{Thick,Black,
MidArrow[{{-1,-1},{0,0}}],
MidArrow[{{1,-1},{0,0}}],
MidArrow[{{0,2},{-1 ,3}}],
MidArrow[{{0,2},{1 ,3}}],
Dotted,Line[{{0,0},{0 ,2}}],
TextOver[x,{0,1 }],
TextOver[c1,{-1,-1}],
TextOver[c2,{1 ,-1}],
TextOver[c3,{-1,3}],
TextOver[c4,{ 1,3}]
},ImageSize->Small
];

(**)
tuGraphicDefs::usage="tuGraphicDefs defines functions to be used with Graphics[] *9Oct2018*";
tuGraphicDefs:=Block[{},
mid[i_,j_,wt_:.5]:=(wt $pt[[i]]+(1-wt)$pt[[j]]);
midline[lineN_,wt_:.5]:=(wt $line[[lineN,1]]+(1-wt)$line[[lineN,2]]);
textstyle[txt_,size_:Small,color_:Blue,font:Bold]:=Style[txt,font,color,size];
define$pt[n1_,n2_]:=$pt={Range[-n1,n1],Range[-n2,n2]}//Tuples;
show$pt:=Graphics[MapIndexed[Text[Subscript[#2[[1]], Apply[Sequence,#1]],#1]&,$pt]]
];



(* ::Input::Initialization:: *)
(*
Creates file with filename in SaveFile for saving variable expressions
SaveFile="$HomeDirectory<>"/Mathematica/PeskinSchroeder/NBname["stub"].out"]
*)
tuSaveFile:=Put[SaveFile=NBname["stub"]<>".out"] ;
(*Returns all or parts of NotebookFileName based upon type_String.*)
NBname[type_String]:=Module[{
name=NotebookFileName[],dir=FileNameDrop[NotebookFileName[],-1],base=FileBaseName[NotebookFileName[]]},
Switch[type,
"name",name,
"dir",dir,
"base",base,
"stub",FileNameJoin[{dir,base}]
]
];
(*
To save variables:
Put[variable_List,SaveFile];
or Save[SaveFile,variable_List];

To retrieve output definitions from file in current directory.
	Get[NotebookDirectory[]<>"LectureB2011.10.10.out"]
or   Get[$HomeDirectory<>"/Mathematica/PeskinSchroeder/FinalProject1.out"]*)
tuSaveAllVariables::usage="tuSaveAllVariables[file_:toSaveFile] saves all Context[Global'] variables to file_. To retrieve output definitions from file_ use \[IndentingNewLine]	Get[NotebookDirectory[]<>notebook.out **";
tuSaveAllVariables[file_:SaveFile]:=Module[{$$},
$$=Names["$*"|"e*"];
$$=Select[$$,Context[#]=="Global`"&& Length[StringCases[#,RegularExpression["[$]"]]]<2&];
$$=Inactive[Save][file,$$ ];
$$//Activate
];

tuLoad::usage="tuLoad[filePath_] loads contents of $InitialDirectory/Mathematica/<>filePath into notebook workspace. *12Feb2019*";
tuLoad[filePath_]:=Module[{$},
$=$InitialDirectory<>"/Mathematica/"<>filePath;(*
tuLoad::yes="Loaded: `1` ";
tuLoad::no="Not Found: `1` ";*)
Get[$]
];



(* ::Input::Initialization:: *)
(*for convenience*)
toRule:={Equal->Rule};
toEqual:={Rule->Equal};
(*variables inbedded in any one of tuRuleIndependentVarPattern are considered independent from the variable for the purpose of tuRule[]s.*)tuRuleIndependentVarPattern:={SubPlus[_],SubMinus[_],SuperPlus[_],SuperMinus[_],Subscript[_,_],Superscript[_,_],OverBar[_],UnderBar[_],OverTilde[_],OverHat[_],SubStar[_],SuperStar[_],OverVector[_],OverDot[_],OverDot[_,1],OverDot[_,2],Derivative[1][_],Derivative[2][_],Tensor[_,_,_],Sign[_],Style[__]};
(**)

tuCommentRemove:=head_[CR[__]|CG[__]|CO[__]|CP[__]|CB[__]]->head;

tuRule::usage="tuRule[rules_,negativePower_:False,simplerArg_:True] produces a List of valid Rule[]s from rules_ and forms a Flatten[]d list of Rules. Deletes imbedded comments in the form of head_[CG[__]] and other non-Rule forms. If  If negativePower_\[Rule]True then negative Power of Rule[]s are generated.  If simplerArg_\[Rule]True then Rules are transformed from -a\[Rule]b \[Rule] a\[Rule]-b and \!\(\*SuperscriptBox[\(a\), \(2\)]\)->b \[Implies] a\[Rule]Sqrt[b] . *7Aug2015*1Feb2018*";
tuRule[rules_,negativePower_:False,simplerArg_:True]:=Module[{$=rules,rr$},
$=$//Flatten;
$=$//.head_[CR[__]|CG[__]|CO[__]|CP[__]|CB[__]]->head;(*eliminate comments*)
$=$//tuExtractPattern[Rule[__]|RuleDelayed[__]];
If[simplerArg,
$=$/.(rr:Rule|RuleDelayed)[-a_,b_]->rr[a,-b];
];
If[negativePower,
$={$,$//tuRulePositiveNegativePower,$/.(rr:Rule|RuleDelayed)[a_,b_]->rr[1/a,1/b] }
];
$=$//DeleteCases[(Rule|RuleDelayed)[a_,a_]]//Flatten;
$=$//DeleteCases[(Rule)[FontFamily,a_]]//Flatten;
$//DeleteDuplicates
];
(**)
tuList0::usage="tuList0[EXP_] extracts the element from a List[] with only a single element *3Nov2018*";
tuList0[EXP_]:=Module[{$=EXP},
If[Head[$]===List,
If[Length[$]==1,Flatten[$][[1]],
$]
]
];
tuRule1::usage="tuRule1[rules_,negativePower_:False,simplerArg_:True] is the equivalent to tuList0[tuRule[rules,negativePower,simplerArg]] *3Nov2018*";
tuRule1[rules_,negativePower_:False,simplerArg_:True]:=
tuList0[tuRule[rules,negativePower,simplerArg]];
(**)
tuRuleNoPower::usage="tuRuleNoPower[rules_] eliminates Power of first arguement of Rule[], e.g. \!\(\*SuperscriptBox[\(a\), \(2\)]\)\[Rule]b \[Implies] a\[Rule]Sqrt[b].  *1Feb2018*";
tuRuleNoPower[rules_]:=Module[{$=rules,rr$},
$=$/.(rr:Rule|RuleDelayed)[Power[a_,b_],c_]:>(rr$[a,Power[c,If[Head[b]===Rational,Rationalize[1/b],1/b]]]/.rr$->rr)
];
tuRulePositiveNegativePower::usage="tuRulePositiveNegativePower[rules_] produces inverse Power in Rule[]s that include Power[] in first arguement.  Mathematica does not recognize inversed Power terms in pattern matching.  *2Feb2018*";
tuRulePositiveNegativePower[rules_]:=Module[{$=rules,rr$},
$=$/.(rr:Rule|RuleDelayed)[Power[a_,b_],c_]:>(rr$[Power[a,-b],Power[c,-1]]/.rr$->rr)
];
(**)
tuRuleAll::usage="tuRuleAll[rules_,simplerArg_:False] extracts all possible rules from tuRule[rules_] by extracting nested Rule[]s and combining with Reverse[Rules[]]. If simplerArg_\[Rule]True then Rules are reformed so -a\[Rule]b -> a\[Rule]-b and \!\(\*SuperscriptBox[\(a\), \(2\)]\)->b \[Implies] a\[Rule]Sqrt[b]. *22Jul2017*1Feb2018*";
tuRuleAll[rules_,simplerArg_:True]:=Module[{$=rules},
$=tuRule[$];
$=tuRuleSeparate[#,simplerArg]&/@$//Flatten;
$//DeleteDuplicates
];
(**)
tuRuleUnique::usage="tuRuleUnique[hasRules_] extracts Rules from hasRules_ and produces an unique List[] of Rule[]s *12Aug2017*";
tuRuleUnique[hasRules_]:=Module[{xRule,$=hasRules},
$=tuRuleAll[$]/.Rule->xRule/.xRule[a_,b_]:>xRule[b,a]/;OrderedQ[{b,a}]//DeleteDuplicates//Sort;
$=$/.xRule->Rule
];
(**)
Clear[tuRuleSeparate]
tuRuleSeparate::usage="tuRuleSeparate[exp_Rule,simplerArg_:False,threadOverList_:False] separate string of Rule[]s, e.g., a\[Rule]b\[Rule]c, into a List[] of separate Permuted Rule[]s, e.g., {a\[Rule]b,b\[Rule]c,b->a,c->b,c->a}. If simplerArg_\[Rule]True then Rules are reformed so -a\[Rule]b -> a\[Rule]-b and \!\(\*SuperscriptBox[\(a\), \(2\)]\)->b \[Implies] a\[Rule]Sqrt[b]. If threadOverList_\[Rule]True then exp_ like a\[Rule]{b,c} are treated as a\[Rule]b\[Rule]c. *30Aug2017*1Feb2018*22Feb2018*";
tuRuleSeparate[exp_Rule,simplerArg_:False,threadOverList_:False]:=Module[{$=exp,xList},
$=If[threadOverList,Thread[$],$/.List->xList];
(*a\[Rule]b->c Condition*)
If[tuHasNoneQ[$,xList],$=$/.Rule|RuleDelayed->List];
$=$//Flatten//DeleteDuplicates;xPrint[$];
$=$/.xList->List;xPrint[$];
$=Rule@@#&/@Permutations[$,{2}];
If[simplerArg,
$=$/. Rule[-a_,b_]->Rule[a,-b];
$=$/. Rule[cc_ a_,b_]:>Rule[a,b/cc]/;NumericQ[cc];
$={$,$//tuRuleNoPower}//Flatten
];
$=DeleteCases[$,(Rule|RuleDelayed)[a_,a_]]//DeleteDuplicates
];
(**)
Clear[tuRuleSelect];
tuRuleSelect::usage="tuRuleSelect[key_,with_:{},without_:Null][rules_] selects all Rule[]s from rules_ with the LHS equal to key_.  key_ may be a List of key_s. Rules can be further selected by with_ patterns and without_ patterns.  *5Sep2015*22Jul2017*";
tuRuleSelect[key_,with_:{},without_:Null][rules_]:=Module[{$keys,$rules},
$rules=tuExtractPattern[(Rule|RuleDelayed)[__]][tuRuleAll[{rules}]];
$keys=Flatten[{key}/.{}->\[EmptySet]]/.\[EmptySet]->{};
$rules=Cases[$rules,(Rule|RuleDelayed)[#,_]]&/@$keys//Flatten;
$rules=Select[$rules,tuHasAllQ[#,Flatten[{with}]]&];
$rules=Select[$rules,tuHasNoneQ[#,Flatten[{without}]]&]
];
tuRuleSelectReverse[rules_List][key_]:=tuRuleSelect[key][rules];(*compatible*)

(**)
tuRuleApply::usage="tuRuleApply[rules_,nosubFn_List:{}][exp_] applies rules_ on exp_.  The optional nosubFn_List is a List of variables/Patterns protected from subcomponent replacements. i.e, \!\(\*SubscriptBox[\(A\), \(0\)]\)/.A->aa is not replaced if Subscript[_,_] is a member of nosubFn_List Default nosubFn_List:tuRuleIndependentVarPattern *21Jan2016*";
tuRuleApply[rules_,nosubFn_List:tuRuleIndependentVarPattern][exp_]:=Module[{$=exp,$p,$pvar,$rhead,$pvar1,$rule},
$rule=tuRule[Flatten[{rules}]];xPrint[$rule];
(*possible protected variables*)
$p=$//tuExtractPositionPattern[nosubFn];xPrint[$p];
(*protected variables in rule_List*)
$rhead=#[[1]]&/@$rule;xPrint[$rhead];
$pvar=#[[2]]&/@$p;xPrint[$pvar];
$pvar=Select[$pvar,!tuMemberQ[#,$rhead]&];xPrint[$pvar];
(*replace protected variables in exp_*)
$pvar1=MapIndexed[#1->ToString[pvar[#2[[1]]]]&,$pvar];xPrint[{$pvar1}];
$p=$p/.$pvar1;xPrint[$p];
$rule=$rule/.$pvar1;
$=tuReplacePart[$,$p];xPrint[$,"<<",$rule];
$=$/.$rule;xPrint[$];(*Repeat*)
(*replacement Rule for pvar*)
$pvar1=Reverse[#]&/@($pvar1);xPrint[$pvar1];
$/.$pvar1
];
(**)
tuRuleVariable::usage="tuRuleVariable[rules_,variable_List:{},nosubFn_List:tuRuleIndependentVarPattern][exp_] applies rules_ to exp_ where variable_List names in rules_ are replaced with Unique[] name Pattern[]s before application.  Optional nosubFn_List specifies Pattern[]s that are to be treated as whole variables. *3Oct2016*";
tuRuleVariable[rules_,variable_List:{},nosubFn_List:tuRuleIndependentVarPattern][exp_]:=Module[{$=exp,$p,$pvar,$rhead,$pvar1,$rule,$subs=variable,$subRules={},$i,$test,$patterns},
$rule=tuRule[Flatten[{rules}]];xPrint["$rule: ",$rule];
$subs=Flatten[$subs];
(* Substitute variable_List into rules_ with Unique[] names*)
For[$i=1,$i<=Length[$subs],$i++,
$test={$subs[[$i]]->Unique[sub]};xPrint[$i," ",$test];
AppendTo[$subRules,$test];
];
$subRules=Flatten[$subRules];xPrint["subRules: ",$subRules];
$patterns=#[[2]]&/@$subRules; xPrint[$patterns];
$rule=$rule//tuRuleApply[$subRules,nosubFn]//tuAddPatternVariable[$patterns];xPrint[$rule];
$test=exp//tuRuleApply[$rule,nosubFn]
];

(*C[Rule]*)
"tuRuleSolveF[vars_,domain_:Complexes,maxExtraCondition_:0,independentVars_List:tuRuleIndependentVarPattern][rules_] operator form of tuRuleSolve[]";
tuRuleSolveF[vars_,domain_:Complexes,maxExtraCondition_:0,independentVars_List:tuRuleIndependentVarPattern][rules_]:=tuRuleSolve[rules,vars,domain,maxExtraCondition,independentVars];

tuRuleSolve::usage="tuRuleSolve[rules_,vars_,domain_:Complexes,maxExtraCondition_:0,independentVars_List:tuRuleIndependentVarPattern] Solve[]s rules_ (singley or List[]) for vars_ (Singlely or List[] of Pattern[]s) and returns Rules for vars_.  independentVars_List can be set to indicate independent variables that are Mathematica functions such as OverBar[a]. NOTE: parameter list changed to include more Solve parameters *23Mar2016*";
tuRuleSolve[rules_,vars_,domain_:Complexes,maxExtraCondition_:0,independentVars_List:tuRuleIndependentVarPattern]:=Module[{tmp,XXXX,varlist,Xs,subX,varPat,xrules,xvars=DeleteDuplicates[Flatten[{vars}]] ,independentPos,independents,independentLab,Is,IIII,subIIII,SolveArgs},
(**********)
{varlist,xrules}=ExtractPatternXpat[xvars][tuRule[{rules/.Equal->Rule},False]];
varlist=DeleteDuplicates[varlist];(*OK QQ*)
subX=Thread[Rule[varlist,(Xs=Array[XXXX,Length[varlist]])]];
(*Substitute vars_ for Solve variables*)
tmp=xrules//.subX;
xPrint["> ",tmp];
tmp=Select[tmp,!tuFreeQ[#,Xs]&];(*Remove irrelevant Rules*)
SolveArgs={tmp,Xs};xPrint["> ",SolveArgs,"\n:: ",tmp,"\n:: ",Xs];
(*independentVars need dummy labels incase unclothed independentVars is in vars_ *)
independentPos=SolveArgs//tuExtractPositionPattern[independentVars];
xPrint["independentPos > ",independentPos];
independents=#[[2]]&/@independentPos//DeleteDuplicates;
independentLab=MapIndexed[#1->IIII[First[#2]]&,independents];
subIIII=independentPos//.independentLab;
SolveArgs=tuReplacePart[SolveArgs,subIIII];xPrint[SolveArgs,"\n:: subIIII ",subIIII];
SolveArgs=SolveArgs/.Rule->Equal;(*Length[] must be 2*)
tmp=Solve[Apply[Sequence,SolveArgs],domain,MaxExtraConditions->maxExtraCondition];(*TEST*)(*
tmp=Solve[SolveArgs[[1]],SolveArgs[[2]]];*)
xPrint[SolveArgs,":",tmp];
(*Replace independentLab *)
tmp=tmp//RemovePatterns;xPrint[tmp];
tmp=tmp//.Reverse/@independentLab;
tmp=tmp//.Reverse/@subX//.Xpat[a_]->a;
tmp//Flatten
];
(**)
tuRuleDSolve::usage="tuRuleDSolve[var_,independents_][eqn_] converts eqn_ from tuDerivative notation to Mathematica-D-notation and applies DSolve. var_ indicates ALL variables that are functions of independents_ by onverting var_ to var_[independents_].  Only single equations in eqn_ are handled reliably. Currently only the first var_ is solved for in DSolve[eqn_,var_,independents_]. PROTOTYPE. *11Jan2018*22Sep2018*";
tuRuleDSolve[var_,independents_][eqn_]:=Module[{$0=eqn,$,$s,$s1},
$s=Map[#->#[Apply[Sequence,Flatten[{independents}]]]&,Flatten[{var}]];
xPrint[$0//tuRuleApply[$s],":",$s];
$=$0/.Rule->Equal//tuRuleApply[$s]//tuDerivOps2D;
$s1=#[[2]]&/@$s;
$=xDSolve[$,$s1//First,Flatten[{independents}]];(*only solve for first var_*)
xPrint[$];
$=$/.xDSolve->DSolve;
$=$/.Map[Reverse[#]&,$s];
(*Reverse substitution is incompatible in some cases*)
$
];
tuRuleDSolveIndVar::usage="tuRuleDSolveIndVar[var_,independents_][eqn_] applies tuRuleDSolve wrapped in tuOpIndependentVar";
tuRuleDSolveIndVar[var_,independents_][eqn_]:=tuOpIndependentVar[tuRuleDSolve,op$[var,independents][eqn]]
(**)

tuRuleDenominator0::usage="tuDenominator0[exp_] removes Denominator from Rule[]s, DelayedRule[]s, Equal[] expressions, e.g., a/b\[Rule]0 \[DoubleLongRightArrow] a\[Rule]0 *15Nov2017*";
tuRuleDenominator0[exp_]:=Module[{$=exp},
$=$/. a_==0:>Numerator[a]==0/;Numerator[a]/Denominator[a]===a;
$=$/.( a_->0):>Numerator[a]->0/;Numerator[a]/Denominator[a]===a;
$=$/.( a_:>0):>Numerator[a]:>0/;Numerator[a]/Denominator[a]===a
];
(*TEST
$0=Sqrt[1+tuDs[d][y,t]^2]
tuEulerEquation[y,t][$0]

$1=tuDs[d][$0,tuDs[d][y,t]]//tuDerivativeExpand[{}]
$2=tuDs[d][$0,y]//tuDerivativeExpand[{}]//tuDArgSwitch[{t},{y}]//tuDerivativeExpand[{}]
$=tuDs[d][$1,t]-$2\[Rule]0//tuDerivativeExpand[{}]//Simplify
$=$//tuRuleDSolveIndVar[y,t]
*)
(**)
tuOpIndependentVarActivate::usage="tuOpIndependentVarActivate[independentVars_List:tuRuleIndependentVarPattern][exp_] evaluates exp_ containing Inactive[] operations after independentVars_List variables are replaced by dummy variables so as not to confuse Mathematica operators (e.g., DSolve) with duplicate symbol in exp_ (e.g., subscript as in DSolve[\!\(\*SubscriptBox[\(a\), \(\[CurlyPhi]\)]\)\[CurlyPhi][t]+b==0,\[CurlyPhi][t],t]). independentVars_List contains Pattern[]s whose internal symbols are considered independent of the calculation (e.g. subscripts).  *16Nov2017*";
tuOpIndependentVarActivate[independentVars_List:tuRuleIndependentVarPattern][exp_]:=Module[{$=exp,$h ,$hcnt=1,$seq,independentPos,independents,independentLab,Is,IIII,subIIII},
tuOpIndependentVarActivate::independents="Independents: `1` ";
(*independentVars need dummy labels*)
independentPos=$//tuExtractPositionPattern[independentVars];
independents=#[[2]]&/@independentPos//DeleteDuplicates;
independentLab=MapIndexed[#1->IIII[First[#2]]&,independents];
Message[tuOpIndependentVarActivate::independents,independents];
subIIII=independentPos//.independentLab;
$=ReplacePart[$,subIIII];(*Print[$,"::",subIIII,"::",$[[0]]]*);
$h=Head[$];While[!MatchQ[$h,Inactive[f_]],$h=Head[$h];$hcnt++];
$seq=Apply[Sequence,Table[0,$hcnt]];
$[[$seq]]=Activate[$[[$seq]]];(*
Print[$,"::",$hcnt,"::",$h\[Rule]Activate[$h]];*)
(*Replace independentLabs *)
$=$//.Reverse/@independentLab
];
(*Ex: 
$=Inactive[DSolve][Subscript[a, \[CurlyPhi]]\[CurlyPhi][x]+b^\[CurlyPhi]\[Equal]0,\[CurlyPhi][x],x]
$//tuOpIndependentVarActivate[{Subscript[_, _],_^_}]
*)
tuOpIndependentVar::usage="tuOpIndependentVar[opname_?(Head[#]=!=List&),op_?(tuHasAnyQ[Head[#],op$]&),independentVars_List:tuRuleIndependentVarPattern] applies tuOpIndependentVarActivate[independentVars_List:tuRuleIndependentVarPattern][exp_] given opname_ and op_(must be the statement opname[] in the form op$[]) where op$ will be replace by Inactive[opname] for evaluataion.  This is a more convenient interface to tuOpIndependentVarActivate[independentVars_List:tuRuleIndependentVarPattern][exp_] *13Dec2017*";
tuOpIndependentVar[opname_?(Head[#]=!=List&),op_?(tuHasAnyQ[Head[#],op$]&),independentVars_List:tuRuleIndependentVarPattern]:=Module[{},
op/.op$->Inactive[opname]//tuOpIndependentVarActivate[independentVars]
];

Clear[tuRuleEliminate];
tuRuleEliminate::usage:="tuRuleEliminate[pattern_List][rules_List] composes rules from rules_List of form Map[Rule[tuRuleSolve[{rule_[#]},#],pattern_]. Works for Dot[] patterns.  WARNING: The order of rules_List determines the order in which patterns are substituted back into rules_.  Try tuEliminate if this Module does not work. *18Jun2015*";
tuRuleEliminate[pattern_][rules_]:=Module[{$r=tuRule[{rules}],$rp={},$p=Flatten[{pattern}]},
(*Apply simple pattern_ rules first.*)
xPrint["$r>",$r,">",$p];
$rp=Map[tuExtractPositionPattern[{#->_,_->#}][$r]&,$p];xPrint["$rp>",$rp];
If[$rp!={{}}&&$rp!={},
$rp=Map[#[[1,1]]&,$rp]//DeleteDuplicates;xPrint[">",$p," ",$rp," ",$r,"<"];
$rp=Map[tuRuleSolve[$r[[#]],$p]&,$rp];
$rp=DeleteCases[$rp,HoldPattern[Solve[_,_]]]//Flatten;

$rp=Select[$rp,tuHasNoneQ[#[[2]],$p]&];
$rp=$rp//tuRule;
If[Length[$r]>1,
$r=$r//.$rp,
$r=$rp];
];
(*Inspect each rule for possible pattern rule.*)
$rp=tuExtractPositionPattern[$p][$r];xPrint["$p>",$p," $rp>",$rp," $r>",$r,"<"];
$rp=Map[#[[1,1]]&,$rp]//DeleteDuplicates;
xPrint["$rp>",$rp];
$rp=Map[tuRuleSolve[$r[[#]],$p]&,$rp];xPrint["$p> ",$p," $rp>",$rp];
$rp=DeleteCases[$rp,HoldPattern[Solve[_,_]]]//Flatten;
xPrint["$r> ",$r," $rp>",$rp];

$rp=Select[$rp,tuHasNoneQ[#[[2]],$p]&];
$rp=$rp//tuRule;
xPrint["$p> ",$p," $rp>",$rp];
If[Length[$r]>1,
$r=$r//.$rp,
$r=$rp
];
$r=DeleteCases[$r,a_->a_]//tuRule
];

(**)
tuEliminate2::usage="tuEliminate2[,vars_,independentVars_List:tuRuleIndependentVarPattern][rules_List] applies Eliminate[] to a list of rules_ eliminating vars_.  Simpler version of tuEliminate. *4Jan2019*";
tuEliminate2[vars_,independentVars_List:tuRuleIndependentVarPattern][rules_List]:=
Module[{$=rules},
$=$//tuRule1;
$=$/.toEqual;
$=tuOpIndependentVar[Eliminate,op$[$,vars],independentVars];
$
]
(**)
tuEliminate::usage="tuEliminate[rules_,vars_,independentVars_List:tuRuleIndependentVarPattern] applies Eliminate[] to a list of rules_ eliminating vars_. Recognizes negative powers of vars_.  Variables Matching independentVars_ are treated independent variables. Try tuEliminate2 or tuRuleEliminate if this Module does not work. *23May2014";
tuEliminate[rules_,vars_,independentVars_List:tuRuleIndependentVarPattern]:=Module[{tmp,XXXX,varlist,Xs,subX,varPat,xrules,xvars=DeleteDuplicates[Flatten[{vars}]] ,independentPos,independents,independentLab,Is,IIII,subIIII,SolveArgs,ivars,xpower},
xpower[rule_Rule]:=Module[{pow,tmp=rule},(*eliminate negative powers in rule*)
tmp=tmp/.Power[a,n_]:>power[a,n]/;n<0;
pow=tmp//tuExtractPattern[power[a,_]];
tmp=If[pow=!={},
pow[[1,2]]=-pow[[1,2]];pow= pow[[1]]#&/@tmp;pow/.power->Power,
tmp];
tmp
];
(**********)
xrules=tuRule[{rules}/.{Equal->Rule,And->List}];
(*Eliminate 1/(vars_)^n from denominator in rules_ *)
ivars=1/#&/@xvars;
xrules=xpower/@xrules;
(**)
{varlist,xrules}=ExtractPatternXpat[xvars][xrules];
xPrint["VV",{varlist,xrules}];
varlist=DeleteDuplicates[varlist];(*OK QQ*)
subX=Thread[Rule[varlist,(Xs=Array[XXXX,Length[varlist]])]];xPrint[subX];
(*Substitute vars_ for Solve variables*)
tmp=xrules//.subX;
SolveArgs={tmp,Xs};
(*independentVars need dummy labels incase unclothed independentVars is in vars_ *)
independentPos=SolveArgs//tuExtractPositionPattern[independentVars];
independents=#[[2]]&/@independentPos//DeleteDuplicates;
independentLab=MapIndexed[#1->IIII[First[#2]]&,independents];
subIIII=independentPos//.independentLab;
SolveArgs=ReplacePart[SolveArgs,subIIII];
SolveArgs=SolveArgs/.Rule->Equal;
tmp=Eliminate[Apply[Sequence,SolveArgs]];
(*Replace independentLab *)
tmp=tmp//RemovePatterns;
tmp=tmp//.Reverse/@independentLab;
tmp=tmp//.Reverse/@subX//.Xpat[a_]->a;
tmp//Flatten
];

(*Rewrites (simple) rule_ in form  var_\[Rule] ..  .  var_ may be a pattern but must only match one item in rule.  var_ needs to be a variable that can be Solved for in rule_.  
This Module does not work with Power or Sqrt[ ] .  Only uses first solution of Solve  *13Dec2012*)
RuleX[rule_Rule,var_]:=Module[{tmp=Apply[Equal,rule],XXXXX,list},
list=DeleteDuplicates[First[ExtractPatternXpat[var][rule]]];
If[list=!={},
tmp=tmp//.var->XXXXX;
tmp=Solve[tmp,XXXXX]//First;
If[Length[list]==1,
tmp=tmp//.XXXXX->list[[1]],
tmp=tmp//.XXXXX->var
];
tmp[[1,2]]=tmp[[1,2]]/.Pattern->xPattern/.xPattern[x_,b_]->x;
tmp/.Xpat[a_]->a,
{}(*Return {} if var_ \[Element] rule_Rule *)
]
];
(*
As RuleX but returns all solutions of Solve. *10Jan2013*)
RuleXall[rule_Rule,var_]:=Module[{tmp=Apply[Equal,rule],XXXXX,list},
list=DeleteDuplicates[ExtractPattern[rule,var]];
tmp=tmp//.var->XXXXX;
tmp=Solve[tmp,XXXXX];
If[Length[list]==1,(*In general only one var_*)
tmp=tmp//.XXXXX->list[[1]],
tmp=tmp//.XXXXX->var(*For cases where there may be a choice.*)
];
tmp//RemovePatterns
];
(* Applies RuleX[rule_,var_] to a list of Rules *13Dec2013*)
RuleX[rules_List,var_List]:=Module[{pos,sub,tmp=rules //Flatten },
tmp=tmp/.Rule->Equal;
tmp=Solve[tmp,var]//Flatten
];
(* Applies RuleX[rule_,var_] to a list of Rules *13Dec2013*)
RuleX[rules_List,var_]:=Module[{pos,sub,tmp={rules} //Flatten },
tmp=RuleX[#,var]&/@tmp//Flatten
];
RuleX2[rules_List,var_]:=RuleX[rules,var];(*Backward compatibility*)
(*Rewrites (simple) rule_ in form  var_\[Rule] ..   var_ may be a pattern but must only match one item in rule.  Returns all possible Solutions. *)RuleX1[rule_Rule,var_]:=Module[{tmp=Apply[Equal,rule],XXXXX,list,tmpx},
list=DeleteDuplicates[ExtractPattern[rule,var]];(*list of var*)
tmpx=tmp//.var->XXXXX;
tmpx=Solve[tmpx,XXXXX];
If[Length[list]==1(*one var*)&&Length[tmpx]>0,
(*\[Exists] some solution, replace*)
tmpx=tmpx/.XXXXX->list[[1]];
,
tmpx={Apply[Rule,tmp]}(*no solution*);
];
tmp=tmpx/.Pattern->xPattern/.xPattern[x_,b_]->x;
tmp//Flatten
];

(*
Applies RuleX converting patternvar_ on LHS to Pattern. *13Dec2012*)
RuleX[rules_, var_,patternvar_]:=Module[{},
RuleX2PatternVar[   RuleX[{rules},var],  patternvar  ]//Flatten
];

RuleX1[rules_, var_,patternvar_]:=Module[{},
RuleX2PatternVar[   RuleX[{rules},var],  patternvar  ]//Flatten
];

(* Changes straight variables in left-hand part of rules_ to Pattern as specified by patternvars_  *)
tuAddPatternVariable::usage="tuAddPatternVariable[variables_,Btype_:Blank][rules_] Converts variables_ on LHS of rules_ into Patterns (Btype_ option is available.). Syntax option: tuAddPatternVariable[rules_,variables_].  Rules/Variables may be a Lists. *24Dec2014*";

tuAddPatternVariable[ variables_ , Btype_ : Blank  ] [rules_]:=Module[{tmp=rules,pvar,sub,xRule},
pvar=Flatten[{variables}];
sub=Map[#->Pattern[#,Btype[]] &,pvar];
tmp=tmp/.Rule[a_,b_]:>xRule[a/.sub,b];
tmp=tmp//.xRule->Rule;
tmp=tmp/.RuleDelayed[a_,b_]:>xRule[a/.sub,b];
tmp=tmp//.xRule->RuleDelayed
];

(**)
tuRuleFromTable::usage="tuRuleFromTable[table_][var_] makes Rule[]s from a 2-D table where the first row defines column parameter labels and the first column defines variables referenced by var_.  The result is a set of Rule[]s for each column parameter of the var_ specified. e.g. table={{_,A,B},{var1,a1,b1},{var2,a2,b2}} tuRuleFromTable[table][var2]\[Rule]{A->a2,B->b2} *9Mar2016*";
tuRuleFromTable[table_][var_]:=Module[{head=table[[1]],tmp=table,pattern,row},
pattern=Table[_,{Length[head]}];
pattern[[1]]=var;
tmp=Drop[tmp,1];
row=Cases[tmp,pattern]//First;
Drop[Thread[Rule[head,row]],1]
];

(**)
tuRuleOp::usage="tuRuleOp[operator_][rules_] acts with operator_ on rules_List and outputs a Rule which is a operator_ combination of right-hand terms to a operator_ combination of left-hand terms. e.g. tuRuleOp[fn][{a->b,c->d}]\[LongRightArrow]{fn[a,c]\[Rule]fn[b,d]]} *12Mar2014*12Jan2018*";
tuRuleOp[operator_][rules_List]:=Module[{$=rules,$s,head},
head=Head[$[[1]]];(*default Rule for output*)
$=$/.rr:Rule|RuleDelayed->List;
$={Map[#[[1]]&,$],Map[#[[2]]&,$]};
$=$/. {a__,b__}:>{Apply[operator,a],Apply[operator,b]};
$=Apply[head,$]
];
OpRules[operator_,rules_List]:=tuRuleOp[operator][rules];(*Compatibility*)
(**)
tuRuleOpApply::usage="tuRuleOpApply[operator_][rules_] applies operator_ over both arguements of Rule[] in rules_. 12Jan2108*";
tuRuleOpApply[operator_][rules_List]:=Module[{},
rules/.(rr:Rule|RuleDelayed)[a_,b_]->rr[operator[a],operator[b]]
];

tuRuleSubtract::usage="tuRuleSubtract[rules_List] list of Rules and output a Rule which the first Rule minus the subsequent Rules for the right and left Rule terms. *21Jun2015*";
tuRuleSubtract[rules_List]:=Module[{tmp,head,first,rest},
head=Head[first=First[rules]];
rest=Rest[rules];
first=Apply[List,first];
rest=-Map[Apply[List,#]&,rest];
tmp=Flatten[{{first},rest},1];
tmp=MapThread[Plus,tmp];
Apply[head,tmp]
];
SubtractRules[rules_List]:=tuRuleSubtract[rules];(*Compatibility*)
(**)
tuRuleAdd::usage="tuRuleAdd[rules_List] returns a sum of Left Hand Side \[Rule] sum of Right Hand Side of rules_List *13Jul2016*";
tuRuleAdd[rules_List]:=tuRuleOp[Plus][rules];
AddRules[rules_List]:=tuRuleAdd[rules]; (*Compatibility*)
(**)
tuRuleTimes::usage="tuRuleTimes[rules_List]  return a Rule that is a product of right-hand terms to a product of left-hand terms. *13Jul2016*";
tuRuleTimes[rules_List]:=tuRuleOp[Times][rules];
TimesRules[rules_List]:=tuRuleTimes[rules](*Compatibility*)
(**)
tuRuleDivide::usage="tuRuleDivide[rules_List] returns ratio of first two Rules in rules_List. ";
tuRuleDivide[rules_List]:=tuRuleOp[#1/#2&][rules];
DivideRules[rules_List]:=tuRuleDivide[rules ];(*Compatibility*)
(**)

(*Solves vars_ for a set of rules_ *)
SolveRules[rules_,vars_]:=Solve[(rules//.Rule->Equal),vars];

(**)
tuPatternRemove::usage="tuPatternRemove[exp_] removes Pattern[a_,Blank[]|BlankSequence[]]:>a in all of exp_ *24Nov2013";
tuPatternRemove[exp_]:=Module[{tmp=exp,xPattern},
tmp=tmp/.PatternTest->xPatternTest/.xPatternTest[a_,b_]->a;
tmp=tmp//.Pattern->xPattern//.Blank->xBlank//.BlankSequence->xBlankSequence;
tmp=tmp//.xPattern[a_,xBlank[]|xBlankSequence[]]->a;
tmp=tmp/.xPattern->Pattern
];
RemovePatterns[exp_]:=tuPatternRemove[exp];(*Compatibility*)

(*
RuleVarPattern[var_List][rule_Rule] converts var in Rule to Pattern[var,Blank[]]*)
RuleVarPattern[var_List][rule_Rule|rule_RuleDelayed]:=Module[{tmp=rule[[1]]},
tmp=tmp/.Map[#->Pattern[#,Blank[]]&,var];
tmp=tmp->rule[[2]]
];
(*
RulesVarPatterns[var_List][exp_] converts var_List in exp_ containing Rule to Pattern[var,Blank[]] DOES NOT RECOGNIZE ALTERNATIVE exp ARGUEMENTS *7Dec2014*)
RulesVarPattern[var_List][exp_List|exp_Rule|exp_RuleDelayed]:=Module[{rulepos,tmp=exp},
If[Head[exp]===List,
rulepos={tmp}//tuExtractPositionPattern[Rule[a_,b_]];
rulepos=Map[#[[1]]->RuleVarPattern[var][#[[2]]]&,rulepos];
tmp=ReplacePart[{tmp},rulepos][[1]]
,
tmp=exp[[1]];
tmp=tmp/.Map[#->Pattern[#,Blank[]]&,var];
tmp=tmp->exp[[2]]
];
tmp
];
(*
RulePatternCondition[rule_Rule|rule_RuleDelayed,pvars_List,condition_Hold] converts Rule into RuleDelayed with condition_Hold *24Nov2014*)
RulePatternCondition[rule_Rule|rule_RuleDelayed,pvars_List,condition_Hold]:=Module[{tmp=rule},
tmp=tmp//RuleX2PatternVar[pvars];
tmp[[2]]=tmp[[2]]/;condition;
tmp/.Rule->RuleDelayed//ReleaseHold
];
(*
RuleAddCondtion[condition_][rule_] adds condition_ to rule_.  *13Dec2013*)
RuleAddCondtion[cond_][rule_]:=Module[{tmp=rule},
tmp=tmp/.Rule[a_,b_]->xRule[a,xCondition[b,cond]];
tmp/.xCondition->Condition/.xRule->RuleDelayed//ReleaseHold];

tuRuleSimplify::usage="tuRuleSimplify[exp_] Simplify[]s Rules in exp_.  NOTE: Simplify[] sometimes produces 0\[Rule]something. *11Jan2015*8Arp2018*";
tuRuleSimplify[exp_]:=Module[{$=exp},
$=$/.Rule->Equal//Simplify;
$=$/.Equal->Rule;
$=$//tuRuleRHS0//Simplify;
$=$/. Rule->xRule/.xRule[a_?NumericQ b_,0]->Rule[b,0];
$=$/.xRule->Rule
];
tuSimplifyRules[exp_]:=tuSimplifyRules[exp](*Compatibility*)
(**)
Clear[tuSolve];
tuSolve::usage="tuSolve[exp_] Solve[]s exp_ (Rule|Equal) assuming all variables are non-zero. It returns (all solutions from Solve[]) \[Implies] (solutions when all variable are non-zero).  Intended to Solve[] exp_ where a term can be factored out,
	i.e., a (b-c)\[Rule]0  will produce b\[Rule]c. *26Mar2016*";
tuSolve[exp_]:=Module[{$s,$,$0,$var},
(*get all variables*)
$s=exp/.Times|Plus|Equal|Rule->List//Flatten;
$s=$s/.(1/v_)->v//DeleteDuplicates//Select[#,!NumericQ[#]&]&;
$var=$s;xPrint[$s];
$s=#!=0&/@$s/.List->And;xPrint[$s];
$=exp/.Rule->Equal//Simplify;
$0=$=Solve[$,$var,Complexes];xPrint[$];
$=$/.Rule->Equal;
$=Refine[$,Assumptions->$s];
$=Select[$,FreeQ[#,False]&]//Flatten;
$0\[Implies]$
];

tuRuleFirstLast::usage="tuRuleFirstLast[exp_Rule] returns a Rule with only the First and Last elements of a nested Rule. e.g. tuRuleFirstLast[a\[Rule]b\[Rule]c] \[DoubleLongRightArrow] a\[Rule]c *6Sep2016*";
tuRuleFirstLast[exp_Rule]:=Flatten[exp/.Rule->List]//{#[[1]],#[[-1]]}&//Apply[Rule,#]&;
(**)
tuRuleFlatten::usage="tuRuleFlatten[rules_] Flatten Rules in rules_. EG. (a\[Rule]b)\[Rule]c \[Implies] {a\[Rule]c,a\[Rule]b} *11Jul2018*";
tuRuleFlatten[rules_]:=Module[{$r=Flatten[{rules}],$s},
$s={Rule[a_,b_]:>{Rule[a,b[[1]]],b}/;Head[b]===Rule,
Rule[a_,b_]:>{Rule[a[[1]],b],a}/;Head[a]===Rule
};
$r=$r//.$s//Flatten//DeleteDuplicates
];
(*TEST
{a\[Rule]b\[Rule]c\[Rule]d[dd\[Rule]x],
(a\[Rule]b\[Rule]e)\[Rule]c
}
%//tuRuleFlatten
*)tuRuleRHS0::usage="tuRuleRHS0[rules_] rearranges simple Rule[] or Equal[]s so that the RHS is 0 as  Rule[,0]s. *12Aug2017*";
tuRuleRHS0[rules_]:=Module[{$r=Flatten[{rules}]},
Map[
If[tuHasAnyQ[Head[#],{Rule,Equal}],First[#]-Last[#]->0,#]&,tuRuleFlatten[$r]]
];

tuRuleRHS0factor::usage="tuRuleRHS0factor[RULES_] applies tuRuleRHS0[RULES_] and factors the LHS into expressions \[Rule] 0 if possible, EG: a (b+c)\[Rule]d a \[LongRightArrow] {a\[Rule]0,b+c-d\[Rule]0} *10Apr2018*";
tuRuleRHS0factor[RULES_]:=Module[{$=Flatten[{RULES}]},
$=$//tuRuleRHS0//Simplify;
$=Map[If[Head[#[[1]]]===Times,Thread[Apply[List,#[[1]]]->0],#]&,$];
$
];
(*TEST $={a (b+c)\[Rule]d a,a b c\[Rule]b c, a b \[Rule] c}
$//tuRuleRHS0factor
*)
tuRuleDelayAdd::uage="tuRuleDelayAdd[rule_Rule,conditions_] changes rule_Rule into RuleDelayed with  conditions_ added *15Jan2018*";

tuRuleDelayAdd[rule_Rule,conditions_]:=Module[{$,xRuleDelayed},
$=rule/.Rule->xRuleDelayed;
xRuleDelayed[$[[1]],$[[2]]/;conditions]/.xRuleDelayed->RuleDelayed
](*
TEST
tuRuleDelayAdd[a\[Rule]b,c]*)
tuRuleNoConditions[rules_]:=rules/.Condition->xCondition/.xCondition[a_,b_]->a;


(*routines to accumulate and select Rules used in .nb*)
accum[label_][item_]:=Block[{},$def[label]=tuAppendUniq[item][$def[label]];""];
select::usage="select[label_][heads_,with_:{},without_:Null] selects Rule[] from Rule[]s accumulated $def[] (user defined, e.g., $def['Label']). The Rule[] selection is modified by with_ and without_ specifications.  If without_ \[Rule] all then all Rule[]s are output. *6Jul2017*";
select[label_][heads_,with_:{},without_:Null]:=Module[{$},
$=tuRuleSelect[Flatten[{Map[{#,#[_],#[_][_]}&,Flatten[{heads}]]}]][$def[label]];
$=$//Select[#,tuHasAllQ[#,Flatten[{with}]]&]&;
$=$//If[without===Null,Last[#],Select[#,tuHasNoneQ[#,Flatten[{without}]]&]]&
];

$defID:=NBname["stub"];
$def[$defID]={};
accumDef:=accum[$defID];
selectDef:=select[$defID];


(* ::Input::Initialization:: *)
tuPowerFactor::usage="tuPowerFactor[exp_,sep_:CenterDot] factor summed exponential into individual terms separated by sep_, eg., \!\(\*SuperscriptBox[\(A\), \(b + c\)]\)\[Rule]\!\(\*SuperscriptBox[\(A\), \(b\)]\)\[CenterDot]\!\(\*SuperscriptBox[\(A\), \(c\)]\) *22Nov2018*";

tuPowerFactor[exp_,sep_:CenterDot]:=Module[{$},
$=exp/.pp:Power[e_,Plus[__]]:>(pp/.Plus->xPlus/.Power[e,xPlus[a__]]:>Apply[sep,e^{a}]/.xPlus->Plus)
];
(*
moveOut[term_] and moveIn[term_] are examples of moving term_ outside and inside op[_ term_,_] DOESN'T match NumberQ[_].  *14Mar2014*)
moveOut[term_]:=(op:xProduct|xSum)[a_  b_,i_]:>a op[b,i]/;ListMemberQ[a,Flatten[{term,1/#&/@{term}}]];
moveIn[term_]:=a_ (op:xProduct|xSum)[b_,i_]:>op[a b,i]/;ListMemberQ[a,Flatten[{term,1/#&/@{term}}]];

(*
independentOf[pattern_List][exp_] Removes elements dependent of pattern_List in the FreeQ sense.*3Mar2013*)
independentOf::usage=
"independentOf[pattern_List][exp_] removes elements dependent on pattern_List in the FreeQ sense. *3Mar2013*";
independentOf[pattern_List][exp_]:=Module[{head,tmp,TF},
head=Head[exp];
If[head =!= Symbol,
tmp=Apply[List,exp];
TF=Map[ListFreeQ[#,pattern]&,tmp];
TF=Map[If[!TF[[#]],{#}]&,Range[Length[TF]]];
TF=DeleteCases[TF,Null];
TF=Delete[tmp,TF];
If[Length[TF]>0,Apply[head,TF],If[head ===Plus,0,1]],
(*else*)
If[ListFreeQ[exp,pattern],exp,1]
]
];
(*
dependentOn[pattern_List][exp_] Removes Level 0 terms that are independent (in the FreeQ sense) of elements in pattern_List. *3Mar2013*)
dependentOn::usage=
"dependentOn[pattern_List][exp_] removes elements independent of pattern_List in the FreeQ sense. *3Mar2013*";
dependentOn[pattern_List][exp_]:=Module[{head,tmp,TF},
head=Head[exp];
If[head =!= Symbol,
tmp=Apply[List,exp];
TF=Map[ListFreeQ[#,pattern]&,tmp];
TF=Map[If[TF[[#]],{#}]&,Range[Length[TF]]];
TF=DeleteCases[TF,Null];
TF=Delete[tmp,TF];
If[Length[TF]>0,Apply[head,TF],If[head ===Plus,0,1]],
(*else*)
If[ListFreeQ[exp,pattern],1,exp]
]
];
(**)
tuSumSimplify::usage="tuSumSimplify[independent_List][exp_] converts Sum[]\[Rule]xSum[], move terms within xSum[] of exp_. Moves patterns in independent_List to outside xSum[], and return a xSum[] expressions.  *20Oct2013**15Oct2017*";
tuSumSimplify[independent_List:{}][exp_]:=Module[{tmp=exp,tmp1},
tmp=tmp/.Sum->xSum;
While[tmp =!=tmp1,
tmp1=tmp;
tmp=tmp//.tuOpDistribute[xSum];
tmp=tmp//tuOpSimplifyFirst[xSum,independent];
tmp=tmp//.xSum[a_ ,b__]:>(a  xSum[1,b]/;NumericQ[a]);
tmp=tmp/.xSum[0,b__]->0;
tmp=tmp/.xSum[a_,b__]:>dependentOn[independent][a]xSum[ independentOf[independent][a],b];
];
tmp
];
simpleSum[independent_List]:=tuSumSimplify[independent];
(**)
tuSum2Parts::usage="tuSum2Parts[limits_List][exp_] replaces Sum[]s in exp_ with a sum of Sum[]s where each limit is replaced each one of limits_List. Return xSum[] expressions. *6Dec2017*";
tuSum2Parts[limits_List][exp_]:=Module[{$=exp,$parts,a},
$parts=xSum[a,#]&/@limits;
$parts=xSum[a,_]->Apply[Plus,$parts]//tuAddPatternVariable[a];
$=$/.Sum->xSum/.$parts
];
(**)
Clear[tuSumKroneckerDelta]
tuSumKroneckerDelta::usage="tuSumKroneckerDelta[refine_:{},sym_:\[Delta]][exp_] applies (1) tuSumSimplify[] to exp_, (2) replaces Tensor[sym_,_,_] \[Rule] KroneckerDelta[_,_], (3) replaces xSum\[Rule]Sum so Mathematica can do the work, (4) applies Refine[_,refine_] *13Oct2017*";
tuSumKroneckerDelta[refine_:{},sym_:\[Delta]][exp_]:=Module[{$=exp},
$=$//tuSumSimplify[];
$=$/.Tensor[sym,up_,dn_]:>KroneckerDelta[Apply[Sequence,DeleteCases[Flatten[{up,dn}],Void]]];
$=$/.xSum->Sum;
$=Refine[$,refine];
$
];

(*Distribute xSum over ExpandAll[sumand] of Sum[].  Returns xSum[]. 
3.1.2010*)
DistributeSum[exp_]:=Module[{tmp,tmp1=NULL,DEBUG=0},
tmp=exp/.Sum->xSum;
While[tmp=!=tmp1,
If[DEBUG>0,Print["DistributeSum: ",tmp]];
tmp1=tmp;
tmp=tmp/.xSum[a_,c__]:>xSum[ExpandAll[a],c];
tmp=tmp/.xSum[a_,b__]:>Map[xSum[#,b]&,a]/;Head[a]===Plus;
];
tmp
];
(**)
tuDistributeOp::usage="tuDistributeOp[Op_,func_:Plus][exp_] applies Distribute[Op_[],func_] on every Pattern matched by Op_[__]. EG:DistributeOp[IntegralOp[_,_]][IntegralOp[{{x}},a+b]]->IntegralOp[{{x}},a]+IntegralOp[{{x}},b] *29Jan2014*";
tuDistributeOp[Op_,func_:Plus][exp_]:=Module[{tmp=exp,pos,i},
pos=tmp//tuExtractPositionPattern[Op];
For[i=1,i<=Length[pos],i++,
pos[[i,2]]=Distribute[pos[[i,2]],func]
];
ReplacePartTU[tmp,pos]
];
DistributeOp[Op_][exp_]:=tuDistributeOp[Op][exp];

(*
ThreadOp[Op_][exp_] applies Thread on pattern Op_[_] in exp_.  Accomodates variation for IntegralOp. Must indicate arguements as Op_[_,_]. *5Sep2014*)
ThreadOp[Op_][exp_]:=Module[{tmp={exp},pos,i,xInt,xOp},
pos=tmp//tuExtractPositionPattern[Op];
xOp=Op;
If[Head[Op]===IntegralOp,pos=pos/.IntegralOp[a_,b_]->xInt[a][b];xOp=xInt[_][_]];
For[i=1,i<=Length[pos],i++,
pos[[i,2]]=pos[[i,2]]//.ii:xOp:>Thread[ii];
];
If[Head[Op]===IntegralOp,pos=pos/.xInt[a_][b_]->IntegralOp[a,b]];
ReplacePartTU[tmp,pos]//First
];

(**)
tuArgSimplify::usage="tuArgSimplify[OP_,constants_List][exp_] simplifies arg_ in OP_[arg_] functional expressions in exp_ by first DistributeOp[OP_][exp_] and removing constants_List and NumericQ[] elements in arg_ outside of OP_.  OP_ must be specified as fn[_].\[IndentingNewLine]Usage:  xOp[f+g,c+d e]//simpleOp[xOp[__],{d}] \[Rule]\[IndentingNewLine]{xOp[f,c]+d xOp[f,e]+xOp[g,c]+d xOp[g,e]}   *2Jul2014*";
tuArgSimplify[OP_,constants_List:{}][exp_]:=Module[{tmp=exp,headOp=OP,xop,sub,one},
tmp=tmp//.tuOpDistribute[OP];xPrint[tmp,":",headOp];
tmp=tmp/.headOp->xop;xPrint[xop," : ",tmp];
(*Op with multiple arguements*)
sub=xop[b1___,c_^(n_:1)  a_,b___]:>c^n xop[b1,a,b]/;ListMemberQ[c,constants]||ListMemberQ[c,constants]||NumericQ[c];
tmp=tmp//.sub;
(*Op with multiple arguements but single arguement as constant*)
sub=xop[b1___,c_^(n_:1) ,b___]:>c^n xop[b1,1,b]/;ListMemberQ[c,constants]||ListMemberQ[c,constants]||NumericQ[c];
tmp=tmp//.sub;
(*Op with single arguement*)
sub=xop[c_^(n_:1)]:>c^n/;ListMemberQ[c,constants]||ListMemberQ[c,constants]||NumericQ[c];
tmp=tmp//.sub;
tmp=tmp/.xop->headOp;xPrint[tmp];
tmp
];
simpleOp[OP_,constants_List:{}][exp_]:=tuArgSimplify[OP,constants][exp];
tuSimpleOp[OP_,constants_List:{}][exp_]:=tuArgSimplify[OP,constants][exp];
(**)
tuArgAdd::usage="tuArgAdd[op_,arg_][exp_] adds arguments specified by arg_ to op_[]s found in exp_.  op_ may be Pattern[]s or Alternative Pattern[]s. E.G., \!\(\*SubscriptBox[\(op\), \(A\)]\)+\!\(\*SuperscriptBox[\(op\), \(B\)]\)//tuArgAdd[\!\(\*SubscriptBox[\(a_\), \(_\)]\)|\!\(\*SuperscriptBox[\(a_\), \(_\)]\),{r,t}]\[LongRightArrow]\!\(\*SubscriptBox[\(op\), \(A\)]\)[r,t]+\!\(\*SuperscriptBox[\(op\), \(B\)]\)[r,t]  *19Jan2018*";
tuArgAdd[op_,arg_][exp_]:=Module[{$arg},
$arg=Apply[Sequence,Flatten[{arg}]];
exp/.oo:op->oo[$arg]
];
tuArgRemove::usage="tuArgRemove[op_,arg_:__][exp_] removes arguments specified by arg_ from op_[]s found in exp_.  op_ may be Pattern[]s or Alternative Pattern[]s. E.G., \!\(\*SubscriptBox[\(op\), \(A\)]\)[t,r]+\!\(\*SuperscriptBox[\(op\), \(B\)]\)[t,r]//tuArgRemove[\!\(\*SubscriptBox[\(a_\), \(_\)]\)|\!\(\*SuperscriptBox[\(a_\), \(_\)]\),{__}]\[LongRightArrow]\!\(\*SubscriptBox[\(op\), \(A\)]\)+\!\(\*SuperscriptBox[\(op\), \(B\)]\)  *19Jan2018*";
tuArgRemove[op_,arg_:__][exp_]:=Module[{$arg},
$arg=Apply[Sequence,Flatten[{arg}]];
exp/.(oo:op)[$arg]->oo
]
(**)

(*Adds columns of tablex_ to the right of table.*)
TableAddColumn[table_][tablex_]:=Module[{head=table[[1]],tmp=table,pattern,row,mname="TableAddColumn",DEBUG=1},
tmp=MapThread[Join,{tmp,tablex}];
tmp
];

(**)
tuExtractPositionPattern::usage="tuExtractPositionPattern[pattern_,maxlevel_:Infinity][exp_] extracts a List of {Positions,items} that match pattern_ in exp_ up to Level maxlevel_.  Returns a List[ pos1->match1,pos2->match2,... ]. pattern_ may be a List or Alternatives. *3Nov2016*)";
tuExtractPositionPattern[pattern_,maxlevel_:Infinity][exp_]:=Module[{xpattern=pattern,pos,list,tmp,xList},
If[Head[xpattern]==List,(*always change List of patterns to Alternatives*)
xpattern=Apply[Alternatives,xpattern];xPrint[xHead[xpattern]]
];(*
If[Head[xpattern]=!=List,xPrint[Head[xpattern]];*)
(*not List of patterns*)
pos=Position[exp,xpattern,{0,maxlevel},Heads->True];
list=Extract[exp,pos];
tmp=Thread[Rule[pos,list]];
xPrint["X ",tmp,", ",xpattern,", ",list,", ",pos];
(*List of patterns DOES NOT DO ANYTHING with pattern*)
(*,
tmp=exp/.List\[Rule]xList;
pos=Position[exp,xList,{0,maxlevel},Heads\[Rule]True];
list=Extract[exp,pos];
tmp=Thread[Rule[pos,list]];
tmp=tmp/.xList\[Rule]List;
Print[exp,xpattern,tmp];
];*)
tmp
];
(**)
tuReplacePart::usage="tuReplacePart[exp_,pos_List] like ReplacePart[] except replaces whole exp_ when pos contains {{}->replacement} in which case ReplacePart does nothing. *5Sep2015*";
tuReplacePart[exp_,pos_List]:=Module[{$},
If[Length[($=Cases[pos,({}->_)|({}:>_)])]>0,$[[1,2]](*replace entire expression*),
ReplacePart[exp,pos]]
];
(**)tuFreeQ::usage="tuFreeQ[exp_,items_] tests exp_ as FreeQ of all items in items_List. Equivalent form: tuFreeQ[items_][exp_]  *18Jun2015*";
tuFreeQ[exp_,items_]:=Apply[And,Map[FreeQ[exp,#]&,Flatten[{items}]]];
tuFreeQ[items_][exp_]:=tuFreeQ[exp,items];
ListFreeQ[exp_,items_List]:=tuFreeQ[exp,items];(*Compatibility*)

(**)tuHasAnyQ::usage="tuHasAnyQ[exp_,items_List] returns True if exp_ has any item(FreeQ) in items_List. *18Jul2015*";
tuHasAnyQ[exp_,items_]:=Apply[Or,!FreeQ[exp,#]&/@Flatten[{items}]];
(**)tuHasAllQ::usage="tuHasAllQ[exp_,items_List] returns True if exp_ has (!FreeQ) all items in items_List. *18Jul2015*";
tuHasAllQ[exp_,items_]:=Apply[And,!FreeQ[exp,#]&/@Flatten[{items}]];
(**)tuHasNoneQ::usage="tuHasNoneQ[exp_,items_List] returns True if exp_ has none(FreeQ) of the items in items_List. *18Jul2015*";
tuHasNoneQ[exp_,items_]:=Not[tuHasAnyQ[exp,items]];
(**)tuProductQ::usage="tuProductQ[exp_] returns True if exp_ is a product(Times,xTimes) of simple variables. *8Aug2015*";
tuProductQ[exp_]:=Module[{tmp},
tmp={tuHasNoneQ[exp,{Plus}],tuHasAnyQ[Head[exp],{Times,xTimes}]};
Apply[And,tmp]
];

(**)tuMemberQ::usage="tuMemberQ[variable_,patterns_] True if any variable_ (may be List[]) matches any in patterns_ (may be List). Equivalent form: tuMemberQ[patterns_][variable_] *16May2015*";
tuMemberQ[variable_,patterns_]:=
Apply[Or,Map[MemberQ[Flatten[{variable}],#]&,Flatten[{patterns}]]];
tuMemberQ[patterns_][variable_]:=tuMemberQ[variable,patterns];
ListMemberQ[variable_,patterns_List]:=tuMemberQ[variable,patterns];(*Compatibility*)

disjointQ::usage="disjointQ[b_,c_,free_List:{u,d,e,\[Nu],L,R}] return True if both b_, c_ do not have in common items of free_List. *27Apr2016*";
disjointQ[b_,c_,free_List:{u,d,e,\[Nu],L,R}]:=Apply[Or,Map[FreeQ[b,#]&&!FreeQ[c,#]&,free]]

(*
allMemberQ[variables_,patterns_List] True if all variables_ match any in patterns_List.  *16Aug2013*)
allMemberQ[variables_,patterns_List]:=Module[{tmp},
tmp=Map[ListMemberQ[#,Flatten[patterns]]&,Flatten[{variables}]];
Apply[And,tmp]
];
allMemberQ::usage="allMemberQ[variables_,patterns_List] True if all variables_  match any in patterns_List.";

(*
combineElements[elements_List,to_][exp_List] replaces elements_List items of exp_List and Append[]s to_.  *22Nov2014*)
combineElements[elements_List,to_][exp_List]:=Module[{tmp=exp},
tmp=Select[tmp,!MemberQ[elements,#]&];
tmp=Append[tmp,to]
];

(**)
tuOpGather::usage="tuOpGather[op_][exp_] gathers combination of operators op_ in exp_ ,Log: a Log[b]+c Log[d]\[Rule]Log[\!\(\*SuperscriptBox[\(b\), \(a\)]\)\!\(\*SuperscriptBox[\(d\), \(b\)]\)], Sqrt: \!\(\*SqrtBox[\(a_\)]\)\!\(\*SqrtBox[\(b_\)]\)->\!\(\*SqrtBox[\(a\\\ b\)]\)\[IndentingNewLine]*18Jul2016*";
tuOpGather[op_][exp_]:=Module[{tmp=exp},
If[op===Log,
tmp=tmp//.a_ Log[b_]->Log[b^a];xPrint[tmp];
tmp=tmp//.Log[a_]+Log[b_]->Log[a b];xPrint[tmp],
If[op===Sqrt,
tmp=tmp//.{c___ Sqrt[a_] Sqrt[b_]->c Sqrt[a b],c___ Sqrt[a_]/Sqrt[b_]->c Sqrt[a /b]};
];
];
tmp
];
gatherLog[exp_]:=tuOpGather[Log][exp];
gatherSqrt[exp_]:=tuOpGather[Sqrt][exp];

(**)
tuVarGather::usage="tuVarGather[var_,op_:dotOps] Rules[] for gathering var_ at end of op_ terms distributed over Plus expressions. *9Feb2016*";
tuVarGather[var_,op_:dotOps]:={(oo:op)[b_,var]+ (sign_:1)(oo:op)[c_,var]->oo[(b+sign c),var],(oo:op)[var,b_]+ (sign_:1)(oo:op)[var,  c_]->oo[var,(b+sign c)]};

tuSeries::usage="tuSeries[f_,var_List] generates symbolic Series expansion of f_ given var_ parameters of Series[] function *1Nov2015*";tuSeries[f_,var_List]:=Module[{tmp,dif},
tmp=f/.var[[1]]->var[[2]];
dif=tuDPartial[tmp,var[[1]]];
Do[tmp=tmp+(dif/.var[[1]]->var[[2]])(var[[1]]-var[[2]])^(i$)/i$!;
dif=tuDPartial[dif,var[[1]]],
{i$,1,var[[3]]}
];
tmp
];

(*
xSeries[f_,var_List] produces a symbolic Series expansion of f_.  var_List is the variable arguement as in Series.
EG: xSeries[f[x],{x,1,2}] -> xLimit[f[x]+(-1+x) Subscript[Underscript["\[PartialD]", _], x][f[x]]+1/2 (-1+x)^2 Subscript[Underscript["\[PartialD]", _], x][Subscript[Underscript["\[PartialD]", _], x][f[x]]],x\[Rule]1]
*28Jul2014*)
(*xSeries[f_,var_List]:=Module[{tmp,dif},
tmp=f;
dif=xPartialD[tmp,var[[1]]];
Do[tmp=tmp+dif(var[[1]]-var[[2]])^(i$)/i$!;
dif=xPartialD[dif,var[[1]]],{i$,1,var[[3]]}
];
xLimit[tmp,var[[1]]->var[[2]]]
];*)
(*
Generates a Series to order_ in pattern_ from exp_. NOT USED?*)
(*SeriesByPattern[exp_,pattern_,order_]:=Module[{pos,tmp,xpos,XXXX,DEBUG=0,mname="SeriesPattern"},
pos=ExtractPositionPattern[exp,pattern];
IfDEBUG[mname,DEBUG>0,{exp,pattern,pos},"{exp,pattern,pos}"];
xpos=pos/.pattern\[Rule]XXXX;
tmp=ReplacePart[exp,xpos];
IfDEBUG[mname,DEBUG>0,{xpos,tmp},"{xpos,tmp}"];
tmp[[2]]=Series[tmp[[2]],{XXXX,0,order}]//Normal;
IfDEBUG[mname,DEBUG>0,{tmp},"{tmp}"];
tmp=tmp/.XXXX\[Rule]pos[[1,2]];
tmp
];*)
(*
tuSeriesApproximation[exp_,varOrder_List,pattern_List] generates a Rule that is a Series[] approximation to exp_.  varOrder_List is the same as Series[] variable arguement and pattern_List specifies labels to turn into Patterns on the LHS. *19Dec2014*)
tuSeriesApproximation[exp_,varOrder_List,pattern_List]:=exp->Series[exp,varOrder]//Normal//RulesVarPattern[pattern]

(**)
Clear[tuRepeat]
tuRepeat::usage="tuRepeat[rules_List:{},operations_:{},nInterate_:100][exp_] applies rules_List and operations_ (may be List) repeatedly until exp_ does not change. nInterate_ sets MaxInterations in ReplaceRepeated and While[] loop. *22Feb2016*" ;
tuRepeat[rules_List:{},operations_:{},nInterate_:100][exp_]:= Module [{$IterationLimit=20,xrule,xop,tmp=exp,tmp0,icnt=0},
xrule=Flatten[{rules}];
xop=Flatten[{operations}];
xPrint[xrule,xop,$IterationLimit];
While[tmp0=!=tmp,tmp0=tmp;xPrint[icnt,tmp];icnt++;
xPrint[xop];
If[xop=!={},tmp=Composition[Apply[Sequence,xop]][tmp]];
If[xrule=!={},tmp=Fold[ReplaceRepeated[#1,#2,MaxIterations->nInterate]&,tmp,xrule]];(*Position of this statement affects result.*)
xPrint[operation=!=Null];
If[icnt>=nInterate,Return[tmp]];xPrint[$IterationLimit];
];
tmp
];
(*TEST
(a+b)//tuRepeat[{},{#/.a\[Rule]c&,#/.b\[Rule]d&}]
*)
Clear[tuAppendUniq];
tuAppendUniq::usage="tuAppendUniq[item_][list_] combines item_ and list_, Flatten, and DeleteDuplicates";
tuAppendUniq[item_][list_]:=Module[{$},
$=Append[{list},{item}]//Flatten//DeleteDuplicates
];
(**)
Clear[tuProductExpand]
tuProductExpand::usage="tuProductExpand[op_:Times][exp_] expands Product|xProduct operations in exp_ with op_ as product operator. This routine needs Numerical range of productOp[_,{i,9}]. *30Oct2015*";
tuProductExpand[op_:Times][exp_]:=Module[{$=exp,productOp=Product|xProduct},
$=$/.(pp:productOp)[a_,b__]:>op@@Table[a,b]
];
(**)
tuTermSelect::usage="tuTermSelect[patterns_:{},nopattern_:{},withPositions_:False][exp_]\.08\.08\.08\.08 extracts terms which match ALL patterns_(List) and NO nopattern_ in a Plus expression.  withPositions_\[Rule]True returns List of terms with their positions. *7Mar2016*";
tuTermSelect[patterns_:{},nopattern_:{},withPositions_:False][exp_]:=Module[{$,$s},
$=exp/.Plus->Inactive[Plus];
$=$//tuExtractPositionPattern[Inactive[Plus][__]];
(*If no Plus[]*)
If[Length[$]==0 ,
If[ 
tuHasAnyQ[exp,patterns]&&
tuHasNoneQ[exp,nopattern],
Return[{exp}],
Return[$](*{} return*)
];
];
$=$//tuPositionNestDelete;(*top most Plus*)
$=Map[MapAt[Apply[List,#]&,#,2]&,$];
$=Select[Flatten[$[[1,2]]],tuHasAllQ[#,Flatten[{patterns}]]&];
$=Select[$,tuHasNoneQ[#,Flatten[{nopattern}]]&];
$=$//Activate;
If[withPositions,
$=exp//tuExtractPositionPattern[$];
];
$
];
(**)
Clear[tuTermExtract];
tuTermExtract::usage="tuTermExtract[pattern_,nopattern_List:{}][exp_] Apply[]s Plus to tuTermSelect[] items *5May2015*";
tuTermExtract[pattern_,nopattern_List:{}][exp_]:=Apply[Plus,tuTermSelect[Flatten[{pattern}],Flatten[{nopattern}]][exp]];

Clear[tuTermApply];
tuTermApply::usage="tuTermApply[selectPattern_List:{},noselectPattern_List:{},rules_List:{},operations_List:{},showRule_:Null,nIterations_:10][exp_] selects terms in expression exp_ based upon selectPattern_List and noselectPattern_List, and applies rules_List,operations_List to the SUM of selected terms using tuRepeat[]. nInterate_ determines the the number of iterations used in tuRepeat[].  It returns altered exp_ or if showRule_=!=Null returns {Rule,result}. *18May2016*";
tuTermApply[selectPattern_List:{},noselectPattern_List:{},rules_List:{},operations_List:{},showRule_:Null,nIterations_:10][exp_]:=Module[{$0,$,$s},
$=exp//ExpandAll;
$s0=$s=$//tuTermExtract[selectPattern,noselectPattern];(*return Plus[terms]*)
$s=$s//tuRepeat[tuRule[rules],operations,nIterations];
$s=($s0->$s);
If[showRule=!=Null,{$s,$/.$s},$/.$s]
];

Clear[tuTermApplyEach];
tuTermApplyEach::usage="tuTermApplyEach[
selectPattern_List:{},
noselectPattern_List:{},
rules_List:{},
operations_List:{},
nIterations_:10]
[exp_]
 selects Level[1] Plus[] terms and isolated terms in expression exp_  based upon selectPattern_List and noselectPattern_List applies rules_List, operations_List to the EACH selected terms using tuRepeat[,nIterations]. It returns altered exp_.  *18May2016**1Mar2018*10Dec2018*";
tuTermApplyEach[selectPattern_List:{},noselectPattern_List:{},rules_List:{},operations_List:{},nIterations_:10][exp_]:=Module[{$,xfnc,zero},
xfnc[$_]:=Module[{$s0,$s},
$s0=$s=$//tuTermSelect[selectPattern,noselectPattern];
xPrint[$s0];
$s=tuRepeat[tuRule[rules],operations,nIterations]/@$s0;
xPrint[$s];
$s=Apply[Plus,$s];
xPrint[$s];
$s0=Apply[Plus,$s0];
$+$s-$s0
];
$=exp//ExpandAll;
(*distribute zero over exp_*)
$=$+zero/.(rr:Rule|Equal|List)[a_,b_]+zero:>(List[a,b]+zero/.List->rr);
$=$/.Plus->xPlus/.xPlus[a__]:>xfnc[Plus[a]];
$/.zero->0
];

tuRelatedElements::usage="tuRelatedElements[termlist_List,operations_:{Conjugate},reals_] is prototype routine to determine if elements of termlist_List are related to one another.  Simple tests are performed: {Ratio, Conjugate Ratio}. A list of index pairs are returned indicating what was discovered about the pairs.  If no relationship was found then the If[] statement contains the Equality test statement. *3Apr2016* ";
tuRelatedElements[termlist_List,operations_:{Conjugate},reals_]:=Module[{table,tlist,$,listN=Length[termlist],list,i,ii,a$,Ntlist},
(*Make table*)
tlist=Table[{{i,j},termlist[[i]],termlist[[j]]},{i,listN},{j,i+1,listN}]//Flatten[#,1]&;
Ntlist=Length[tlist];
xPrint[tlist,"<<<",Ntlist];
(*Equal test*)
CellPrint["Equal test "];
tlist=Table[{tlist[[ii,1]],If[tlist[[ii,2]]==tlist[[ii,3]],"DirectlyEqual"]},{ii,Ntlist}];
xPrint[ColumnBar[tlist],"<<<<"];
(*operation tests*)
(*ratio test *)
CellPrint["Numeric factor test "];
For[ii=1,ii<=Ntlist,ii++,
If[tuHasAnyQ[tlist[[ii]],If],xPrint[">>",tlist[[ii]] ];(*equality not found*)
$=tuExtractPattern[If[__]][tlist[[ii]]];xPrint[">>If>>",$[[1,1]] ];
$=$[[1,1,1]]==a$ $[[1,1,2]]//Solve[#,a$]&//Simplify;xPrint[">>>> ",$ ,$[[1,1,2]]];
If[NumericQ[$[[1,1,2]]],tlist[[ii]]={tlist[[ii,1]],"FactorEqual",$[[1,1,2]]}];
];
];
CellPrint["Conjugate factor test "];
For[ii=1,ii<=Ntlist,ii++,
If[tuHasAnyQ[tlist[[ii]],If],xPrint[">>",tlist[[ii]] ];(*equality not found*)
$=tuExtractPattern[If[__]][tlist[[ii]]];xPrint[">CF>If>>",$[[1,1]] ];
$=$[[1,1,1]]==a$ Conjugate[$[[1,1,2]]]//tuConjugateSimplify[reals]//Solve[#,a$]&//Simplify;xPrint[">>CF>> ",$ ,$[[1,1,2]]];
If[NumericQ[$[[1,1,2]]],tlist[[ii]]={tlist[[ii,1]],"ConjugateFactorEqual",$[[1,1,2]]}];
];
];
tlist
];

tuConnectedPairs::usage="tuConnectedPairs[list_List] returns a list of lists that have associate common elements, i.e. {1,2},{2,3},{3,4} are all related. list_List is a list of pairs to be grouped. *6Apr2016*";
tuConnectedPairs[list_List]:=Module[{$,$0=list,nlist,point,grp,xgrp,groups={},test,xpoint},
nlist=Length[$0];
point=$0//Flatten//DeleteDuplicates;
While[Length[point]>=1,
grp={};
test=point//First;
point=point//Rest;
While[Length[xgrp=Select[$0,tuHasAnyQ[#,xpoint=Flatten[{test,grp}]]&]]>0,
$0=Select[$0,tuHasNoneQ[#,xpoint]&];
grp=Join[grp,xgrp];
point=Select[point,tuHasNoneQ[#,xpoint]&];
];
If[grp!={},
groups=Append[groups,grp]];
];
groups
];
(**)
tuPositionNestDelete::usage="tuPositionNestDelete[position_List] reduces the result of Position\[Rule] position_List so that there is only top level positions. E.G. {{1,2}\[Rule]a,{1}\[Rule]r[a]}\[Rule]{{1}->r[a]}. If pointer to whole expression {} exists then that alone is returned.  *11Feb2017*";
tuPositionNestDelete[position_List]:=Module[{$=position,$p,dup,$n,$t,i},
$p=$=Map[#&,Sort[$]];xPrint[$p];
If[$p[[1,1]]=={},Return[{$p[[1]]}]];
(*If {} return whole expression.*)
Do[
$t=$p[[i,1]];
$n=FirstPosition[$t ,0][[1]];(*Head index*)
$p[[i,1]]=$t[[1;;(If[NumericQ[$n ],$n-1,-1])]],
{i,Length[$p]}
];
(*delete subindices*)
Do[If[MemberQ[SequencePosition[$p[[$j,1]],$p[[$i,1]]],{1,___}],
$[[$j]]=dup[$i,$[[$j]]]],
{$i,Length[$]-1},
{$j,$i+1,Length[$]}];
DeleteCases[$,dup[__]]
];
(**)
tuPositionHighestLevel::usage="tuPositionHighesttLevel[position_List] returns only the outer-most leaves of position_List. *23Jun2017*";
tuPositionHighesttLevel[position_List]:=Module[{$=position,$p,dup,$n,$t,i,NO},
$p=$=Map[#&,Sort[$]];xPrint[$p];
$p=DeleteCases[$p,{}->_];
Do[
If[$p[[i+1,1]][[1;;Length[$p[[i,1]]]]]==$p[[i,1]],$p[[i,1]]=NO;$i++],
{i,Length[$p]-1}
];
xPrint[$p];
$p=DeleteCases[$p,NO->_];
$p
];
(*TEST*)
(*
$={{1,2,3}\[Rule]a,{1,2}\[Rule]b,{}\[Rule]all}
$//tuPositionLowestLevel
*)

(**)
tuIndependentVar::usage="tuIndependentVar[independentVars_][exp_ ] evaluates exp_ hiding independentVars_ in the evaluation as in the case where there may be subscripted and non-subscripted variables with identical symbols in exp_, but they would be considered different variables.  tuIndependentVar returns List[] \[Rule] {exp_ with independentVars_ substituted, Rules to return substituted exp_ into original variables}. E.g., \[IndentingNewLine]$=Inactive[D][\!\(\*SuperscriptBox[SubscriptBox[\(\[Sigma]\), \(i\)], \(2\)]\)+\!\(\*SuperscriptBox[\(\[Sigma]\), \(2\)]\),\[Sigma]]//tuIndependentVar[{tuDPartial[_,_],\!\(\*SubscriptBox[\(_\), \(_\)]\)}]//Activate//(#[[1]]//.#[[2]]&),
    $=Hold[\!\(\*SubscriptBox[\(r\), \(i\)]\) r/.r\[Rule]s]//tuVar2String[{tuDPartial[_,_],\!\(\*SubscriptBox[\(_\), \(_\)]\)}]//(ReleaseHold[#[[1]]]//.#[[2]]&).
	Evaluation of exp_ must be suspended by Inactive or Hold (depending on what works for exp_) and reactivated after tuIndependentVar.  independentVars_ can be a List of patterns. *22Feb2017*";
tuIndependentVar[independentVars_][exp_ ]:=Module[{$=exp,$p ,independentPos,independents,independentLab,Is,IIII,subIIII,SolveArgs,ivars,xpower},
(*independentVars need dummy labels incase unclothed independentVars is in vars_ *)
independentPos=$//tuExtractPositionPattern[independentVars];
independents=#[[2]]&/@independentPos//DeleteDuplicates;
independentLab=MapIndexed[#1->IIII[First[#2]]&,independents];
subIIII=independentPos//.independentLab;
$p=ReplacePart[$,subIIII];xPrint[SolveArgs,":",subIIII];
{$p,Reverse/@independentLab}
];
(**)tuArraySimplify::usage="tuArraySimplify[exp_] extracts common multiplicative factors from List, Matrices, CircleTimes, etc. and outputs the factor\[CenterDot]reduced_exp_. 0 elements are ignored. *25Mar2017*19Jul2018*";
tuArraySimplify[exp_]:=Module[{$0=exp,$,$common},
$=Flatten[Apply[List,$0]];
$=$//.productOps->Times;
$common=Apply[Intersection,$];xPrint[$," ",$common];
$common=DeleteCases[$common,0|{0}|{{0}}];xPrint["NO 0's ",$common];
If[Head[$common]===List,
$common=Apply[Times,$common]
];xPrint[$common];
$=Map[#/$common&,$0];
$= $common \[CenterDot] $
];
(*TEST
{{Exp[I a] A},{0},{Exp[I a]Bb}}//tuArraySimplify
{{a},{a 0},{b}}//tuArraySimplify
xMM[{{1 /Sqrt[2]},{a 0},{1/Sqrt[2]}}]//tuArraySimplify
xMM[{{a b},{a 0},{a d}}]//tuArraySimplify
a b + a c+a d//tuArraySimplify*)
(**)
Clear[tuConstantsNone]
tuConstantsNone::usage="tuConstantsNone[constants_:{}][EXP_?(tuMemberQ[Head[#],productOps]||tuHasNoneQ[Head[#],{Plus}]&)] returns the non-constant or non-NumericQ[] parts of EXP_ where EXP_ needs to be a productOps or a non-Plus[] expression. The number 1 is returned if only constants_ are found, so tuConstantsNone[] may be used easily in product expressions. *21Mar2017*";
tuConstantsNone[constants_:{}][EXP_?(tuMemberQ[Head[#],productOps]||tuHasNoneQ[Head[#],{Plus}]&)]:=Module[{$=EXP,$const=Flatten[{constants}]},
If[Length[$]>1&&tuMemberQ[Head[$],productOps],
$=Select[$,tuHasNoneQ[#,$const]&&!NumericQ[#]&],
$=If[tuHasNoneQ[$,$const]&&!NumericQ[$],$,1]
];
$
];
(**)
Clear[tuConstants]
tuConstants::usage="tuConstants[constants_:{}][EXP_?(tuMemberQ[Head[#],productOps]||tuHasNoneQ[Head[#],{Plus}]&)] returns the constant and NumericQ[] parts of EXP_ where EXP_ needs to be a productOps or a non-Plus[] expression. The number 1 is returned if no constants_ are found so tuConstants[] may be used easily in product expressions. *21Mar2017*";
tuConstants[constants_:{}][EXP_?(tuMemberQ[Head[#],productOps]||tuHasNoneQ[Head[#],{Plus}]&)]:=Module[{$=EXP,$const=Flatten[{constants}]},
If[Length[$]>1&&tuMemberQ[Head[$],productOps],
$=Select[$,tuHasAnyQ[#,$const]||NumericQ[#]&],
$=If[tuHasAnyQ[$,$const]||NumericQ[$],$,1]
];
$
];
(**)
Clear[tupmConsolidate]
tupmConsolidate::usage="tupmConsolidate[EXP_List] consolidates a pair of Rules in EXP_  which explicitly have {'-','+'} in the coefficients, Subsubscripts, and Superscripts into a single expression with {\[PlusMinus],\[MinusPlus]} labels.  Returns RED expression if input is inconsistent with \[PlusMinus] forms. *28Nov2018*";
tupmConsolidate[EXP_List]:=Module[{$,$0,$1,$pm,$d,$u,$s},
$0=$=EXP//Expand;
xPrint[$0];
$pm=$//tuExtractPattern[\!\(\*SubscriptBox[\(a_\), \("\<+\>"\)]\)|\!\(\*SubscriptBox[\(a_\), \("\<-\>"\)]\)]//DeleteDuplicates;
$pm=Select[$pm,tuHasAnyQ[\!\(\*SubscriptBox[\(First[#]\), \("\<+\>"\)]\),$pm]&&tuHasAnyQ[\!\(\*SubscriptBox[\(First[#]\), \("\<-\>"\)]\),$pm]&];
xPrint[$pm];
$d=tuRuleSubtract[$];
$d=$d/.aa:\!\(\*SubscriptBox[\(a_\), \("\<+\>"\)]\):>Subscript[a, pm]/;tuHasAnyQ[aa,$pm];
$d=$d/.aa:\!\(\*SubscriptBox[\(a_\), \("\<-\>"\)]\):>Subscript[a, mp]/;tuHasAnyQ[aa,$pm];
xPrint[$d];
$d=tuTermApplyEach[{_},{mp,pm},{b_:>pm[1]b},{},1][$d];
xPrint[$d];
$s=tuRuleAdd[$];
$s=$s/.\!\(\*SubscriptBox[\(a_\), \("\<+\>"\)]\)->Subscript[a, pm]/.\!\(\*SubscriptBox[\(a_\), \("\<-\>"\)]\)->Subscript[a, mp];
xPrint[$d," ; ",$s];
$=tuRuleAdd[{$d,$s}];
$=#/2&/@$//Simplify;
(*CHECK*)
$u=$/.pmUp;
$d=$/.pmDn;
xPrint[$u={$0[[1]],$u}//tuRuleSubtract//Simplify];
xPrint[$d={$0[[2]],$d}//tuRuleSubtract//Simplify];
If[MatchQ[$u,Rule[0,0]]&&MatchQ[$d,Rule[0,0]],Return[$],
Return[CR[$]]];
];
(*
(**)TEST00
$={0\[Rule]Subscript[a, "+"]+Subscript[b, "-"],0\[Rule]Subscript[a, "-"]-Subscript[b, "-"]}
tupmConsolidate[$]
(**)TEST1
$={Subscript[a, "+"]\[Rule]a(*+b/2- (c+1)Subscript[a, "+"]*)(*-Subscript[a, "-"]*), Subscript[a, "-"]\[Rule]a(*-b/2+(-1+c)Subscript[a, "-"]*)(*+Subscript[a, "+"]*)}
tupmConsolidate[$]
(**)TEST2
$={Subscript[a, "+"]\[Rule]a+b/2(*- (c+1)Subscript[a, "+"]*)(*-Subscript[a, "-"]*), Subscript[a, "-"]\[Rule]a-b/2(*+(-1+c)Subscript[a, "-"]*)(*+Subscript[a, "+"]*)}
tupmConsolidate[$]
(**)TEST3
$={Subscript[a, "+"]\[Rule]a+b/2- (c+1)Subscript[a, "+"](*-Subscript[a, "-"]*), Subscript[a, "-"]\[Rule]a-b/2+(-1+c)Subscript[a, "-"](*+Subscript[a, "+"]*)}//Expand;$//Column
$=tupmConsolidate[$]
(**)TEST0
$={Subscript[\[Tau], "-"]\[Rule]t-(1-\[Epsilon])r^*,Subscript[\[Tau], "+"]\[Rule]t+(1-\[Epsilon])r^*}
tupmConsolidate[$]*)
