(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Needs["TensorCalculus4V6`Tensorial`"]
Needs["Quantum`Notation`"]
Needs["Combinatorica`"]
<<Local`LocalFunctions`
IntegrateSumFunctions
DotFunctions
IntegralFunctions
SetQuantumAliases[]


tmp=f  Dot[f[a],b,g Dot[c,h Muu[i,j]],NN]==0
dotRetain[{c,f[_],Tensor[M,___],NN},tmp]


Indices4D={0,1,2,3};
DeclareIndexFlavor[{field,Green}]
DeclareIndexFlavor[{space,Red}]
DeclareBaseIndices[Indices4D,{field,{1,2}},{space,{1,2,3}}]
DefineTensorShortcuts[{{\[CurlyPhi],\[Psi],m,k},0},{{x,y,dx,\[Xi],b,r,zero,\[CurlyPhi],\[Psi],\[Psi]c,J,K,P,a,k,e,p,q,dp,dq,j,A},1},{{x,k,g,\[Delta] ,\[Sigma],zero,\[Omega],\[Omega]1,\[Omega]2,\[Omega]s,\[Omega]a,\[Eta],\[CapitalLambda],A,B,M,\[Delta]\[Omega],\[Delta]\[Alpha],q,p,R,T,\[Theta],S,F},2},{{\[CapitalGamma],\[Epsilon]},3}]
labels = {x,\[Delta],g, \[CapitalGamma]};
DeclareZeroTensor[zero]
TensorLabelFormat[zero,0]

SetTensorValues[\[Delta]ud[i,j],IdentityMatrix[4]]
\[Delta]ud[i,j];
%//EinsteinArray[]//MatrixForm;
SetTensorValues[\[Eta]ud[i,j],DiagonalMatrix[{-1,1,1,1}]]
SetTensorValues[\[Eta]uu[i,j],DiagonalMatrix[{-1,1,1,1}]]
SetTensorValues[\[Eta]dd[i,j],DiagonalMatrix[{-1,1,1,1}]]
CompleteBaseIndices


MCommutator::usage = "MCommutator[A,B] calculates the commutator of matrices A and B";
MCommutator[A_,B_]:=A.B-B.A;

subInt=IntegralOp[a_List,intgA_].(IntegralOp[b_List,intgB_])->IntegralOp[xFlatten[{a,b}],intgA.intgB];

MakeBoxes[MatrixExp[x_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@
    {SuperscriptBox["\[ExponentialE]",MakeBoxes[x,form]], MatrixExp[x]}
MakeBoxes[DiracConjugate[a_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@
    {ToBoxes[OverBar[a]], DiracConjugate[a]}

MakeBoxes[ConjugateTranspose[a_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@
    {SuperscriptBox[MakeBoxes[a,form],"\[Dagger]"], ConjugateTranspose[a]}

MakeBoxes[Transpose[a_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@
    {SuperscriptBox[MakeBoxes[a,form],"T"], Transpose[a]}

Unprotect[Transpose];
Transpose[Dot[a_,b_]]:=Dot[Transpose[b],Transpose[a]]
Transpose[Times[c_,Dot[a_,b_]]]:=c Dot[Transpose[b],Transpose[a]]
Transpose[Transpose[a_]]:=a
Transpose[a_+b_]:=Transpose[a]+Transpose[b]
Protect[Transpose];

Unprotect[ConjugateTranspose];
ConjugateTranspose[Dot[a_,b_]]:=Dot[ConjugateTranspose[b],ConjugateTranspose[a]]
ConjugateTranspose[Times[c_,Dot[a_,b_]]]:=c Dot[ConjugateTranspose[b],ConjugateTranspose[a]]
ConjugateTranspose[ConjugateTranspose[a_]]:=a
ConjugateTranspose[a_+b_]:=ConjugateTranspose[a]+ConjugateTranspose[b]
ConjugateTranspose[Exp[a_]]:=Exp[ConjugateTranspose[a]]
ConjugateTranspose[Times[a_,b_]]:=Times[ConjugateTranspose[b],ConjugateTranspose[a]]
ConjugateTranspose[Rule[a_,b_]]:=Rule[ConjugateTranspose[a],ConjugateTranspose[b]]
ConjugateTranspose[I]:=-I
ConjugateTranspose[-I]:=I
ConjugateTranspose[1]:=1
Protect[ConjugateTranspose];


Clear[n];
x[n_,i_]:=xuu[field@n,i];(*to eliminate typing*)
k[n_,i_]:=kud[field@n,i];
q[n_,i_]:=qud[field@n,i];
p[n_,i_]:=pud[field@n,i];
x[n_]:=xu[field@n];(*to eliminate typing*)
k[n_]:=ku[field@n];
q[n_]:=qu[field@n];
y[n_]:=yu[field@n];
sepTX=k[m_,i_]x[n_,i_]:>If[AtomQ[i]&&!IntegerQ[i],k[m,space@i]x[n,space@i]-k[m,0]x[n,0],k[m,i]x[n,i]];
Imply="\n\[DoubleRightArrow] ";
imply=" \[DoubleRightArrow] ";
Yield="\n\[RightArrow] ";
yield=" \[LongRightArrow] ";
back=" \[LongLeftArrow]";
and=" and ";
New="\n\[FilledCircle] ";
(*Function to generate IntegralOp variables for F[n_] in e1410.*)
xF[n_]:=Module[{out,i},For[out={{x[1],0,1}};i=2,i<=n,i++,AppendTo[out,{x[i],0,1}]];
out
];
Fn[n_]:=Module[{out,i,j},For[out={{x[1],0,1}};i=2,i<=n,i++,AppendTo[out,{x[i],0,1-Sum[x[j-1],{j,2,i}]}]];
out
];
DefPrint["e1410",IntegralOp[{{F[n_]}},a__]:>IntegralOp[xF[n],a (n-1)! DiracDelta[Sum[x[i],{i,1,n}]-1]]]
DefPrint["e1427",IntegralOp[{{q}},1/(2 \[Pi])^d (q^2)^a/(q^2+D)^b]->(Gamma[b-a-d/2]Gamma[a+d/2])/((4 \[Pi])^(d/2) Gamma[b]Gamma[d/2]) D^-(b-a-d/2)]
DefPrint["e1427s",IntegralOp[{{q}},(q^2)^a/(q^2+D)^b]->((2 \[Pi])^d Gamma[b-a-d/2]Gamma[a+d/2])/((4 \[Pi])^(d/2) Gamma[b]Gamma[d/2]) D^-(b-a-d/2)]
DefPrint["e1426",Gamma[-n+\[CurlyEpsilon]]:>(-1)^n/(n)! (1/\[CurlyEpsilon]-\[Gamma]+Sum[k^-1,{k,1,n}])]

Same[exp_]:=Module[{same},same=SameQ[exp,lastexp];lastexp=exp;If[same," <-Same"," <-Different"]];
Same[exp_,exp2_]:=Module[{same},same=SameQ[exp,exp2];If[same," <-Same"," <-Different"]]


Op\[Delta]Integrand[exp_]:=(*computes variations of integrand wrt variations in J's.  *)Module[{out=exp,opPos,op,ops,oparg,i,j,tmp0,tmp1,jPos,xdebug,js,jarg,repl,jaccum,dop,args,integrand,intI,ints,intPos,intRepl={},DEBUG=0},
intPos=Position[exp,IntegralOp[_,_]];
ints=Extract[exp,intPos];
If[DEBUG>1,Print[ints]];
For[intI=1,intI<=Length[ints],intI++,If[DEBUG>0,Print[intI]];
{args,integrand}=Apply[List,ints[[intI]]];
opPos=Position[integrand,\[Delta]Op[_]];
ops=Extract[integrand,opPos];(*list of \[Delta]Op*)
tmp0=integrand/.\[Delta]Op[_]->1;(*tmp0 integrand without \[Delta]Op*)
jPos=Position[tmp0,J[_]|(J^\[Dagger])[_]];
js=Extract[tmp0,jPos];(*list of J's*)
repl={};
For[j=1,j<=Length[js],j++,
jarg=js[[j]][[1]];
AppendTo[repl,jPos[[j]]->js[[j]]. DiracDelta[jarg]];
];
tmp0=ReplacePart[tmp0,repl];

For[i=1,i<=Length[ops],i++,If[DEBUG>1,Print[intI,":",i]];
op=ops[[i]];
oparg=op[[1,1]];
jaccum=0;
For[j=1,j<=Length[js],j++,If[DEBUG>2,Print[intI,":",i,":",j]];
jarg=js[[j]][[1]];
dop=op[[1]];
dop[[1]]=jarg;
tmp1=D[tmp0,dop];
jaccum+=tmp1/.DiracDelta[jarg]->DiracDelta[jarg-oparg];
If[DEBUG>3,Print[intI,":",i,":",j,":",tmp0,":",dop]];
If[DEBUG>3,Print[intI,":",i,":",j,":",jaccum]];
];
tmp0=jaccum;
];
For[j=1,j<=Length[js],j++,(*eliminate DiracDelta attached to J's not in variation*)
jarg=js[[j]][[1]];
tmp0=tmp0//.DiracDelta[jarg]->1
];
AppendTo[intRepl,intPos[[intI]]->IntegralOp[args,tmp0]];
];
ReplacePart[out,intRepl]
];

Op\[Delta]Integrand2[exp_]:=(*computes variations of integrand wrt variations in J's.  *)Module[{out=exp,opPos,op,ops,oparg,i,j,tmp0,tmp1,jPos,xdebug,js,jarg,repl,jaccum,dop,args,integrand,intI,ints,intPos,intRepl={},DEBUG=1},
intPos=Position[exp,IntegralOp[_,_]];
ints=Extract[exp,intPos];
If[DEBUG>1,Print[ints]];
For[intI=1,intI<=Length[ints],intI++,If[DEBUG>0,Print[intI]];
{args,integrand}=Apply[List,ints[[intI]]];
opPos=Position[integrand,\[Delta]Op[_]];
ops=Extract[integrand,opPos];(*list of \[Delta]Op*)
tmp0=integrand;
(* Would be easier if we had form G[\[Delta]Op[J[_]]][F[J[_]]] *)

jPos=Position[tmp0,J[_]|(J^\[Dagger])[_]];
js=Extract[tmp0,jPos];(*list of J's*)
repl={};
For[j=1,j<=Length[js],j++,
jarg=js[[j]][[1]];
AppendTo[repl,jPos[[j]]->js[[j]]. DiracDelta[jarg]];
];
tmp0=ReplacePart[tmp0,repl];

For[i=1,i<=Length[ops],i++,If[DEBUG>1,Print[intI,":",i]];
op=ops[[i]];
oparg=op[[1,1]];
jaccum=0;
For[j=1,j<=Length[js],j++,If[DEBUG>2,Print[intI,":",i,":",j]];
jarg=js[[j]][[1]];
dop=op[[1]];
dop[[1]]=jarg;
tmp1=D[tmp0,dop];
jaccum+=tmp1/.DiracDelta[jarg]->DiracDelta[jarg-oparg];
If[DEBUG>3,Print[intI,":",i,":",j,":",tmp0,":",dop]];
If[DEBUG>3,Print[intI,":",i,":",j,":",jaccum]];
];
tmp0=jaccum;
];
For[j=1,j<=Length[js],j++,(*eliminate DiracDelta attached to J's not in variation*)
jarg=js[[j]][[1]];
tmp0=tmp0//.DiracDelta[jarg]->1
];
AppendTo[intRepl,intPos[[intI]]->IntegralOp[args,tmp0]];
];
ReplacePart[out,intRepl]
];

RearrangeIntJArg[exp_]:=(*Rearrange J\[CapitalDelta] arguements so that J's are sequenced first and \[CapitalDelta]'s later*)Module[{out=exp,args,integrand,i,j,iv,term,js,jps,repl,repls={},sub,rlist={},ints,intPos,intI,intOut={},DEBUG=0},
intPos=Position[exp,IntegralOp[_,_]];
ints=Extract[exp,intPos];
For[intI=1,intI<=Length[ints],intI++,
{args,integrand}=Apply[List,ints[[intI]]];
If[DEBUG>0,
Print["IntegralOp:",intI,":",integrand]];
integrand=Expand[integrand];
rlist={};
If[Head[integrand]===Plus,
For[i=1,i<=Length[integrand],i++,
term=integrand[[i]];
iv=1;
repls={};
(*Replace all args with dummy*)
For[j=1,j<=Length[args],j++,term=term/.args[[j,1]]->repl[j]];
If[i==2,List[i,">> ",term]];

(*First reassign J arguements*)
jPos=Position[term,J[_]|(J^\[Dagger])[_]];
js=Extract[term,jPos];
For[j=1,j<=Length[js],j++,sub=js[[j,1]]->args[[iv++,1]];
term=term//.sub;
AppendTo[repls,js[[j,1]]];
If[i==2,List[i,">>> ",sub," ",term]];
];
If[i==2,List[i,">repl>> ",repls," ",term]];

(*Then replace remaining args*)
For[j=1,j<=Length[args],j++,
If[MemberQ[repls,repl[j]],Null,sub=repl[j]->args[[iv++,1]];term=term//.sub;
AppendTo[repls,repl[j]];
If[i==2,List[sub," VV ",repls,"<==> ",term]];
];
];
If[i==2,List["M> ",term]];
AppendTo[rlist,i->term];
];
integrand=ReplacePart[integrand,rlist];
If[DEBUG>0,
Print[">",integrand]];
AppendTo[intOut,intPos[[intI]]->IntegralOp[args,integrand]];
];
];
If[DEBUG>0,
Print[">>",intOut]];
out=ReplacePart[exp,intOut]
];

GroupJ\[CapitalDelta][exp_]:=(*Extracts graphs: subterms by coordiate groups*)Module[{out=exp,args,integrand,i,j,iv,intPos,ints,intI,term,lastterm,js,jps,xs,lastxs,xPos,xt,ix,tmp,output={},sub,group,groups={},outputLength=33333,DEBUG=1},
intPos=Position[exp,IntegralOp[_,_]];
ints=Extract[exp,intPos];
For[intI=1,intI<=Length[ints],intI++,
{args,integrand}=Apply[List,ints[[intI]]];
If[DEBUG>0,
Print["IntegralOp:",intI,":",integrand]];
For[i=1,(i<=Length[integrand]&&Head[integrand]===Plus)||(i==1)&&i<outputLength,i++,
If[Head[integrand]===Plus,
term=integrand[[i]],
term=integrand];
xs=Cases[term,x[_,_],\[Infinity]]//DeleteDuplicates;
lastxs={};lastterm={};groups={};
While[term=!=lastterm&&Length[xs]>0,
lastterm=term;
xt={First[xs]}; xs=Rest[xs];
group={};lastxs={};
While[Sort[xs]=!=Sort[lastxs],
lastxs=xs;
For[ix=1,ix<=Length[xt],ix++,
AppendTo[group,Cases[term,\[CapitalDelta][_+xt[[ix]]]^_|\[CapitalDelta][_-xt[[ix]]]^_,\[Infinity]]](*get powers of \[CapitalDelta]*);
term=DeleteCases[term,\[CapitalDelta][_+xt[[ix]]]^_|\[CapitalDelta][_-xt[[ix]]]^_,\[Infinity]];
AppendTo[group,Cases[term,_[xt[[ix]]]|\[CapitalDelta][_+xt[[ix]]]|\[CapitalDelta][_-xt[[ix]]],\[Infinity]]];
];
group=Flatten[group];
sub=Map[#->1&,group];
term=term/.sub;
xt=Cases[group,x[_,_],\[Infinity]]//DeleteDuplicates;
xs=DeleteCases[xs,a_/;MemberQ[xt,a],\[Infinity]];
List["xt:",xt,":",group,"<",xs,":",lastxs];
];
If[Length[group]>0,
AppendTo[groups,Sort[group]];
];
];
AppendTo[groups,term];
If[Length[groups]<=outputLength,
If[DEBUG>0,
Print["term:",i," groups:",Column[groups]]];
AppendTo[output,groups];
];
];
];
output/.Null->1
];

Plot\[CapitalDelta][in_,nterm_,minProp_]:=(*plots groups formed with routine above.  in_=output from GroupJ\[CapitalDelta], nterm_=upper limit on number of subgroups included in plot (nterm=2 limits output to connected graphs, minProp_=minimum number of propagators needed to plot.  Some interpretation of these plots is require: Note the coefficient factor indicates the number of vertices in the diagram, so there are diagrams where there are no loops,i.e, \[CapitalDelta][0], but odd number of branches from a vertex.  In this case the interpretation is that a single line is hiding multiple lines (I think due to DeleteDuplicates). *)Module[{list=in,term,iterm,iplt,tmp,js,\[CapitalDelta]s,\[CapitalDelta]xs={},iline,line,xarg},
For[iterm=1,iterm<=Length[list],iterm++,
term=list[[iterm]];
If[Length[term]<=nterm,
Print["------",iterm,":",Length[term] ,"-----Coefficient:",term[[-1]]];
For[iplt=1,iplt<=Length[term],iplt++,
List[tmp=term[[iplt]]];
js=Cases[tmp,J[x[_,_]]|(J^\[Dagger])[x[_,_]]];
tmp=tmp/.\[CapitalDelta][a_]^n_:>Apply[Sequence,Tuples[{\[CapitalDelta][a]},n][[1]]];
\[CapitalDelta]s=Cases[tmp,\[CapitalDelta][_]];
\[CapitalDelta]xs={};
For[iline=1,iline<=Length[\[CapitalDelta]s],iline++,
xarg=\[CapitalDelta]s[[iline]]/.\[CapitalDelta][a_]->a;
xarg=xarg/.Plus[a_,b_]:>Abs[a]->Abs[b]/.Abs[a_]->a;
AppendTo[\[CapitalDelta]xs,xarg];
\[CapitalDelta]xs=\[CapitalDelta]xs/.x[a_,_]->a;
];
If[Length[\[CapitalDelta]xs]>minProp&&\[CapitalDelta]xs=!={0},
Print[js,":",\[CapitalDelta]xs,":","
",GraphPlot[\[CapitalDelta]xs,VertexLabeling->True,ImageSize->200]]
];
];
];
];
];


CompleteSquare[quadratic_,var_]:=
(*Finds square of quadradic polynomial, quadratic, with var as variable.  Assumes q[], k, and h as vectors.  Returns (h^2+D) and substitutions to create quadradic in h. *)
Module[{subsimple={Dot[a_,a_]->a^2},tmpId,tmp,tmps,tmpr,tmpD,tmpc,tmpq2fac,sub,subD,dvar,subvar,subh,retainList={q[_],k,k[_],h}},
tmpId=quadratic/.(a_)^2->Dot[a,a];
(*manipulate k,q as vectors*)
dotRetain[retainList,tmpId];
tmpId=tmpId//.simpleDot/.subsimple//Expand;
"Factor of power function. Find squre expression of var.";
tmpId=Collect[tmpId,{var}];
tmpId=groupDot[var,tmpId];
"The square of quadratic in var.";
tmpc=CoefficientList[tmpId,{var}];
tmpq2fac=tmpc//Last;
tmp=(tmpId//Last);(*first order in var*)
"Coefficient of linear term.";
tmp=(tmp/.var->1/2/.xDot->Times)//Expand;
"The transform of var that generates \!\(\*SuperscriptBox[\"D\", \"2\"]\)->\!\(\*SuperscriptBox[\"var\", \"2\"]\) tmpq1fac";
tmpD=(var+tmp/tmpq2fac) Sqrt[tmpq2fac]//Simplify;
"Find remainder:";
tmps=dotRetain[retainList,tmpD.tmpD]/.subsimple;
tmpr=tmpId-tmps/.xDot->Dot//Expand;
"Should not have any var.";
tmpr= dotRetain[retainList,tmpr]//Simplify;
"Find linear transform h[var] to yield form (\!\(\*SuperscriptBox[\"h\", \"2\"]\)+D) in denominator where h is new integration variable.";
sub=h==tmpD ;
subvar=Solve[sub,var][[1,1]];" and ";
subh=Solve[sub,h][[1,1]];
(*reinsert Dot for squared terms *)
tmps=tmps /.subvar/.a_^2->a.a;Yield;
tmps=dotRetain[retainList,tmps]/.subsimple//.simpleDot/.commuteDot//Simplify;
tmpr=dotRetain[retainList,tmpr]/.subsimple//.simpleDot/.commuteDot//Simplify;
tmp=tmps+D;
subD=D->tmpr;
dvar=d[var]->d[h]D[subvar[[2]],h];
{tmp,subD,dvar,subh,subvar}

]

