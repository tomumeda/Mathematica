(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
(*External packages*)
(*
Needs["TensorForms1V6`TensorialForms`"];
TensorialHelp;
*)
(*WARNING: Needs["TensorCalculus5`Tensorial`"]  called in TensorialForms  *)
Needs["VariationalMethods`"];
(***********************)
(*The display definitions of Tensor[] from TensorialForms.   *)
MakeBoxes[Tensor[A_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,Editable->False]&@@{MakeBoxes[A,form],Tensor[A]};

MakeBoxes[Tensor[A_,up_List,down_List],form:StandardForm|TraditionalForm]:=Module[{newdown=down,newup=up,makespace},makespace=If[#1===Void,Style[#2,ShowContents->False],#1]&;newup=Inner[makespace,newup,newdown,List];newdown=Inner[makespace,newdown,newup,List];(InterpretationBox[#1,#2,Editable->False,BaseStyle->{AutoMultiplicationSymbol->False}
]&)@@{SubsuperscriptBox[MakeBoxes[A,form],
RowBox[(MakeBoxes[#1,form]&)/@newdown],RowBox[(MakeBoxes[#1,form]&)/@newup]],Tensor[A,up,down]}];

(****Simple ways of defining Tensor[] ****)
T::usage="T[A_,up_List,down_List] produces any Tensor[A_,up_List,down_list]. Checks for proper indices. \[IndentingNewLine]A_ can be functional labels. Uses Null List item to hold slot in index list, e.g., T[A,{,i},{j,}\[Rule]\!\(\*SuperscriptBox[SubscriptBox[\(T\), \(j\)], \(i\)]\).";
T[A_,up_List,down_List]:=Module[{tmp,u=up/.Null->Void,d=down/.Null->Void,return},
If[up=={}&&down=={},Return[Tensor[A,up,down]]];(*Scalar Tensor with no indices*)
(*{} index case -> entirely other index *)
If[up=={},u=Table[Void,{Length[d]}]];
If[down=={},d=Table[Void,{Length[u]}]];
If[Length[d]==Length[u]&&
(!Inner[#1=!=Void&&#2=!=Void||#1===Void&&#2===Void&,u,d,Or]),(*index check*)
Tensor[A,u,d],
Style[Tensor[A,up,down],FontColor->Red](*Error condition*)
]
];
(**)
T::usage="T[A_,uds_String,index_List] produces any Tensor where uds_String specifies up/down position of index_, e.g., T[Symbol\"udd\",{i,j,k}]->((\!\(\*SuperscriptBox[\(Symbol\), \(i\)]\)\!\(\*SubscriptBox[\()\), \(jk\)]\))";
T[A_,uds_String,index_List]:=Module[{tmp,ud=Characters[uds]},
If[Cases[ud,Except["u"|"d"]]==={}&&(*only u and d allowed*)
(tmp=Which[Head[index]===List&&Length[ud]==Length[index],(*check list parameter compatibility*)
Tensor[A,MapThread[(If[#1==="u",#2,Void])&,{ud,index}],MapThread[(If[#1==="d",#2,Void])&,{ud,index}]],
ud==={"u"},
Tensor[A,{index},{Void}],
ud==={"d"},
Tensor[A,{Void},{index}],
(*no list index*)
True,(*error*)
-1])=!=-1,tmp,
Style[Tensor[A,uds,index],FontColor->Red]]
];

OnlyudQ[string_]:=StringCases[string,Except[{"d","u"}] ]=={};(* Alternate format for T:= T[symbol,"UpDownString"][indices] 7Apr2012 *)
T::usage="T[A_,uds_String][index0__] produces any Tensor where uds_String specifies up/down position of index_, e.g.,T[Symbol,\"udd\"][i,j,k]->((\!\(\*SuperscriptBox[\(Symbol\), \(i\)]\)\!\(\*SubscriptBox[\()\), \(jk\)]\))";
T[A_,uds_String][index0__]:=Module[{tmp,ud=Characters[uds],index={index0}},
If[Cases[ud,Except["u"|"d"]]==={}&&(*only u and d allowed*)
(tmp=Which[Head[index]===List&&Length[ud]==Length[index],(*check list parameter compatibility*)
Tensor[A,MapThread[(If[#1==="u",#2,Void])&,{ud,index}],MapThread[(If[#1==="d",#2,Void])&,{ud,index}]],
ud==={"u"},
Tensor[A,{index},{Void}],
ud==={"d"},
Tensor[A,{Void},{index}],
(*no list index*)
True,(*error*)
-1])=!=-1,tmp,
Style[Tensor[A,uds,index],FontColor->Red]]
];

(***********************)
(* This a a replacement routine that includes DerivOps, etc.  The .m version does not work for some reason.  Uses Tensorial routines. *5Sep2015*)
(* DELETE xArrayExpansion[indices_List,baseindices_ :Automatic][expr_]/;MatchQ[baseindices,Automatic|{(_Integer|_Symbol)..}|{{(_Integer|_Symbol)..}..}]:=Module[{idx,inindex,wbaseindices,indexstructure,wstructure,replace,uq,q,uqreplace},wbaseindices=If[VectorQ[baseindices],{baseindices},baseindices];
indexstructure=Module[{index,bases,subbases},Table[index=Part[indices,idx];
bases=GetBaseIndices[index];
subbases=If[Length[wbaseindices]\[GreaterEqual]idx,Part[wbaseindices,idx],bases];
If[\[Not](Intersection[subbases,bases]===Sort[subbases]),Message[SumArrayExpansion::subset,subbases,bases];Abort[],bases=subbases];
{index,bases},{idx,1,Length[indices]}]];
inindex[i_]:=(Count[{expr},Tensor[_,up_/;\[Not]FreeQ[up,i,1],down_]|Tensor[_,up_,down_/;\[Not]FreeQ[down,i,1]]|
Map[HoldPattern[#[_,i]]&,DerivOps],\[Infinity],Heads\[Rule]True]>0\[And]\[Not]BaseIndexQ[i]);

replace[i_,newindex_]:=Switch[Head[i],_?IndexFlavorQ,Head[i][newindex],_,newindex];
uqreplace[i_]:=Switch[Head[i],_?IndexFlavorQ,Head[i][q],_,q];
wstructure=Select[indexstructure,inindex[First[#]]&];

Fold[List@@Table[(#1//tuIndexChange[{First[#2],uq=uqreplace[First[#2]]}])/.uq\[Rule]replace[First[#2],Part[Last[#2],idx]],{idx,1,Length[Last[#2]]}]&,expr,Reverse[wstructure]]
];

tuArraySum::usage="tuArraySum[index_List][exp_] sums xArrayExpansion results.";
tuArraySum[index_List][exp_]:=Module[{tmp},
tmp=Fold[Apply[Plus,xArrayExpansion[{#2}][#1]]&,exp,index];
tmp
];
xArraySum[index_List][exp_]:=tuArraySum[index][exp];(*Compatibility*)
*)
(**)
tuEinsteinSum::usage="tuEinsteinSum[baseindices_:Automatic][exp_] uses EinsteinSum[] but includes functions defined in DerivOps. baseindices_ can be Automatic[ly] defined by DeclareBaseIndices[] or explicitly, e.g. {1,2,3} or {i1,i2,i3}. *3Aug2012*";
tuEinsteinSum[baseindices_:Automatic][exp_]:=Module[{tmp=ExpandAll[exp],xtmp,sub,OPS=DerivOps},
tmp=tmp//EinsteinSum[baseindices];
tmp=tmp/.a__ (OP:DerivOps)[d_,$e_]:>xArraySum[{$e}][a OP[d,$e]]/; MemberQ[ExtractDummyIndices[a OP[d,$e]],$e];
tmp
];
xEinsteinSum[baseindices_:Automatic][exo_]:=tuEinsteinSum[baseindices][exp];

(*
SumTermsWithTU[index_List][exp_] applies Sum to Times terms in exp_  where index_List is form of the Sum[_,arg] arg.   Intended to extend EinsteinSum. Does not observe UpDown convention.  Returns xSum to allow checking of expression. *5Mar2014*)
SumTermsWithTU[index_List][exp_]:=Module[{tmp=exp,iterm,noiterm,$i,
(*associative operators that this can be applied on *)
ops=Times|Dot|xDot
},
Do[
tmp=tmp//Expand;
tmp=tmp/.op:ops->OP[op];
xPrint[$i,index[[$i]]];
xPrint[tmp];
tmp=tmp/.OP[op:_][a__]:>iterm[Apply[op,Select[{a},!FreeQ[#,index[[$i,1]]]&  ]]]noiterm[Apply[op,Select[{a},FreeQ[#,index[[$i,1]] ]&]]];
tmp=tmp/.iterm[a_]:>iterm[xSum[a,index[[$i]]]]/;!FreeQ[a,index[[$i,1]]];
tmp=tmp/.iterm[a_]->a/.noiterm[a_]->a/.OP[op_][a__]:>op[a];
xPrint[tmp],
{$i,Length[index]}
];
tmp
];

(******)
(*Past definitions*)(*
DeclareZeroTensor[zero];
TensorLabelFormat[zero,0];*)
(*
<<Local`LocalFunctions`*)
<<Local`CommonPR2`
<<Local`Utilities2`
tuSaveFile;

DotFunctions(*
IntegralFunctions already included*)(*
IntegrateSumFunctions*)
(*Some mathematical relationships are different in Peskin-Schroeder, e.g., Civita Tensor index sums.  Setting this to 1 use the Peskin-Schroeder relationship. *)
PeskinSchroederMode=1;
(*Area for specific assignments of variables for all problems.*)
Indices4D={0,1,2,3};

(*
DeclareIndexFlavor[{field,Green}]
DeclareIndexFlavor[{space,Red}]
DeclareIndexFlavor[{timespace,Magenta}]
DeclareIndexFlavor[{feyn,Orange}]
DeclareIndexFlavor[{groupR,Blue}]*)

SetAttributes[timespace,{Flat,OneIdentity,Listable}];(*eliminates double calls*)

DeclareBaseIndices[Indices4D,{field,{1,2,3,4}},{feyn,{1,2,3,4,5}},{space,{1,2,3}},{timespace,{0,1}},{groupR,{1,2,3}}];
CompleteBaseIndices
Clear[QCDBaseIndices]
QCDBaseIndices:=Module[{},
DeclareIndexFlavor[{color,Brown}];
DeclareIndexFlavor[{flavor,Orange}];
DeclareIndexFlavor[{family,Darker[Green]}];
AddBaseIndex[{gaugeG,{1,2,3,4,5,6,7,8}}];(*SU[3] gauge group index*)
AddBaseIndex[{color,{1,2,3}}];(*SU[3] singlet index*)
AddBaseIndex[{flavor,{1,2,3,4,5,6}}];
(*correspondence: {{u,c,t, with Q=2/3},{d,s,b, with Q=-1/3}}*)
AddBaseIndex[{family,{1,2,3}}];
CompleteBaseIndices
];

(*DefineTensor[
\[CurlyPhi],\[Psi],m,k,x,y,z,dx,\[Xi],b,c,r,\[Phi],\[Psi]c,J,K,P,a,k,l,e,p,q,dp,dq,j,A,B,\[Gamma],G,n,\[Sigma],h,\[Chi],\[Theta],\[Zeta],x,k,g,\[Delta] ,\[Sigma],\[Omega],\[Omega]1,\[Omega]2,\[Omega]s,\[Omega]a,\[Eta],\[CapitalLambda],A,B,M,\[Delta]\[Omega],\[Delta]\[Alpha],q,p,R,T,S,F,W,J,\[CapitalGamma],f,W,J,\[Epsilon]
];

labels = {x,\[Delta],g, \[CapitalGamma]};
SetTensorValues[\[Eta]@uu[i,j],DiagonalMatrix[{1,-1,-1,-1}]]
SetTensorValues[\[Eta]@dd[i,j],DiagonalMatrix[{1,-1,-1,-1}]]
Tr\[Eta]=Tr[DiagonalMatrix[{1,-1,-1,-1}]]
SetTensorValues[\[Eta]@dd[timespace@i,timespace@j],DiagonalMatrix[{1,-1}]]
SetTensorValues[\[Eta]@uu[timespace@i,timespace@j],DiagonalMatrix[{1,-1}]]
SetTensorValues[\[Delta]@ud[i,j],IdentityMatrix[4]]
*)
(* Add index pattern for xPartialD. *)
indexspecs1={
{1,{2},xPartialD[_,index_/;Head[index]=!=List]},
{2,{2,_},xPartialD[_,index_List]},
{1,{2},xCovariantD[_,index_/;Head[index]=!=List]},
{2,{2,_},xCovariantD[_,index_List]},
{1,{2},xD[_][_,index_/;Head[index]=!=List]},
{2,{2,_},xD[_][_,index_List]}
};
indexspecs2={
{1,{2},xPartialDu[_,index_/;Head[index]=!=List]},
{2,{2,_},xPartialDu[_,index_List]},
{1,{2},xCovariantDu[_,index_/;Head[index]=!=List]},
{2,{2,_},xCovariantDu[_,index_List]},
{1,{2},xDu[_][_,index_/;Head[index]=!=List]},
{2,{2,_},xDu[_][_,index_List]}
};

NewIndexChangePatterns=Join[indexspecs1,indexspecs2];
NewIndexChangePatterns;

IndexParsingRules:={\!\(\*OverscriptBox[\($$ten_Tensor\), \(_\)]\)->$$ten,
DerivOpsU[($$c_:1) DerivOpsD[$$a_,$$m_],$$n_]->$$c $$a Tensor[$$XXX,{$$n},{$$m}],
DerivOpsD[($$c_:1 ) DerivOpsU[$$a_,$$m_],$$n_]->$$c $$a Tensor[$$XXX,{$$m},{$$n}],

DerivOpsD[$$a_,$$m_]->$$a Tensor[$$XXX,{Void},{$$m}],
DerivOpsU[$$a_,$$m_]->$$a Tensor[$$XXX,{$$m},{Void}],
HoldPattern[Derivative][a__][Tensor[$$b_,$$c_,$$d_]]:>Tensor[$$b,$$c,$$d],
ExteriorD[$$a_]->$$a
};

(*Functional patterns that may use indices*)
IndexVarPatterns=Tensor[a_,u_List,d_List]|xPartialD[a_,d_]|xPartialDu[a_,u_]|xCovariantD[a_,d_]|xCovariantDu[a_,u_]|xD[b_][a_,d_]|xDu[b_][a_,u_];
(*Notation in QFT has too many requirements and often needs to be problem specific.
*)

(*Keep the Length of the _D _U variables the same! *)
tuDerivOpsD:=tuDPartial|tuDCovariant|tuDs[_]|tuDDown[_];
tuDerivOpsU:=tuDPartialu|tuDCovariantu|tuDsu[_]|tuDUp[_];
tuDerivOps:=tuDerivOpsD|tuDerivOpsU|tuDLie//Flatten;

DerivOpsD:=Join[xPartialD|xCovariantD|xD[_],tuDerivOpsD];
DerivOpsU:=Join[xPartialDu|xCovariantDu|xDu[_],tuDerivOpsU];
DerivOps:=DerivOpsD|DerivOpsU|tuDerivOps//Flatten;(*Compatibility*)

(*
Slashes symbol_*)
MakeBoxes[slash[symbol_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{RowBox[{ToBoxes["/"],AdjustmentBox[ToBoxes[symbol],BoxMargins->{{-.6,0},{.0,0}}]}],slash[symbol]};
Slash:=slash;
(*
PartialDSlash[symbol_] notation. *)
MakeBoxes[tuPartialDSlash[symbol_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{RowBox[{ToBoxes["/"],AdjustmentBox["\[PartialD]",BoxMargins->{{-0.8,0.0},{0.,0.}}],ToBoxes[symbol]}], tuPartialDSlash[symbol]};
PartialDSlash:=tuPartialDSlash
(*
CovariantDSlash[symbol_] notation. *)
MakeBoxes[tuCovariantDSlash[symbol_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{RowBox[{ToBoxes["\[ScriptCapitalD]"],AdjustmentBox["/",BoxMargins->{{-0.6666666666666666,-0.6666},{0.,0.}}],"[",ToBoxes[symbol],"]"}], tuCovariantDSlash[symbol]};
CovariantDSlash:=tuCovariantDSlash
(*
GammaSlash display definition.  May want to redefine it as g[a_]:=GammaSlash[a].  Perhaps the Bold is enough.*)
MakeBoxes[GammaSlash[a_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@
    {ToBoxes[Overscript[Style[a,Bold],"/"]], GammaSlash[a]};

(*
xIntegral and xCIntegral: 
Intermediate form of tuIntegral and tuCIntegral to have arguements consistent with standard Mathematica arguement lists. *)
xIntegral:=Inactive[Integrate]

MakeBoxes[xCIntegral[a_,v__],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Subscript["\[ContourIntegral]",Column[{v}]][a]], xCIntegral[a,v]};

(*
tuIntegral display definition. *)
tuIntegral::usage="tuIntegral[vars_List,integrand_] Integral operator with list of variables vars_ \[Rule] {{v1},{v2}} and integrand_. ";
MakeBoxes[tuIntegral[v_,a_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Subscript["\[Integral]",Column[v]][a]], tuIntegral[v,a]};
IntegralOp:=tuIntegral;

(*
tuCIntegral display definition.  Syntax tuCIntegral[{{v1,a1,b1},{v2,a2,b3}},integrand]*)
MakeBoxes[tuCIntegral[v_,a_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Subscript["\[ContourIntegral]",Column[v]][a]], tuCIntegral[v,a]};
CIntegralOp[v_,a_]:=tuCIntegral[v,a];
(*
Transpose display definition.*)
MakeBoxes[Transpose[a_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Superscript[a,T]], Transpose[a]};
(*
ConjugateTranspose display definition.*)
MakeBoxes[ConjugateTranspose[a_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[SuperDagger[a]], ConjugateTranspose[a]};
(*
Conjugate display definition.*)
MakeBoxes[Conjugate[a_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[SuperStar[a]], Conjugate[a]};
(*
xPartialD display definition.*)
tuPartialD::usage="tuPartialD[field_,var_] displays the PartialD[field,var] \[Rule] \!\(\*SubscriptBox[\(\[PartialD]\), \(var\)]\)field. ";
MakeBoxes[tuPartialD[a_,b_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Subscript[\!\(\*UnderscriptBox[\("\<\[PartialD]\>"\), \(_\)]\),b][a]], tuPartialD[a,b]};
xPartialD[field_,var_]:=tuPartialD[field,var];
tuPartialD:=tuDPartial; (*Transitional*)
tuPartialDu:=tuDPartialu; (*Transitional*)
(*
xPartialDu (contravariant derivative) display definition.*)
tuPartialDu::usage="tuPartialDu[field_,var_] displays the PartialDu[field,var] \[Rule] \!\(\*SuperscriptBox[\(\[PartialD]\), \(var\)]\)field. ";
MakeBoxes[tuPartialDu[a_,b_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Superscript[\!\(\*UnderscriptBox[\("\<\[PartialD]\>"\), \(_\)]\),b][a]], tuPartialDu[a,b]};
xPartialDu[field_,var_]:=tuPartialDu[field,var];
(*
xCovariantD (contravariant covariant derivative) display definition.*)
MakeBoxes[xCovariantD[a_,b_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Subscript[\!\(\*UnderscriptBox[\("\<\[GothicCapitalD]\>"\), \(_\)]\),b][a]], xCovariantD[a,b]};
(*
xCovariantDu (contravariant covariant derivative) display definition.*)
MakeBoxes[xCovariantDu[a_,b_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Superscript[\!\(\*UnderscriptBox[\("\<\[GothicCapitalD]\>"\), \(_\)]\),b][a]], xCovariantDu[a,b]}
(*
xLieD (Lie derivative) display definition.*)
MakeBoxes[xLieD[a_,b_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Subscript[\!\(\*UnderscriptBox[\("\<\[ScriptCapitalL]\>"\), \(_\)]\),b][a]], xLieD[a,b]};
(*
deltaD display definition.*)
MakeBoxes[deltaD[a_,b_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Subscript[\!\(\*UnderscriptBox[\("\<\[Delta]\>"\), \(_\)]\),b][a]], deltaD[a,b]};
(*
xDeltaD display definition.*)
MakeBoxes[xDeltaD[a_,b_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Subscript[\!\(\*UnderscriptBox[\("\<\[Del]\>"\), \(_\)]\),b][a]], xDeltaD[a,b]};
(*
xDeltaD display definition for specified symbol s_.*)
MakeBoxes[xDeltaD[s_,a_,b_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Subscript[\!\(\*UnderscriptBox[\(s\), \(_\)]\),b][a]], xDeltaD[s,a,b]};
(*
xD display definition specified symbol s_.*)
MakeBoxes[xD[s_][a_,b_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Subscript[\!\(\*UnderscriptBox[\(s\), \(_\)]\),b][a]], xD[s][a,b]};
(*
xDu display definition specified symbol s_.*)
MakeBoxes[xDu[s_][a_,b_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Superscript[\!\(\*UnderscriptBox[\(s\), \(_\)]\),b][a]], xDu[s][a,b]};
(*
xDDeltaD display definition.*)
MakeBoxes[xDDeltaD[a_,b_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Subscript[\!\(\*UnderscriptBox[\("\<D\>"\), \(_\)]\),b][a]], xDDeltaD[a,b]};
(*
xDiscreteDelta display definition.*)
MakeBoxes[xDiscreteDelta[a_,b_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[\!\(\*UnderscriptBox[\("\<\[Delta]\>"\), \(_\)]\)[a,b]], xDiscreteDelta[a,b]}
(*
xSum display definition.*)
MakeBoxes[xSum[a_,b__],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Underscript[\!\(\*UnderscriptBox[\(\(\ \)\("\<\[Sum]\>"\)\), \(_\)]\),Column[{b}]][a]], xSum[a,b]};
(*
xProduct, xUnion, xIntersection display definition. *)
MakeBoxes[xProduct[a_,b__],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Underscript[\!\(\*UnderscriptBox[\(\(\ \)\("\<\[Product]\>"\)\), \(_\)]\),Column[{b}]][a]], xProduct[a,b]};
MakeBoxes[xUnion[a_,b__],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Underscript[\!\(\*UnderscriptBox[\(\(\ \)\("\<\[Union]\>"\)\), \(_\)]\),Column[{b}]][a]], xUnion[a,b]}
MakeBoxes[xIntersection[a_,b__],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Underscript[\!\(\*UnderscriptBox[\(\(\ \)\("\<\[Intersection]\>"\)\), \(_\)]\),Column[{b}]][a]], xIntersection[a,b]}
(*
Bra display definition.*)
MakeBoxes[Bra[b__],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{RowBox[{StyleBox["\[LeftAngleBracket]",Bold],ToBoxes[b],StyleBox["\[RightBracketingBar]",Bold]}], Bra[b]};
(*
Bra display definition without List arguement *13Jul2018*)
MakeBoxes[Bra[b__],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{RowBox[{StyleBox["\[LeftAngleBracket]",Bold],
Thread[MakeBoxes[{b}]][[2;;-2,1]][[1]],
StyleBox["\[RightBracketingBar]",Bold]}], 
Bra[b]};
(*
Ket display definition.*)
(*MakeBoxes[Ket[b__],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm\[Rule]Automatic,
Editable\[Rule]False]& @@{RowBox[{StyleBox["\[LeftBracketingBar]",Bold],ToBoxes[b],StyleBox["\[RightAngleBracket]",Bold]}], Ket[b]};
*)
(*
Ket display definition without List arguement *13Jul2018*)
MakeBoxes[Ket[b__],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{RowBox[{StyleBox["\[LeftBracketingBar]",Bold],
Thread[MakeBoxes[{b}]][[2;;-2,1]][[1]],
StyleBox["\[RightAngleBracket]",Bold]}], 
Ket[b]};
(*
BraKet[b] display definition, <b>  *)
MakeBoxes[BraKet[b__],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{RowBox[{StyleBox["\[LeftAngleBracket]",Bold],ToBoxes[b],StyleBox["\[RightAngleBracket]",Bold]}], BraKet[b]};
(*
BraKet[b,c] display definition, <b|c> *)
MakeBoxes[BraKet[b__,c__],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{RowBox[{StyleBox["\[LeftAngleBracket]",Bold],ToBoxes[b],StyleBox["|",Bold],ToBoxes[c],StyleBox["\[RightAngleBracket]",Bold]}], BraKet[b,c]};

(*
BraKet[a,b,c] display definition, <a|b|c> *)
MakeBoxes[BraKet[a__,b__,c__],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{RowBox[{StyleBox["\[LeftAngleBracket]",Bold],ToBoxes[a],StyleBox["|",Bold],ToBoxes[b],StyleBox["|",Bold],ToBoxes[c],StyleBox["\[RightAngleBracket]",Bold]}], BraKet[a,b,c]};
(*
CommutatorM display definition. *)
MakeBoxes[CommutatorM[a_,b__],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{SubscriptBox[RowBox[{"[",ToBoxes[a],",",ToBoxes[b],"]"}],"-"], CommutatorM[a,b]};
(*
CommutatorP display definition.*)
MakeBoxes[CommutatorP[a_,b__],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{SubscriptBox[RowBox[{"{",ToBoxes[a],",",ToBoxes[b],"}"}],"+"], CommutatorP[a,b]};
(*
HodgeStar display definition*)
MakeBoxes[HodgeStar[a_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[\!\(\*UnderscriptBox[\("\<*\>"\), \(_\)]\)[a]], HodgeStar[a]};
(*
difForm display definition 11July2012*)
MakeBoxes[difForm[a_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[\!\(\*UnderscriptBox[\(d\), \(_\)]\)[a]], difForm[a]};
DifForm:=difForm (*Compatibility*)
(*****************************************************
Indexed derivative Box definitions *migration TARGET *6Feb2015*)
MakeBoxes[tuDDown[s_][a_,b_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Subscript[\!\(\*UnderscriptBox[\(s\), \(_\)]\),b][a]], tuDDown[s][a,b]};MakeBoxes[tuDUp[s_][a_,b_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Superscript[\!\(\*UnderscriptBox[\(s\), \(_\)]\),b][a]], tuDUp[s][a,b]};
(******************************************************)
tuDPartial[a_,b_]:=tuDDown["\[PartialD]"][a,b];
tuDPartialu[a_,b_]:=tuDUp["\[PartialD]"][a,b];
tuDCovariant[a_,b_]:=tuDDown["\[Del]"][a,b];
tuDCovariantu[a_,b_]:=tuDUp["\[Del]"][a,b];
tuDs[s_][a_,b_]:=tuDDown[s][a,b];
tuDsu[s_][a_,b_]:=tuDUp[s][a,b];
tuDLie[a_,b_]:=tuDDown["\[ScriptCapitalL]"][a,b];
tuDOps:=tuDUp[_]|tuDDown[_];

tuDExpand::usage="tuDExpand[ops_:tuDOps,constants_List:{},fnc_:(BraKet|Times|dotOps|Wedge|CircleTimes)] Rules to Expand by name two argument differential operator ops_, e.g., tuDUp[_]|tuDDown[_], tuDPartial, tuDPartialu, tuDCovariant, tuDCovariantu. Terms that match any of list of constants are treated as constant. Leibnitz rule is applied over functions fnc_.  NOTE: seems like only tuDUp[_] and tuDDown [_] work as ops_.  *2Mar2015*27Sep2017*12Feb2019*";
tuDExpand[ops_:tuDOps,constants_List:{},fnc_:(BraKet|Times|dotOps|Wedge|CircleTimes)]:={
((*Liebnitz rule*)
name:ops)[(oo:Flatten[fnc])[a_  ,b__],c__]:>oo[name[a,c],b]+oo[a ,name[oo[b],c]]/;Length[{b}]>1,
(name:ops)[(oo:Flatten[fnc])[a_  ,b__],c__]:>oo[name[a,c],b]+oo[a ,name[b,c]]/;Length[{b}]==1,

(name:ops)[a_+ c_,b_]->name[a,b]+ name[ c,b],
(name:ops)[a_,b_ c_?NumericQ]:> name[a,b]/c,

(name:ops)[Exp[a_],b_]->Exp[a] name[a,b],
(name:ops)[Log[a_],b_]-> name[a,b]/a,

(name:tuDOps)[Power[a_,n_],b_]:>a^n ( Log[a]name[n,b]+n name[a,b]/a),

(name:ops)[a_,b_+c_]->name[a,b]+ name[ a,c],
(name:ops)[a_,b_]:>0/;NumericQ[a] ,
(name:ops)[a_,b_]:>0/;ListMemberQ[a,constants],
(*(ff:(BraKet|Times|dotOps|Wedge|CircleTimes))[b__,  ConjugateTranspose[(name:DerivOps)[a_,a_]]]:>ConjugateTranspose[ff[b]],
*)
(name:ops)[a_,a_]:>1,
(*The following 3 Rules conflict with the above (name:ops)[a_,a_]:>1 and the Liebnitz rule, in that when it is satisfied the coefficient terms are not dealt with properly.   *)
(name:ops)[Conjugate[a_],b_]:>Conjugate[name[a,b]]/;!MemberQ[{"\[Del]"},name],
(name:ops)[ConjugateTranspose[a_],b_]:>ConjugateTranspose[name[a,b]]/;!MemberQ[{"\[Del]"},name],
(name:ops)[Transpose[a_],b_]:>Transpose[name[a,b]],

(name:ops)[a__,\[Mu]_]:>Thread[name[a,\[Mu]]]/;Head[a]==List,
(name:ops)[a_,\[Mu]_]:>Apply[Rule,Thread[name[Apply[List,a],\[Mu]]]]/;Head[a]===Rule,
(name:ops)[(ss:xSum|Sum)[a_,b__],\[Mu]_]:>ss[name[a,\[Mu]],b]
(*Intended to do: \!\(
\*SubscriptBox[\(\[PartialD]\), \(2 x\)]A\)\[Rule](\!\(
\*SubscriptBox[\(\[PartialD]\), \(x\)]A\))/2 but CREATES Rule[] PROBLEMS with some expressions. Avoid cases where b is an integer index.*)
};
(*TEST
difForm[a+b+d]
%//.tuDExpand[difForm]
tuDDown[Dn][a+b,c]
%//.tuDExpand[DerivOps]
tuDDown[Dn][Log[a b],c]
%//.tuDExpand[DerivOps]
tuDDown[Dn][Wedge[a, b,d],c]
%//.tuDExpand[DerivOps]
tuDDown[Dn][ConjugateTranspose[a b  ]e d,b]
%//.tuDExpand[DerivOps]
*)

(**)
tuDExpandF::usage="tuDExpandF[ops_,constants_List:{},fnc_:(BraKet|Times|dotOps|Wedge|CircleTimes)][exp_]Expands terms with two argument differential operator ops_, e.g., tuDUp[_]|tuDDown[_], tuDPartial, tuDPartialu, tuDCovariant, tuDCovariantu. Terms that match any of list of constants are treated as constant. Leibnitz rule is applied over functions fnc_. Applies Mathematica function Dt[]. NOTE: Works with single argumennt differential operator, but does not as Liebnitz rule. WARNING: Does not work with nested ops_. *2Mar2015**27Sep2017*8May2018*";
tuDExpandF[ops_,constants_List:{},fnc_:(BraKet|Times|dotOps|Wedge|CircleTimes)][exp_]:=Module[{sub,tmp=exp,tmp0
},
While[tmp=!=tmp0,
tmp0=tmp;xPrint[tmp];
tmp=tmp//ExpandAll;(*
tmp=tmp//.(name:ops)[a_ +  b_]\[Rule]name[a]+ name[b];*)
tmp=tmp//.(name:ops)[(oo:ProductOp)[a_  ,b__]]:>oo[name[a],b]+oo[a ,If[Length[{b}]>1,name[oo[b]],name[b]]];
tmp=tmp//.tuDExpand[ops,constants,fnc];
(*work around for Dt[a[2]] like terms*)
tmp=tmp/.dd:ops[a_]:>hideDtIntArg[dd];
(*Use Mathematica Dt function\[DoubleLongRightArrow]some Rules above are obsolete.*)
tmp=tmp/.(name:ops)[a_,___]:>0/;ListMemberQ[a,constants]
];
tmp
];
(*TEST
difForm[a+b+d]
%//tuDExpandF[difForm]
d[a[x,y]+b+d]
%//tuDExpandF[d]
tuDDown[Dn][a[x,y]+b,d]
%//tuDExpandF[DerivOps]
tuDDown[Dn][Log[a b],c]
%//tuDExpandF[DerivOps]
tuDDown[Dn][Wedge[a[x], b,d],c]
%//tuDExpandF[DerivOps]
d[a[x,y]+b+d[f[x]]]
%//tuDExpandF[d]
d[Wedge[a[x,y],b+d]]
%//tuDExpandF[d](*no Liebnitz rule*)
tuDDown[Dn][ct[a b],a]
%//tuDExpandF[tuDDown[Dn]]
*)

(*Module to apply Dt where the variables may be a single integer coming from independentVars dummies*)
hideDtIntArg[dtexp_]:=Module[{$=dtexp,op,nn,hideXX,$s,$s1},
op=Head[$];
$=$/. a_[n_]:>hideXX[a,n]/;IntegerQ[n];
$=$/.op->Dt/.Dt->op;xPrint[$//FullForm];
$s=$//tuExtractPattern[Derivative[1,0][hideXX][_,_]]//First;
$s1=op[$s[[1]]]->op[$s[[1]][$s[[2]]]];
$=$/.$s->1 /.$s1;
$=$//.hideXX[a_,n_]->a[n];
$=$//.Derivative[_,0][hideXX][_,_]->0(*set higher Dt\[Rule]0*)
];
tuDExpandFvI::usage="tuDExpandFvI[ops_,constants_List:{},fnc_:(BraKet|Times|dotOps|Wedge|CircleTimes)] wrapper for tuDExpandF[]. Calls  tuOpIndependentVar[tuDExpandF,op$[ops,constants,fnc][exp]] *14Jan2018*";
tuDExpandFvI[ops_,constants_List:{},fnc_:(BraKet|Times|dotOps|Wedge|CircleTimes)][exp_]:=Module[{},
tuOpIndependentVar[tuDExpandF,op$[ops,constants,fnc][exp]]
];

\[Delta]Expand[\[Delta]1_,constants_List:{}][exp_]:=tuDExpandF[\[Delta]1,constants][exp];
DifExpand[ops_,constants_List]:=tuDExpand[ops,constants];
(**)
tuDExpandMultiVar::usage="tuDExpandMultiVar is Rule[] for separating multiple differential symbol into a nest of single differtials: tuDOps[a,{b,c}]->tuDOps[tuDOps[a,b],c] *15Aug2015*";
tuDExpandMultiVar:={(head:DerivOps)[a_,b_List]:>head[head[a,First[b]],If[Length[Rest[b]]>1,Rest[b],Rest[b][[1]]]]
};
(**)
tuDerivativeExpand::usage="tuDerivativeExpand[constants_List:{},fnc_:(BraKet|Times|dotOps|Wedge|CircleTimes)][exp_] expands DerivOps in exp_ by applying tuDExpandMultiVar and tuDExpand. Expands over functions specified by fnc_. Defaults:BraKet|Times|dotOps|Wedge|CircleTimes.  *15Aug2015**27Sep2017*";
tuDerivativeExpand[constants_List:{},fnc_:(BraKet|Times|dotOps|Wedge|CircleTimes)][exp_]:=
Module[{tmp=exp,ops=DerivOps,test=NULL},
tmp=tmp//.tuDExpandMultiVar;(*Expansion for multiple tuOOps *)
While[test=!=tmp,
test=tmp;
tmp=Expand[tmp];
tmp=tmp//tuDExpandF[ops,constants,(fnc|Times)];(*changed 7Dec2017*)
Continue[](*May not need to iterate.*)
];
tmp
];

Clear[tuDExpandD2];
tuDExpandD2::usage="tuDExpandD2[ops_:tuDerivOps,constants_List:{},fnc_:(BraKet|Times|dotOps|Wedge|CircleTimes)][EXP_] expands tuDerivOps expression in EXP_ including its second arguement, *13Dec2017*2May2018*";
tuDExpandD2[ops_:tuDerivOps,constants_List:{},fnc_:(BraKet|Times|dotOps|Wedge|CircleTimes)][EXP_]:=
Module[{tmp=EXP,xdx,$s},
tmp=tmp//.(name:ops)[a_,b___]:>(name[a,xdx[b]]//Inactive[tuDExpandF][xdx,constants,fnc]//tuOpIndependentVarActivate[]//tuDerivativeExpand[constants])/;Length[b]>1&&tuHasNoneQ[b,{xdx}];xPrint[tmp];
(*Clean up xdx[]s*)
tmp=tmp//.(name:ops)[a_,b___]:>(name[a,($s=First[tuExtractPattern[xdx[_]][b]])/.xdx[c_]->c] /(b/.($s->1)))/;Length[b]>1&&tuHasAnyQ[b,{xdx}];
xPrint[$s];
tmp//tuDerivativeExpand[constants]
];
(*EX: $=tuDPartial[a,b^2/c]
$//tuDExpandD2[]
*)
Clear[tuDlHopital]
(*EG:
$=tuDPartialu[T[\[Theta],"d",{1}],\[Tau]]
$=$/.tuDChain[T[\[Omega],"d",{1}],tuDPartialu]
$=$/.T[\[Omega],"d",{1}]\[Rule]T[x,"u",{1}]/r
%//tuDerivativeExpand[{r}]//tuDExpandD2[]//Simplify
tuDlHopital[T[\[Omega],"d",{1}],tuDPartialu]*)
tuDChain::usage="tuDChain[c_,dif_:tuDPartial] Rule for applying the chain rule to dif_[] with c_ as the chain variable: dif_[a_,b_]\[Rule]dif[a,c]dif[c,b]. *21Feb2019*";
tuDChain[c_,dif_:tuDPartial]:=dif[a_,b_]->dif[a,c]dif[c,b]

(*******************************************)
Clear[tuScalarSelect]
tuScalarSelect::usage="tuScalarSelect[scalars_List:{}][exp_] returns a List of NumericQ[] and scalars_ in exp_. *12Nov2015*";
tuScalarSelect[scalars_List:{}][exp_]:=Module[{$=exp,$pos},
$pos=$//tuExtractPositionPattern[{_?NumericQ,scalars}];
$=Map[#[[2]]&,$pos]
];
(**)
Clear[tuScalarDelete]
tuScalarDelete::usage="tuScalarDelete[scalars_List:{}][exp_] returns exp_ with NumericQ[] and scalars_ in removed. *12Nov2015*";
tuScalarDelete[scalars_List:{}][exp_]:=Module[{$=exp,$pos},
$pos=$//tuExtractPositionPattern[{_?NumericQ,scalars}];
$pos=Map[#[[1]]&,$pos];
$=Delete[$,$pos];
$
];

(* 
Commutation and Anti-commutation definitions.*)
tuCommutator::usage = "tuCommutator[op_:Dot,sign_:-1][A_,B_] expands the commutator of matrices A and B using op_ as multiplicative operator. *17Feb2016*";
tuCommutator[op_:Dot,sign_:-1][A_,B_]:=op[A,B]+sign op[B,A]
MCommutator[A_,B_]:=tuCommutator[Dot][A,B]; (*Compatibility*)
ACommutator[A_,B_]:=tuCommutator[Dot,1][A,B];(*Compatibility*)



(* ::Input::Initialization:: *)
(*Extract Sum's from Dot expressions and simplifies Sum LowerIndexTUexpression.*)DotSum2SumDot[exp_]:=Module[{tmp=exp,DEBUG=0,mname="DotSum2SumDot"},
tmp=tmp//.Sum->xSum;
IfDEBUG[mname,DEBUG>0,{tmp},"{tmp1}"];
tmp=tmp//.Dot[a___,xSum[b_,nb__],c___]->xSum[Dot[a,b,c],nb];
IfDEBUG[mname,DEBUG>0,{tmp},"{tmp2}"];
tmp=tmp//.subGatherSum;
tmp=tmp(*//.xSum->Sum*)
];

(*Rules to simplify Scalars in Transpose[] and ConjugateTranspose[] expressions.
Usage: expression//.simpleTranspose[scalar_List]  *)
tuTransposeSimplify::usage="tuTransposeSimplify[scalar_List:{}] Rule[]s for simplifying Transpose expressions.  Accounts for scalars in scalar_List. *16Apr2016*";
tuTransposeSimplify[scalar_List:{}]:={Transpose[a_ b_]:>a Transpose[b]/;(tuMemberQ[a,scalar]||NumericQ[a]),
Transpose[Power[a_,n_] b_]:>Power[a,n] Transpose[b]/;(tuMemberQ[a,scalar]||NumericQ[a]),
Transpose[a_ ]:>a /;tuMemberQ[a,scalar]||NumericQ[a],
Transpose[Power[c_,x_]]:>Power[c,x]/;tuMemberQ[c,scalar],
ConjugateTranspose[Power[a_,b_] ]:>Conjugate[Power[a,b]] /;tuMemberQ[a,scalar],
ConjugateTranspose[a_ ]:>Conjugate[a] /;tuMemberQ[a,scalar],
Transpose[(dd:tuDerivOps)[c_,x_]]:>dd[c,x]/;tuMemberQ[c,scalar],
ConjugateTranspose[(dd:tuDerivOps)[c_,x_]]:>Conjugate[dd[c,x]]/;tuMemberQ[c,scalar]
};
simpleTranspose[scalar_List]:=tuTransposeSimplify[scalar];(*Compatibility*)

(*TransposeMatrix applies Transpose to elements of matrix_ (level 2) where elements may be symbolic elements. *)
(*NOT USED?
TransposeMatrix[matrix_List]:=Module[{tmp=matrix,pos=Position[matrix,_,2]},
pos=Select[pos,Length[#]==2&&!MemberQ[#,0]& ];
MapAt[Transpose[#]&,matrix,pos]
];*)

(*
dotOps Attributes *)
SetAttributes[xDot,{Flat}];
Attributes[CenterDot]={Flat,OneIdentity};
Attributes[xDot]={Flat,OneIdentity};
(*Rule for expanding Dot of Sums*)(*
DotExpand={Dot[a___,b_+c_,d___]->Dot[a,b,d]+Dot[a,c,d],
xDot[a___,b_+c_,d___]->xDot[a,b,d]+xDot[a,c,d]};*)
DotExpandAll[exp_]:=Module[{tmp=exp},
tmp=tmp//ExpandAll;
tmp=tmp//.DotExpand
];
DotExpandAll2[scalar_List][exp_]:=Module[{tmp=exp,tmp1},
While[tmp=!=tmp1,
tmp1=tmp;
tmp=tmp//ExpandAll;
tmp=tmp//.DotExpand;
tmp=tmp//.simpleDot2[scalar]
];
tmp
];

(*
Rules to simplify Dot|xDot expressions. *10Sep2012*)
(*Possible Dot operators*)
dotOps:=Dot|xDot|CenterDot|Inactive[Dot];

(*Often used xDot Rule[]s *)
toxDot:=dotOps->xDot;
toDot:=dotOps->Dot;
toTimes:=dotOps->Times;
toCenterDot:=dotOps|Times->CenterDot
(*
dotTimesTerms[with_List][exp_] replaces terms in Times expression in exp_ with with_ symbols in Dot'ed expression *2Oct2014*)
dotTimesTerms[with_List][exp_]:=Module[{tmp=exp,$with,$without},
tmp=exp/.Times->xTimes;
tmp=tmp/.xTimes[a__]:>xTimes[$with[Select[{a},!ListFreeQ[#,with]&]]$without[Select[{a},ListFreeQ[#,with]&]]];
tmp=tmp/.{$with[{}]->1,$without[{}]->1};
tmp=tmp/.$with[{a__}]->Inactive[Dot][a]/.$without[{a__}]->Times[a]/.xTimes->Times//Activate
];
(*productOps definition*)
productOps:=dotOps|Times|CircleTimes//Flatten

(**)
tuOpSwitch::usage="tuOpSwitch[op1_,op2_][exp_] Switches order of op1_ and op2 in exp_ through Repeated Rule. Primarily for operators: Sum, Integrate, i.e., operators with operand as first arguement. *10Feb2017*";
tuOpSwitch[op1_,op2_][exp_]:=Module[{$=exp,op1a,op2a},
(*delayed Symbol assignment*)
op1a=If[tuMemberQ[op1,tuDerivOps],op1[a_,b_]//Head,op1];
op2a=If[tuMemberQ[op2,tuDerivOps],op2[a_,b_]//Head,op2];
$=$//.(ooA:op1a)[(ooB:op2a)[a_,b___],c___]->ooB[ooA[a,c],b]
];

tuOpNestGather::usage="tuOpNestGather[op_,product_:Times][exp_] gathers nested operators op_ into an expression with one op_. Product operator product_ may be specified.,  e.g., xSum[aa[i]\[CenterDot]xSum[bb[k],{k,3},{m,4}],{i,2},{j,3}]//tuOpNestGather[xSum,CenterDot] \[LongRightArrow] xSum[aa[i]\[CenterDot]bb[k],{k,3},{m,4},{i,2},{j,3}]. WARNING: Does not work with Sum, Switch to Inactive[Sum]. *19Oct2015*";
(*tuOpNestGather[op_,product_:Times][exp_]:=Module[{$=exp,$0},
While[$0=!=$,
$0=$;
$=$//.op[ op[b_,c___],d___]\[Rule]op[b,c,d];
$=$//.op[a_,b___]+op[c_,b___]\[Rule]op[a+c,b];
$=$//.(pp:product)[op[a_,d___]  ,op[b_,c___]]\[Rule]op[pp[a, b],c,d];
$=$//.(pp:product)[a_,op[b_,c___]]\[Rule]op[pp[a,b],c];
$=$//.(pp:product)[op[b_,c___],a_]\[Rule]op[pp[b,a],c];
$=$//.op[(pp:product)[a_ , op[b_,c___]],d___]\[Rule]op[pp[a, b],c,d];
];
$
];*)
tuOpNestGather[op_,product_:Times][exp_]:=Module[{$=exp,$0,iproduct=Inactive[product]},
$=$/.product->iproduct;
While[$0=!=$,
$0=$;xPrint[{$0,iproduct}];
$=$/.op[(pp:iproduct)[a___, op[b__,c___],d___]]:>op[pp[a, b,c,d]];
$=$//.(pp:iproduct)[a___,op[b_,c___],d___]->op[pp[a,b,d],c];
$=$//.op[a_,b___]+op[c_,b___]->op[a+c,b];
$=$//.(pp:iproduct)[op[a_,d___]  ,op[b_,c___]]->op[pp[a, b],c,d];
];
Activate[$,product]
];

tuOpDistribute::usage="tuOpDistribute[op_,over_:Plus] Rule for distributing op_ over over_. EG.
a.(b-c).d/.tuOpDistribute[dotOps]->a.b.d+a.(-c).d. Works with op_s of form  CommutatorM[arg__\!\(\*SubscriptBox[\(]\), \(\[Rho]\)]\) as well.  *21May2015*23Jun2017*";
tuOpDistribute[op_,over_:Plus]:={oo:(op/.Dot->dotOps)[a1___,over[a_,ap__],a2___]:>Distribute[ExpandAll[oo],over]
};
(*TEST*)
(*
$=a.(b+c.(d+e))
$//.tuOpDistribute[Dot]
$=fn[fn[c,n+m]+fn[a+b,1],2]
$//.tuOpDistribute[fn]
$=CommutatorM[a,CommutatorM[a+c,b]]
$//.tuOpDistribute[CommutatorM]
*)
DotExpand:=tuOpDistribute[dotOps];(*Compatibility*)
(**)
tuOpDistributeF::usage="tuOpDistributeF[op_,over_:Plus][exp_] applies Rule[] tuOpDistribute over ExpandAll[exp_].  op_ may be somewhat complex in that operators like CommutatorM[arg__\!\(\*SubscriptBox[\(]\), \(\[Rho]\)]\) may be specified.  arg__ is needed to specify position of the arguement. EG.
a.(b-c).d//tuOpDistributeF[dotOps]->a.b.d+a.(-c).d. *10Feb2016*8July2018*";
tuOpDistributeF[operator_,over_:Plus][exp_]:=Module[{tmp},
tmp=ExpandAll[exp]//.tuOpDistribute[operator,over]
];
(*TEST
a.((b+c)/2).d/. tuOpDistribute[Dot]
%//tuOpDistributeF[Dot]
*)
(****)
tuOpSimplify::usage="tuOpSimplify[operator_,scalars_List:{}] Rule for simplifying operator[] expressions by removing NumericQ and scalars_ from its arguements. NOTE: Some of these Rule[]s do not seem active for some expressions. BUG: Does not catch some scalars_. *26Sep2015**21Mar2018*";
tuOpSimplify[operator_,scalars_List:{}]:=Flatten[{
(op:operator)[a_]:>a/;MatchQ[op,dotOps],
(op:operator)[a_]->a,(*1Apr2017*)
(op:operator)[]->1,
(op:operator)[Longest[a___],(cc:c_^(n_:1)) d_,Longest[e___]]:>cc op[a,d,e]/;((NumericQ[c])||tuMemberQ[c,scalars])&&((NumericQ[n])||tuMemberQ[n,scalars]),
(op:operator)[Longest[a___],(cc:c_^(n_:1))  ,Longest[d___]]:>cc op[a,d]/;(((NumericQ[c])||tuMemberQ[c,scalars])&&((NumericQ[n])||tuMemberQ[n,scalars])),
Conjugate[(op:operator)[a__]]:>Apply[op,Thread[Conjugate[{a}]]]
}];
(**)
tuOpSimplifyF::usage="tuOpSimplifyF[operator_,scalars_List:{}] [exp_] simplifies operator[] expressions by removing NumericQ and scalars_ from its arguements. operator_ may be somewhat complex in that operators like CommutatorM[arg__\!\(\*SubscriptBox[\(]\), \(\[Rho]\)]\) may be specified.  arg__ is needed to specify position of the arguement. NOTE: Applies tuOpSimplify Rule[]s above. *10Feb2016*";
tuOpSimplifyF[operator_,scalars_List:{}][exp_]:=Module[{func,tmp,oper,$ss,arg},
If[Head[operator]==Symbol||Head[operator]==Alternatives,
tmp=exp//.tuOpSimplify[operator,scalars],
(*attempt to handle generalize functions e.g. Subscript[[a,b], R]  *)
$ss=func[arg]->tuPatternRemove[operator]//tuAddPatternVariable[arg,BlankSequence];xPrint[$s];
tmp=exp/.operator->func[arg];xPrint[{4,operator,tmp}];
tmp=tmp//.tuOpSimplify[func,scalars];
tmp=tmp/.$ss
];
tmp
];
(**)
Clear[tuOpSimplifyFirst]
tuOpSimplifyFirst::usage="tuOpSimplifyFirst[operator_,scalars_List:{}][exp_] applies tuOpSimplify[] to the First arguement of operator_s in exp_ accounting for scalars_ which are moved out of the arguement list. Only Times[] terms as first arguements are assumed. *23Oct2015*";
tuOpSimplifyFirst[operator_,scalars_List:{}][exp_]:=Module[{$=exp,xTimes,xUNIT},
$=$/.(op:operator)[a_ ,b___]:>op[(AppendTo[xTimes@@{a},xUNIT]//.tuOpSimplify[xTimes,scalars]),b];xPrint["X: ",$];
$=$/.(op:operator)[(aa_:1)   xTimes[c1___],b___]->aa op[(Hold[Times][c1]),b]//ReleaseHold;
$=$/.xUNIT->1
];

tuOpBlankFill::usage="tuOpBlankFill[exp_] returns an expression with Blank[]s in the operator filled with its arguement, e.g. op[_][arg]\[Rule]op[arg].  Only works for simple expressions. Use carefully. *15May2016*";
tuOpBlankFill[exp_]:=Module[{$=exp,head,arg},
head=Head[$]/.Blank->xBlank;
arg=$[[1]];
head=head/.xBlank[]->arg
];

(*
Rules for simplifying dotOps with NumericQ and Conjugates *10Sep2012*)
simpleDot:={
(op:dotOps)[a___,n_ d_,c___]:>n op[a,d,c]/;NumericQ[n],
(op:dotOps)[a___,b_,c___]:>b op[a,c]/;NumericQ[b]&&Length[{a,c}]>0,
(op:dotOps)[a___,b_,c___]:>b /;NumericQ[b]&&Length[{a,c}]===0,
(op:dotOps)[a___,-b_,c___]->- op[a,b,c],
Conjugate[(op:dotOps)[a__]]:>Apply[op,Thread[Conjugate[{a}]]]
};
(*
simpleDot1a[scalars_List][exp_] applies Rules for simplifying Dot|xDot expressions in exp_ accounting for scalars_List.  Conjugate and Transpose of scalars_List are considered scalars.  (Replaces simpleDot1, but has name conflict with it.)*10Sep2012*)
simpleDot1a[scalars_List][exp_]:=Module[{tmp=exp,sub,scal=Join[Conjugate[scalars],scalars]},
sub={
DotExpand,
simpleDot,
(op:dotOps)[a___,d___ c_,b___]:>c  op[a,d,b]/;ListMemberQ[c,scal],
(op:dotOps)[a___,c_,b___]:>c op[a,b]/;ListMemberQ[c,scal],
(op:dotOps)[a___,d___ c_^n_,b___]:>c^n op[a,d,b]/;(ListMemberQ[c,scalars]||ListMemberQ[c,scal]),
(op:dotOps)[a___,c_^n_,b___]:>c^n op[a,b]/;ListMemberQ[c,scal],
simpleTranspose[scalars]
}//Flatten;
tmp//.sub
];

(*
Rules to simplify Dot expressions with extention to simpleDot to account for scalars_.  Usage: expression//.simpleDot1[scalars_List] *)
simpleDot1[scalars_List]:={
(op:dotOps)[a___,d___ c_,b___]:>c op[a,d,b]/;ListMemberQ[c,scalars],
(op:dotOps)[a___,d___ c_^n_,b___]:>c^n op[a,d,b]/;ListMemberQ[c,scalars],
(op:dotOps)[a___,c_,b___]:>c op[a,b]/;ListMemberQ[c,scalars]&&(Length[{a}]>0||Length[{b}]>0),
(op:dotOps)[a___,c_^n_,b___]:>c^n op[a,b]/;ListMemberQ[c,scalars]&&(Length[{a}]>0||Length[{b}]>0),
simpleTranspose[scalars],
simpleDot}//Flatten;

(*Rules to simplify Dot expressions with extention to simpleDot to account for scalars_.  Include DotExpand.
Usage: expression//.simpleDot2[scalars_List].  NOTE: DotExpand works for only simple sums. *)
simpleDot2[scalars_List]:={
DotExpand,
simpleDot1[scalars]
}//Flatten;

(**)
tuDotSimplify::usage="tuDotSimplify[scalars_List][exp_] expands and simplifies Dot|xDot expressions in exp_ accounting for scalar_List. *20Feb2015*";
tuDotSimplify[scalars_List:{}][exp_]:=Module[{tmp=exp,tmp1},
While[tmp=!=tmp1,
tmp1=tmp;
tmp=tmp//DotExpandAll;(*CAREFUL of nested Dot[]s*)
tmp=tmp//.simpleDot2[scalars]
];
tmp
];
simpleDot3[scalars_List:{}][exp_]:=tuDotSimplify[scalars][exp];
(*
ruleSimpleDot[rule_List,scalar_List,constant_List][exp_] recurrent combinations of Functions. *27Oct2014*)ruleSimpleDot[rule_List,scalar_List,repeat_Integer:2][exp_]:=Module[{tmp=exp,tmp1,xrule=Flatten[rule],n=0},
While[tmp=!=tmp1&&n<repeat,tmp1=tmp;n++;
tmp=tmp/.xrule//simpleDot3[scalar];
];
tmp
];
ruleSimpleDot[rule_List,scalar_List,constant_List,repeat_Integer:2][exp_]:=Module[{tmp=exp,tmp1,xrule=Flatten[rule],n=0},
While[tmp=!=tmp1&&n<repeat,tmp1=tmp;n++;
tmp=tmp/.xrule//tuDerivativeExpand[constant]//simpleDot3[scalar];
];
tmp
]
(*
orderDot[exp_(Dot|xDot)] Orders terms in exp_(Dot|xDot) *10Oct2012*)
orderDot[exp_Dot|exp_xDot]:=Apply[Head[exp],Sort[Apply[List,exp]]](*Simple Sort will do.*)
(*
orderArg[term_] orders arguements of any term_.  Supercede orderDot. E.G.: exp/.dot:Dot[a_,b_]:>orderArg[dot]   *23Oct2012*)
orderArg[term_]:=Apply[Head[term],Sort[Apply[List,term]]]
(*
SeparateInto2After[term_][exp_] separates exp_ into 2 pieces with the same Head. The separation point right after term_ which may be a pattern.  Usage example:
exp /.dot:HoldPattern[Dot[a_,b__]]\[RuleDelayed]SeparateInto2After[Subscript[u, e][_]][dot]   *10Nov2012*)
SeparateInto2After[term_][exp_]:=Module[{head,tmp=exp,pos,front,back},
head=Head[tmp];
tmp=Apply[xDot,tmp];
pos=Position[tmp,term,1,1]//Flatten;
front=Apply[head,Take[tmp,Flatten[Append[{1},pos]]]];
back=Apply[head,Take[tmp,Flatten[Append[pos+1,{-1}]]]];
front back
];

(*
CollectDotRight[var_][exp_] collects var_ terms in exp_ if var_ is on the right of Dot[...,var_] or in a Times term.  *10Oct2013*)
CollectDotRight[var_][exp_]:=Module[{tmp=exp,test,tmp1,pos},
tmp=tmp/.Dot->xDot;
tmp=tmp/.{var  ii:___->xDot[ii].test[var],b___ var^n_->xDot[b var^(n-1)]. test[var],xDot[b__,var]->xDot[b] . test[var]};
pos=Position[tmp,Dot[a__,test[_]],2];(*???ERR\[LeftArrow]no Dot*)
tmp1=Extract[tmp,pos]/.test[_]->1//Apply[Plus,#]&;
tmp1=tmp1//.simpleDot2[{}]/.fxDot->Dot;
tmp1=Dot[tmp1,var];
tmp=Delete[tmp,pos];
tmp+tmp1/.xDot->Dot
];
(*
CollectDotLeft[var_][exp_] collects var_ terms in exp_ if var_ is on the left of Dot[var_,...,] or in a Times term.  *10Oct2013*)
CollectDotLeft[var_][exp_]:=Module[{tmp=exp,test,tmp1,pos},
tmp=tmp/.Dot->xDot;
tmp=tmp/.{var  ii:___->test[var].xDot[ii],b___ var^n_->test[var].xDot[b var^(n-1)],xDot[var, b__]-> test[var].xDot[b]};xPrint[tmp];
pos=Position[tmp,Dot[test[_],a__],2];xPrint[pos];(*???ERR\[LeftArrow]no Dot*)
tmp1=Extract[tmp,pos]/.test[_]->1//Apply[Plus,#]&;xPrint[tmp1];
tmp1=tmp1//.simpleDot2[{}]/.xDot->Dot;
tmp1=Dot[var,tmp1];
tmp=Delete[tmp,pos];
tmp+tmp1/.xDot->Dot
];

tuVarsInExp::usage="tuVarsInExp[exp_] produces a List of variables in exp_ accounting for tuRuleIndependentVarPattern. *21Feb2019*";
tuVarsInExp[exp_]:=Module[{$},
$=tuOpIndependentVar[Level,op$[exp,20]];
Select[$,!NumericQ[#]&&(AtomQ[#]||!MemberQ[Attributes[Evaluate[Head[#]]],Protected])
&]//DeleteDuplicates
];
(*TEST
$=a.b c[x][y] d f T[tt,"u",{i}].Subscript[s, j]
$//tuVarsInExp
*)

Clear[tuVarCount]
tuVarCount::usage="tuVarCount[var_][exp_] return the Count of var_ in exp_.  exp_ is wrapped in tuOpIndependentVar before evaluation. *22Feb2019*";
tuVarCount[var_][exp_]:=Module[{$},
$=tuOpIndependentVar[Level,op$[exp,20]];
Select[$,!NumericQ[#]&&(AtomQ[#]||!MemberQ[Attributes[Evaluate[Head[#]]],Protected])
&]//Count[var]
];
(*
TEST
$=-2 \[ImaginaryI] \[CurlyEpsilon].\[Chi] \[CurlyEpsilon].Subscript[Underscript["\[PartialD]", _], \[Tau]][\[CurlyEpsilon]].\[Chi].Subsuperscript[\[Psi], \[Mu], \[Mu]] Subscript[Underscript["\[PartialD]", _], \[Tau]][Subsuperscript[X, \[Mu], \[Mu]]]
tuVarCount[\[CurlyEpsilon]][$]
*)

tuVarCollect::usage="tuVarCollect[side_String:'LR'][exp_] collects left/right end variables of dotOps|CircleTimes terms in Plus[] expression to the left/right.  The side_String 'L','R','LR' determines the side to collect. *26May2016*";
tuVarCollect[side_String:"LR"][exp_]:=Module[{tmp=exp,SCL,ops=Flatten[dotOps|CircleTimes]},
xPrint[ops];
If[!StringFreeQ [side,"R"],
tmp=tmp/.(dd:ops)[a__](acc___:1):>dd[SCL[acc],a]/.dd[SCL[1],a__]->dd[a];
tmp=tmp//.(dd:ops)[a__,Longest[c__]]+(dd:ops)[b__,Longest[c__]]->dd[(dd[a]+dd[b]),c];
tmp=tmp/.(dd:ops)[SCL[a__],b__]->SCL[a]dd[b]/.SCL[a__]:>Times[a]
];
If[!StringFreeQ [side,"L"],
tmp=tmp/.(dd:ops)[a__](acc___:1):>dd[a,SCL[acc]]/.dd[a__,SCL[1]]->dd[a];
tmp=tmp//.(dd:ops)[Longest[c__],a__]+(dd:ops)[Longest[c__],b__]->dd[c,(dd[a]+dd[b])];
tmp=tmp/.(dd:ops)[b__,SCL[a__]]->SCL[a]dd[b]/.SCL[a__]:>Times[a]
];
tmp/.ops[a_]:>a/;Length[{a}]==1
]
(*TEST*)
(*scal(a\[CircleTimes]Subscript[1, n]\[CircleTimes]d)-a\[CircleTimes]0+(-b)\[CircleTimes](-Subscript[1, n])\[CircleTimes](d)//.tuOpSimplify[CircleTimes]
%//tuVarCollect["R"]
scal(a\[CenterDot]Subscript[1, n]\[CenterDot]d)-a\[CenterDot]0+(-b)\[CenterDot](-Subscript[1, n])\[CenterDot](-d)//.tuOpSimplify[CenterDot]
%//tuVarCollect["R"]
*)
tuDotVarCollect:=tuVarCollect;(*Compatibility*)
tuDotVarCollect::usage="tuDotVarCollect[side_String:'LR'][exp_] collects left/right end variables of dotOps terms in Plus[] expression to the left/right.  The side_String 'L','R','LR' determines the side to collect. Replaced by tuVarCollect. *17Feb2016*";
collectDotTermsLeftRight[exp_Plus]:=tuVarCollect["LR"][exp];(*Compatibility*)
collectDotRight[exp_]:=tuVarCollect["R"][exp];(*Compatibility*)
collectDotLeft[exp_]:=tuVarCollect["L"][exp];(*Compatibility*)

(*
Rules to simplify NonCommuting expressions.  Usage: a\[CircleTimes](4 b)\[CircleTimes]c//.simpleNC[op]. NOTE: Does not work for Dot. 25 June 2012 *)
Clear[simpleNC];
simpleNC[op_,scalars_List]:={
op[a___,d___ c_,b___]:>c op[a,d,b]/;ListMemberQ[c,scalars],
op[a___,d___ c_^n_,b___]:>c^n op[a,d,b]/;ListMemberQ[c,scalars],
op[a___,c_,b___]:>c op[a,b]/;ListMemberQ[c,scalars]&&(Length[{a}]>0||Length[{b}]>0),
op[a___,c_^n_,b___]:>c^n op[a,b]/;ListMemberQ[c,scalars]&&(Length[a]>0||Length[b]>0),
simpleTranspose[scalars],(*CHECK if appropriate.*)
op[a___,n_ d_,c___]:>n op[a,d,c]/;NumericQ[n],
op[a___,b_,c___]:>b op[a,c]/;NumericQ[b],
op[a___,-b_,c___]->-op[a,b,c],
Conjugate[op[a__]]:>Map[Conjugate[#]&,op[a]]/;op=!=Dot
}//Flatten;
(**)
tuOpIfMultiArg::usage="tuOpIfMultiArg[op_,arg_List] forms op_[arg_] if Length of arg_List > 1 *4Mar2016*";
tuOpIfMultiArg[op_,arg_List]:=Module[{$},
If[Length[arg]>1,op[Apply[Sequence,arg]],arg[[1]] ]
];
(**)
Clear[tuOpCollectR];
tuOpCollectR::usage="tuOpCollectR[op_:dotOps,dist_:Plus] is Rule[]s for collecting terms with common symbol on the left or right of a dist_ expressions.
 ie. c1(a.b)+d1(c.b)\[Rule](c1 a+d1 c).b. NOTE: has problems with complex expressions. *1Mar2016*";
tuOpCollectR[op_:dotOps,dist_:Plus]:={
(*RHS*)
dist[ (c1_:1)(oo:op)[a1__ ,Longest[ b__]] ,(c2_:1)(oo:op)[a2__,  Longest[ b__]]]:>oo[dist[c1  tuOpIfMultiArg[oo,{a1}]
,c2 tuOpIfMultiArg[oo,{a2}]] , tuOpIfMultiArg[oo,{b}]],
(*LHS*)
dist[(c1_:1)(oo:op)[Longest[ b__],a1__ ] ,(c2_:1)(oo:op)[Longest[ b__],a2__ ]]:>oo[tuOpIfMultiArg[oo,{b}], dist[c1  tuOpIfMultiArg[oo,{a1}],c2 tuOpIfMultiArg[oo,{a2}]] ]
};
(**)
Clear[tuOpCollect];
tuOpCollect::usage="tuOpCollect[op_:dotOps,dist_:Plus,distribute_:True][EXP_] collects common symbols on the left and right of op_ terms in a dist_[op_] expression in EXP_.  If distribute_ is False tuOpDistribute[op,dist] in not applied.  EG: \[IndentingNewLine] cc1 a1.b1.c1 + cc2 a1.b2.c1 \[Rule] a1.(b1 cc1+b2 cc2).c1 *5Mar2018*";

tuOpCollect[op_:dotOps,dist_:Plus,distribute_:True][EXP_]:=Module[{$=EXP,Id,xPlus},
Attributes[xPlus]={Flat};
(*Add dummy identity so tuOpCollect works*)
$=$//ExpandAll;
$=If[distribute,$//.tuOpDistribute[op,dist],$];
$=$//.tuOpSimplify[op];
$=$//.dist->xPlus;(*Need xPlus replacement for dist_ so that following Rule[] works.*)
(* Add Id: var\[Rule]Id.var.Id *)
$=$/.xPlus[a__]:>Apply[xPlus,#/.(dd:op)[aa__]:>dd[Id,aa,Id]&/@{a}];
(*Collect op_ and Simplify, remove Id.*)
$//.tuOpCollectR[op,xPlus]//.tuOpSimplify[op,{Id}]/.Id->1/.xPlus->dist
];
(*TEST
 cc1 a1.b1. c1 + cc2 a1.b2.c1 //tuOpCollect[]*)

(**)
Clear[tuCircleTimesMatrix];
tuCircleTimesMatrix::usage="tuCircleTimesMatrix[exp_] expands all instances of a\[CircleTimes]b where a|b are Metrices|Arrays and turns it into Matrices of \[CircleTimes] over its elements, e.g., {{a,b}}\[CircleTimes]{{c,d}}->{{a\[CircleTimes]c,b\[CircleTimes]d}}. Works with \[CircleTimes] expression with multiple arguments. 2Apr2017*";
tuCircleTimesMatrix[exp_]:=Module[{$=exp,$p},
$p=$//tuExtractPositionPattern[CircleTimes[__]];
$p=$p//.cc:CircleTimes[__]:>tuCircleTimesMatrix1[cc]//.tuOpSimplify[CircleTimes];
$p=Map[#[[1]]->ArrayFlatten[#[[2]],2]&,$p];xPrint[$p];
$=tuReplacePart[$,$p]//.tuOpSimplify[CircleTimes]
];
tuCircleTimesMatrix1[exp_CircleTimes]:=Module[{$0=exp,$,$1,$1a,X},
$1=X[#]&/@$0;
$1=$1//tuExtractPositionPattern[X[List[__]]]//First;xPrint[$1,$0];
If[FreeQ[$1,X[List[__]]],Return[$0]];(*No Lists in \[CircleTimes] exp_*)
$1=$1/.X[a_]->a;
$1a=$1[[2]]/.List->xList
//tuExtractPositionPattern[_?(FreeQ[#[[2]],xList]&)];
$1a=Select[$1a,FreeQ[#,xList]&];xPrint[$1a];
$=#[[1]]->tuReplacePart[$0,{$1[[1]]->#[[2]]}]&/@$1a//Flatten;
$=tuReplacePart[$1[[2]],$];
xPrint[ArrayDepth[$],Dimensions[$]];
$
];


Clear[tuCircleTimesOp];
tuCircleTimesOp::usage="tuCircleTimesOp[OP_:Null][exp_] PROTOTYPE routine to expand \[CircleTimes] expression.  (a\[CircleTimes]b)[c\[CircleTimes]d] \[Rule] a[c]\[CircleTimes]b[d], (a\[CircleTimes]b\[CircleTimes]c).(a1\[CircleTimes]b1\[CircleTimes]c1) \[Rule] a.a1\[CircleTimes]b.b1\[CircleTimes]c.c1.  OP_ does nothing. *2Jul2015*";
tuCircleTimesOp[OP_:Null][exp_]:=Module[{$0=exp,$,ops=Flatten[Times|dotOps]},
$=$0;xPrint[" ",$];
(*Nested (a\[CircleTimes]b)[c\[CircleTimes]d] \[Rule] a[c]\[CircleTimes]b[d] *)
$=$/.CircleTimes[f__][ CircleTimes[d__]]:>Inner[#1[#2]&,{f},{d},CircleTimes]/;Length[{f}]>1&&Length[{f}]==Length[{d}];
(*Distribute arguements over each element of \[CircleTimes].*)
$=$/.CircleTimes[f__][d__]:>Apply[CircleTimes,Map[#[d]&,{f}]]/;Length[{f}]>1;
(*Distribute op_ over \[CircleTimes]*)
xPrint[Flatten[ops|OP]];
$=$/.oo:op_[CircleTimes[a__] , CircleTimes[b__],c___]:>Thread[oo,CircleTimes]/;MemberQ[Flatten[ops|OP],op];
$
];

tuCircleTimesExpand::usage="tuCircleTimesExpand[exp_] distributes CircleTimes Head over arguements. e.g. (a\[CircleTimes]b)[ c\[CircleTimes]d ]\[Rule]a[ c ]\[CircleTimes]b[ d ] and (a\[CircleTimes]b)[ c ]\[Rule]a[ c ] \[CircleTimes] b[ c ] and dotOps[a\[CircleTimes]b,c\[CircleTimes]d]->dotOps[a,c] \[CircleTimes] dotOps[b,d] .  *1Oct2015*";
tuCircleTimesExpand[exp_]:=Module[{$,ops=Flatten[Times|dotOps]},
$=exp;
$=$/.CircleTimes[f__][  CircleTimes[d__]  ]:>Inner[#1[#2]&,{f},{d},CircleTimes]/;Length[{f}]>1&&Length[{f}]==Length[{d}];
$=$//.CircleTimes[f__][d__]:>Apply[CircleTimes,Map[#[d]&,{f}]]/;Length[{f}]>1;
$=$//.oo:op_[c1:CircleTimes[a__] , c2:CircleTimes[b__],c___]:>op[Thread[op[c1,c2],CircleTimes],c]/;MemberQ[ops,op];
$
];

Clear[tuCircleTimesGather]
tuCircleTimesGather::usage="tuCircleTimesGather[altOP_:Null][exp_] gathers \[CircleTimes] expressions, e.g., (aa(a\[CircleTimes]b)).(cc(c\[CircleTimes]d))->((aa a).(cc c))\[CircleTimes](b.d). If altOP_ specified this operator is used instead of dotOps. Any \!\(\*SubscriptBox[\(1\), \(n\)]\) are taken as placeholders and only one is output, e.g., (\!\(\*SubscriptBox[\(1\), \(3\)]\)\[CircleTimes]d)-cc (\!\(\*SubscriptBox[\(1\), \(3\)]\)\[CircleTimes]f)\[Rule]\!\(\*SubscriptBox[\(1\), \(3\)]\)\[CircleTimes](d-cc f).  NOTE: Coefficients are placed in the first space.*16Apr2016*";
tuCircleTimesGather[scal_:{},altOP_:Null][exp_]:=Module[{$=exp,xOP,narg,ops=Flatten[dotOps],$s},
If[altOP=!=Null,ops=altOP];xPrint[ops];
$=$//.tuOpSimplify[CircleTimes,Flatten[{scal}]];
(*Simplified 21May2016*)
(* Combine (cc(a\[CircleTimes]b)).(dd(c\[CircleTimes]d))\[Rule]((cc a).(dd c))\[CircleTimes](b.d) *)
$=$//.a_(b_\[CircleTimes]c_)->(a b) \[CircleTimes]c/.oo:ops:>xOP[oo];
$=$/. oo:xOP[_][arg__]:>Thread[oo,CircleTimes];
$=$/.xOP[a_]->a;
(* Gathering over PlusRule *)(*REMOVED use tuVarCollect[].
$s={(ca_:1) a_ \[CircleTimes]ss_+(cb_:1)b_ \[CircleTimes]ss_\[Rule](ca a+cb b)\[CircleTimes]ss,
(ca_:1)ss_\[CircleTimes] a_ +(cb_:1)ss_\[CircleTimes]b_ \[Rule]ss\[CircleTimes](ca a+cb b)
};*)(*
Print[$tmp=$];*)
$=$//tuRepeat[{ Subscript[1, n_]^(m_:1)->Subscript[1, n],ops[Subscript[1, n_]..]->Subscript[1, n]},{tuOpCollect[CircleTimes],tuOpSimplifyF[ops,{}],tuOpSimplifyF[CircleTimes,Flatten[{scal}]]},
10];
Return[$];
];
(*TEST*)(*
scal(a\[CircleTimes]b\[CircleTimes]d)-a\[CircleTimes]0+(-b)\[CircleTimes](-c)\[CircleTimes](d)
%//tuCircleTimesGather[]
scal(a\[CircleTimes]d)-a\[CircleTimes]0+(-b)\[CircleTimes](d)
%//tuCircleTimesGather[scal]
scal(a\[CircleTimes]Subscript[1, n]\[CircleTimes]d)-a\[CircleTimes]0+(-b)\[CircleTimes](-Subscript[1, n])\[CircleTimes](d)
%//tuCircleTimesGather[scal]
scal(a\[CircleTimes]d).((-b)\[CircleTimes](Subscript[1, n]))+((-e)\[CircleTimes](Subscript[1, n])).((-f)\[CircleTimes](Subscript[1, n]))
%//tuCircleTimesGather[scal]*)


Clear[tuCircleTimesInnerTerm];
tuCircleTimesInnerTerm::usage="tuCircleTimesInnerTerm[difOp_][exp_] computes the inner terms produced when merging CircleTimes operator expressions, exp_, e.g., (a\[CircleTimes]b).(c\[CircleTimes]d)\[Rule](a.c)\[CircleTimes](b.d)+(a.tuCircleTimesInnerTerm[c[b],\[Del]])\[CircleTimes](d).  Assumes dotOps variable separators.  *2Mar2016*"  ;
tuCircleTimesInnerTerm[difOp_][exp_]:=Module[{$h,$h1,$dif,$=exp},
$h=Head[exp];xPrint[$h];
If[FreeQ[$h,difOp],$=0;,
If[!FreeQ[$h,dotOps],xPrint["$XX ",$h];
$dif=tuExtractPattern[difOp][$h][[1]];xPrint[exp];
$=$dif[exp[[1]]];xPrint[$h,Length[$h]];
$h1=Head[$h];
If[tuMemberQ[$h1,dotOps],
$h=Apply[$h1,DeleteCases[Apply[List,$h],difOp]];
$=Apply[$h1,{$h,$}]
];
];
];
$
];
(**)
Clear[tuCircleTimesSimplify];
tuCircleTimesSimplify::usage="tuCircleTimesSimplify[exp_] zeros CircleTimes terms that contain 0, Moves signs of components to overall expression. NOTE: tuOpSimplify[CircleTimes] may be all that is needed. *14Apr2016*";
tuCircleTimesSimplify[exp_]:=Module[{$=exp},
$//.tuOpSimplify[CircleTimes](*replaced 17May2016*)
];

Clear[tuCircleTimesSeparate]
tuCircleTimesSeparate::usage="tuCircleTimesSeparate[{spaceVar_List:{},derivatives:DerivOps}][exp_] separates product spaces (e.g. a\[CircleTimes]b) in exp_  into Dot product of product spaces involving only one of the spaces (a\[CircleTimes]b\[Rule](a\[CircleTimes]\!\(\*SubscriptBox[\(1\), \(b\)]\)).(\!\(\*SubscriptBox[\(1\), \(a\)]\)\[CircleTimes]b)). spaceVar_List:{} specifies Lists of Patterns that group variables of each space ({\!\(\*SubscriptBox[\(1\), \(a\)]\),A,B},{\!\(\*SubscriptBox[\(1\), \(b\)]\),a,b,Tensor[a|b,_,_]}). The first element of each space pattern List is its identity element(\!\(\*SubscriptBox[\(1\), \(n_\)]\)). *21May2016*";
tuCircleTimesSeparate[spaceVars_List:{},derivatives_:DerivOps][exp_]:=Module[{$,$0=exp,$1,$1a,$2,ops=dotOps,nspace=Length[spaceVars],$i,$j,pattern,$list
},
(*template for finding products*)
pattern=Apply[CircleTimes,Table[_,nspace]];
$list=$0//tuExtractPositionPattern[pattern];
(*identity array*)
$1a=$1=Apply[CircleTimes,Map[#[[1]]&,spaceVars]];
For[$i=1,$i<=Length[$list],$i++,
$2={};
 $=$list[[$i,2]];
For[$j=1,$j<=nspace,$j++,
$1=$1a;
$1[[$j]]=$[[$j]];
If[$1=!=$1a,AppendTo[$2,$1]];
];
$list[[$i,2]]=Apply[Dot,$2];
];
tuReplacePart[$0,$list]
];

Clear[tuDotCircleTimesOrder]
tuDotCircleTimesOrder::usage="tuDotCircleTimesOrder[{spaceVar_List:{},derivatives:DerivOps}][exp_] Cononically orders Dot product of product spaces (e.g. (c\[CircleTimes]b).(a\[CircleTimes]b)->(a\[CircleTimes]b).(c\[CircleTimes]b) ) in exp_.  spaceVar_List:{} specifies Lists of Patterns that match variables of each space ({\!\(\*SubscriptBox[\(1\), \(a\)]\),A,B},{\!\(\*SubscriptBox[\(1\), \(b\)]\),a,b,Tensor[a|b,_,_]}). The first element of each space pattern List is its identity element(\!\(\*SubscriptBox[\(1\), \(n_\)]\)). The result is put in canonical order except for separated spaces that contain derivatives.  *21May2016*";
tuDotCircleTimesOrder[spaceVars_List:{},derivatives_:DerivOps][exp_]:=Module[{$,$0=exp,$1,$1a,$2,ops=dotOps,nspace=Length[spaceVars],$i,$j,pattern,$list
},
(*template for finding products*)
pattern=Apply[CircleTimes,Table[_,nspace]];
$0=$0/.toxDot;
$0=$0/.xDot[a__]:>Apply[xDot,{a}/.toDot]; xPrint[$0];
$list=$0//tuExtractPositionPattern[xDot[pattern..]];xPrint[$list];
$list=$list/.dd:xDot[__]:>Sort[dd]/;FreeQ[dd,derivatives];
$list=$list/.toDot;xPrint[$list];
tuReplacePart[$0,$list]
];

Clear[tuCircleTimesSeparateGroups];
tuCircleTimesSeparateGroups::usage="tuCircleTimesSeparateGroups[{spaceVar_List:{},derivatives:DerivOps}][exp_] separates product spaces (e.g. (a1.a2)\[CircleTimes]b) in exp_  into Dot product of product spaces divided by groups defined in spaceVars_List.  The grouping is defined by patterns of variables for each space involving only one of the spaces (a1.a[2].a3)\[CircleTimes]b\[Rule](a1.a[2])\[CircleTimes]b).(a3\[CircleTimes]b). spaceVar_List:{} specifies Lists of Patterns that match variable groups of each space ({\!\(\*SubscriptBox[\(1\), \(a\)]\),A,B},{\!\(\*SubscriptBox[\(1\), \(b\)]\),a.b,Tensor[a|b,_,_]}). Consecutive Dotted variables are grouped. Scalars are grouped an are put in first position of the separated n-space.  The first element of each spaceVar_List is its identity element(\!\(\*SubscriptBox[\(1\), \(n_\)]\)) and used when no vector element is available to hold the space position.  *21May2016*";
tuCircleTimesSeparateGroups[spaceVars_List:{},derivatives_:{DerivOps}][exp_]:=Module[{$,$0=exp,$1,$1a,$2,$2a,$2b,ops=dotOps,nspace=Length[spaceVars],$i,$j,$k,pattern,$list,$s,X,$test
},
(*template for finding products*)
pattern=Apply[CircleTimes,Table[_,nspace]];
$0=tuCircleTimesSeparate[spaceVars,derivatives][$0];xPrint["$0: ",$0];
$list=$0//tuExtractPositionPattern[pattern];xPrint["$list: ",$list];
(*identity array*)
$1s=Apply[CircleTimes,Map[#[[1]]&,spaceVars]];

For[$i=1,$i<=Length[$list],$i++,
$2={};
(*Locate and mark groups*)
 $=$list[[$i,2]];xPrint["$: ",$];
(***************************)
For[$j=1,$j<=nspace,$j++,
$s=spaceVars[[$j]];xPrint["$s: ",$s];
$1=$[[$j]];xPrint["$1a: ",$1];
If[$1===$s[[1]],Continue[]];
(*identify multiplicative scalar*)
$1=Apply[Dot,Map[If[!tuMemberQ[Head[#],dotOps],scal[#],#]&,Flatten[{$1/.Times->List}]]];
xPrint["$1: ",$1,":",Length[$s]];
(*Dot separate groups *)

xPrint["$1.1: ",$1,":",Length[$s]];
(*mark with X specified groups*)
For[$k=2,$k<=Length[$s],$k++,
$1=$1/.(ss: $s[[$k]]):>X[ss];
xPrint["{$1.2}: ",{$1}];
];
xPrint["$1.3:",$j,": ",$1=$1];
(*expand groups*)
$2=expand2CT[$j,$1s][$1];xPrint["$2: ",$2];
$list[[$i,2]]=$2;xPrint["$list: ",$i,":",$list];
]
(***************************)
];
tuReplacePart[$0,$list]
];

tuCirclePlus2Matrix::usage="tuCirclePlus2Matrix[exp_] converts CirclePlus expression exp_ into matrix expression where terms of the CirclePlus expresion are placed on the diagonals *24Jun2016*";
tuCirclePlus2Matrix[exp_]:=Module[{$=exp},
$=$//tuExtractPositionPattern[CirclePlus[__]];xPrint[$];
$=$/.CirclePlus[a__]:>xCirclePlus[Append[Map[ArrayPad[matrixLevel2[{{#}}],{0,1}]&,Most[{a}]],matrixLevel2[{{Last[{a}]}}]]];xPrint[$];
$=$/.xCirclePlus[a__]:>Fold[ArrayFlatten[ReplacePart[#1,{-1,-1}->#2]]&,First[a],Rest[a]];
$=tuReplacePart[exp,$];
$
];
matrixLevel2[exp_List]:=Module[{$=exp},
While[!MatrixQ[$],$=Flatten[$,1]];
$
];


expand2CT[ispace_Integer,ones_][exp_]:=Module[{$scal,$=exp,$1,$2={},$4={},$1s=ones},
$=If[Length[$]<2,xDot[$],$];xPrint["exp: ",$];
$scal=$//tuExtractPattern[scal[_]];xPrint["$scal: ",$scal];
$scal=Apply[Times,$scal]/.scal[a_]->a;
If[$scal=!=1,AppendTo[$2,$scal]];
$=Select[Apply[List,$],!MatchQ[#,scal[_]]&];
While[Length[$]>0,
{$1,$}={$[[1]],$[[2;;]]};
If[tuMemberQ[$1,{X[_]}],
If[Length[$4]>0,AppendTo[$2,Apply[xDot,$4]];$4={}];
AppendTo[$2,$1],
AppendTo[$4,$1]
]
];
If[Length[$4]>0,AppendTo[$2,Apply[xDot,$4]]];
$=Map[ReplacePart[$1s,ispace->#]&,$2]/.X[a__]->a/.toDot;
Apply[Dot,$]
];

(********
Trace (Tr) expansion Rules*)
tuTrExpand=tt:Tr[_]:>tuDistributeOp[Tr[_]][tt];
(**)
TrExpand:=tuTrExpand;

Clear[tuTrSimplify]
tuTrSimplify::usage="tuTrSimplify[scalars_List:{},product_:Times][exp_] simplifies Tr[] terms under product_ operation in exp_. Rules are applied to the terms Tr[product_[...]] accounting for Tr[] scalars_List. *16Jan2016*";
tuTrSimplify[scalars_List:{},product_:Times][exp_]:=Module[{$=exp,$s,scal,iproduct=Inactive[product]},
scal=Flatten[{scalars,Conjugate/@scalars}];
$=$/.product->iproduct;
$s={Tr[(pp:iproduct)[aa___,Tr[a_],b___]]->Tr[pp[aa,a,b]],
Tr[(pp:iproduct)[a___, c_^(n_:1),b___]]:>pp[c^n ,Tr[pp[a,b]]]/;(tuMemberQ[c,scal]||NumericQ[c]||Head[c]===Tr),
Tr[Tr[a_]]->Tr[a],
Tr[0]->0,
Tr[]->1,
tuTrExpand(* BUG: placement of this Rule matters.*)
}//Flatten;
Activate[$//.$s,product]
];
(**)
tuTrEvaluate::usage="tuTrEvaluate[matrixRule_List:{}][exp_] evalates Tr[] expressions in exp_ assuming that all elements of exp_ could be matrices as well.  An optional matrixRule_List is provided for substituting into exp_ before evaluation.  The action is to sum the Diagonal of the exp_ leaving each element of the diagonal as a possible Tr[] term as indicated by xTr[] *16Apr2016*";
tuTrEvaluate[matrixRule_List:{}][exp_]:=Module[{$=exp},
$=$/.Tr->xTr/.matrixRule;xPrint[$];
$=$/.xTr[a_]:>Thread[xTr[Diagonal[a]]];
$=$/.xTr[a_]:>Thread[xTr[a],Plus];
$=Apply[Plus,$];
$
];
(**)
tuTrCanonicalOrder::usage="tuTrCanonicalOrder[exp_Tr] Canonically orders Dot expression in exp_Tr[Dot[]]. EG: exp/.tt:Tr[a_]:>tuTrCanonicalOrder[tt] . *17Jun2015*";
tuTrCanonicalOrder[exp_Tr]:=Module[{$,$low,$range},
$low=$=exp[[1]]/.Dot->List;
$range=Range[Length[$]];
Do[
$=Permute[$,Cycles[{$range}]];xPrint[$range,$,$low,OrderedQ[{$,$low}]];
If[OrderedQ[{$,$low}],$low=$];
,
{Length[$]}
];
Tr[Apply[Dot,$low]]
];

(*Rules for simplifying expressions with metric tensor.*)
simpleMetric[g_]:={Tensor[g,{Void,$a_},{$b_,Void}]->Tensor[g,{$b,Void},{Void,$a}],
Tensor[g,{0,0},{Void,Void}]|Tensor[g,{Void,Void},{0,0}]->1,
Tensor[g,{a_,a_},{Void,Void}]|Tensor[g,{Void,Void},{a_,a_}]:>-1/;MemberQ[{1,2,3},a],
Tensor[g,{a_,b_},{Void,Void}]|Tensor[g,{Void,Void},{a_,b_}]:>0/;IntegerQ[a]&&IntegerQ[b]&&a=!=b,
Tensor[g,{a_,Void},{Void,a_}]|Tensor[g,{Void,a_},{a_,Void}]:>-2/;!IntegerQ[a]
};

(*******LeviCivita routines******)
tuLeviCivitaProduct::usage:="tuLeviCivitaProduct[dim_Integer,up_:ii,dn_:jj] produces a List of LeviCivita products summed over increasing number of indices from 0-to-dim_ indices in terms of Kronecker delta functions.  The index labels can be specified by up_ and dn_.  Ref: Wiki. *31Aug2018*";
tuLeviCivitaProduct[dim_Integer,up_:ii,dn_:jj]:=Module[{$,$1,$list,$i,$ii,n,$s\[Delta],i$,j$,$s1},

$s\[Delta]={T[\[Delta],"ud",{i_Integer,i_Integer}]->1,T[\[Delta],"ud",{i_Integer,j_Integer}]:>0/;i=!=j};
$s1=Sum[a_ T[\[Delta],"ud",{i,jd}]T[\[Delta],"ud",{ju,i}],{i,1}]->a T[\[Delta],"ud",{ju,jd}]-Sum[a T[\[Delta],"ud",{i,jd}]T[\[Delta],"ud",{ju,i}],{i,2,dim}]//tuAddPatternVariable[{ju,jd}];

$=Table[T[\[Delta],"ud",{Subscript[i$, i],Subscript[j$, j]}],{i,dim},{j,dim}];
$=Det[$];

$list[0]=$=(T[\[Epsilon],Table[Subscript[i$, i],{i,dim}],Table[Null,{i,dim}]]
T[\[Epsilon],Table[Null,{j,dim}],Table[Subscript[j$, j],{j,dim}]])->$;
For[n=1,n<=dim,n++,
$=$/.Subscript[j$, n]->Subscript[i$, n]/.Subscript[i$, n]->$ii;
$[[2]]=Sum[$[[2]],{$ii,dim}]/.$s\[Delta];
$=$/.$ii->Subscript[i$, n];
$=$/.$s1;
$list[n]=$;
];

Table[$list[i],{i,0,dim}]/.i$->up/.j$->dn
];


tuLeviCivitaExpand::usage="tuLeviCivitaExpand[index_List,dimension_List:{1,2,3,4}][exp_] Sum[]s LeviCivita terms in exp_ over index_List for dimension_List. *14Jun2017*";
tuLeviCivitaExpand[index_List,dimension_List:{1,2,3,4}][exp_]:=Module[{tmp=exp,rangelist,$test},
tmp=tmp//tuIndexSum[index,dimension];(*
rangelist={#,dimension}&/@index;
tmp=Fold[Sum,tmp,rangelist]; Does not discriminate between variables and indices.*)
(*0 for duplicate indices(Not needed due to Symmetry condition.)*)
tmp=tmp/.term:(Tensor[\[Epsilon],up_List,dn_List]):>0/;(($test=DeleteCases[ Join[up,dn],Void])=!=DeleteDuplicates[$test]);
tmp
];

tuLeviCivitaOrder::usage="tuLeviCivitaOrder[tensor_Tensor] canonically orders indices of tensor_Tensor with up-indices before the down-indices, (\!\(\*SuperscriptBox[\(\[Epsilon]\), \(abc\)]\)\!\(\*SubscriptBox[\()\), \(def\)]\). Returns 0 if two indices are identical.  *14Jun2017*";
tuLeviCivitaOrder[tensor_Tensor]:=Module[{tmp,tmps,u1,d1,u,d,xx,yy,tmpx,tmpy,$sign},
u1=tensor[[2]];
d1=tensor[[3]];
tmp=MapThread[DeleteCases[{xx[#1],yy[#2]},_[Void]]&,{u1,d1}];
tmp=tmp//Flatten;
tmps=Sort[tmp];
$sign=-Signature[tmp];
tmpy=tmps/.xx[_]->Void/.yy[a_]->a;
tmpx=tmps/.yy[_]->Void/.xx[a_]->a;
$sign Tensor[tensor[[1]],tmpx,tmpy]
];
(* TEST
$={d,a,b,c};
T[\[Epsilon],"uddu",$]//tuLeviCivitaOrder*)
Order\[Epsilon][tensor_Tensor]:=tuLeviCivitaOrder[tensor];
OrderAll\[Epsilon]={tt:Tensor[\[Epsilon],a_,b_]:>tuLeviCivitaOrder[tt]};
(*
*)tuLeviCivitaReduce2::usage="tuLeviCivitaReduce2[exp_] contracts pairs of LeviCivita \[Epsilon] Tensors in exp_.
Limitations: \[IndentingNewLine]Converts Tensor pairs into \[Delta]-form,\[IndentingNewLine]Only handles 2 \[Epsilon]'s at a time and the matching is not controlable,
	the \[Epsilon]-Tensor must be of equal dimension,\[IndentingNewLine]there is uncertainty over sign convention. 
*10Jan2019*";
tuLeviCivitaReduce2[exp_]:=Module[{tmp=exp,pos,up,dn,bad,i,pair,tmp1,tmp2,tmpd,u1,u2,d1,d2,$u1,$u2,$d1,$d2,ups,dns,E\[Epsilon]E,E\[Epsilon]Epat,EEterm,dummies,tindices,indices,n,m,\[Mu],\[Nu]},
E\[Epsilon]Epat=(EEterm:Tensor[\[Epsilon],$u1_List,$d1_List]Tensor[\[Epsilon],$u2_List,$d2_List]);
tmp=tmp/.E\[Epsilon]Epat:>E\[Epsilon]E[EEterm];
pos=tmp//tuExtractPositionPattern[E\[Epsilon]E[_]];
xPrint[pos];
For[i=1,i<=Length[pos],i++,(*Go through all \[Epsilon]-pair index contractions.*)
pair=pos[[i,2,1]];
{dummies,{up,dn},bad}=tuIndexParser[pair];
indices=pair/.E\[Epsilon]Epat->{$u1,$d1,$u2,$d2};
{u1,d1,u2,d2}=indices;

xPrint[indices," dummies ",dummies];

If[(n=Length[d1])==Length[d2],(* \[Epsilon]'s must be of equal dimension.*)
(*Build pair \[Delta]-template Wiki Levi-Civita symbol e[7]*)
m=Length[dummies]>0;
tmp1= Product[T[\[Delta],"du",{\[Mu][i],\[Nu][i]}],{i,n}];
tmp1=n! tmp1//tuSymmetrizeSymbol[-1,Table[\[Mu][i],{i,n}]];
(***)
xPrint[tmp1];
If[PeskinSchroederMode===1,tmp1=-tmp1];(*PeskinSchroeder sign differs from Wiki. *)
tmpd=DeleteCases[Flatten[indices],Void];
tmpd=Thread[Rule[Flatten[{Table[\[Mu][i],{i,n}],Table[\[Nu][i],{i,n}]}],tmpd]];
xPrint[tmpd];
tmp1=tmp1/.tmpd;
xPrint[tmp1," :: ",tmpd];
tmp1=tmp1//Expand//tuKroneckerDeltaEliminate[\[Delta],{a,b}];
xPrint[tmp1];
ups=DeleteCases[Join[u1,u2],Void];
dns=DeleteCases[Join[d1,d2],Void];
tmp1=tmp1//tuIndicesRaise[ups,ups]//tuIndicesLower[dns,dns];
];
pos[[i,2]]=tmp1;
];
tmp=tuReplacePart[tmp,pos];
tmp=tmp/.E\[Epsilon]E[a_]->a
];

(*
simple2\[Epsilon][exp_] default for 4-dim space*)
simple2\[Epsilon][exp_,4]:=tuLeviCivitaReduce2[exp]
simple2\[Epsilon][exp_]:=tuLeviCivitaReduce2[exp]
 
(*Relabels \[Epsilon]-matrix indices contained in product terms to indices \[Epsilon][1],\[Epsilon][2],... *)
Relabel\[Epsilon][exp_]:=Module[{tmp=exp,pos,ipos,tmpp,pos\[Delta],ipos\[Delta],indices,post},
tmp=Expand[tmp];
pos=tmp//tuExtractPositionPattern[Times[a___,Tensor[\[Epsilon],_,_],b___]];
For[ipos=1,ipos<=Length[pos],ipos++,
tmpp=pos[[ipos,2]];
pos\[Delta]=tmpp//tuExtractPositionPattern[Tensor[\[Epsilon],_,_]];
post=tmpp//tuExtractPositionPattern[Tensor[_,_,_]];
For[ipos\[Delta]=1,ipos\[Delta]<=Length[pos\[Delta]],ipos\[Delta]++,
indices=Apply[List,pos\[Delta][[ipos\[Delta],2]]][[2;;3]]//Flatten;
indices=DeleteCases[indices,Void];
;
indices=MapThread[{#1,#2}&,{indices,Array[\[Epsilon],Length[indices]]}];
post=post//IndexChangeTU[indices];
tmpp=ReplacePart[tmpp,post];
];
pos[[ipos,2]]=tmpp;
];
tmp=ReplacePart[tmp,pos]
];

(*Expands and changes each term in expression so that all \[Epsilon] indices are in down position.  May not handle summing over 2 \[Epsilon] tensors.*)
All\[Epsilon]Down[exp_]:=Module[{tmp=exp,pos,ipos,tmpp,pos\[Epsilon],ipos\[Epsilon],indices},
tmp=Expand[tmp];
(*Times terms with \[Epsilon]*)
pos=tmp//tuExtractPositionPattern[Times[a___,Tensor[\[Epsilon],_,_],b___]];
For[ipos=1,ipos<=Length[pos],ipos++,
tmpp=pos[[ipos,2]];
pos\[Epsilon]=tmpp//tuExtractPositionPattern[Tensor[\[Epsilon],_,_]];
For[ipos\[Epsilon]=1,ipos\[Epsilon]<=Length[pos\[Epsilon]],ipos\[Epsilon]++,
indices=pos\[Epsilon][[ipos\[Epsilon]]]  [[2,2]];
indices=DeleteCases[indices,Void];
tmpp=tmpp//SwapUpDownIndices[indices];
];
pos[[ipos,2]]=tmpp;
];
tmp=ReplacePart[tmp,pos]
];

tuLeviCivitaSimplify::usage="tuLeviCivitaSimplify[dimension_Integer][exp_] simplifies exp_ with dimension_-space LeviCivita Tensor[]s by zeroing terms with duplicate indices, expanding \[Epsilon] Tensor products into \[Delta]'s which are simple2\[Epsilon]'d, tests for sum\[Rule]0 of the EinsteinSum[] of LeviCivita terms (terms are zeroed if so.). *24Jul2013*";
tuLeviCivitaSimplify[dimension_Integer][exp_]:=Module[{tmp,up,dn,rest,pos,tensors,test},
(*0 for duplicate indices(Not needed due to Symmetry.)*)
tmp=exp/.term:(Tensor[\[Epsilon],up_List,dn_List]):>0/;((test=DeleteCases[ Join[up,dn],Void])=!=DeleteDuplicates[test]);
(*Assign numeric indices. *)
tmp=tmp/.ee:Tensor[\[Epsilon],up_List,dn_List]:>numericLeviCivita[{-1,1,1,1,1,1,1}][ee];
(*Simplify \[Epsilon] Tensor pairs.*)
tmp=Expand[tmp]//simple2\[Epsilon][#,dimension]&//Expand;
(*raise all dummy indices in \[Epsilon]-Tensor.) *)
tmp=tmp/.term:HoldPattern[Times[a__]]:>raiseLeviCivitaDummyIndices[term];
tmp
];
simplifyLeviCivita[dimension_Integer][exp_]:=tuLeviCivitaSimplify[dimension][exp];

(*
numericLeviCivita[metric_List][exp_Tensor]computes the numerical value of Levi-Civita tensor with all numeric indices.  metric_List are the values of the diagonal for the metric tensor referenced by {up|dn}->{0,1,...}. 
exp_Tensor is the Levi-Civita Tensor. *24July2013*)
numericLeviCivita[metric_List][exp_Tensor]:=Module[{tmp=exp,sym,up,dn,indices,allnumeric},
{sym,up,dn}=Apply[List,tmp];
indices=(up+dn)/.Void->0;
allnumeric=!MemberQ[(NumericQ/@indices),False];
If[allnumeric&&Max[indices]<Length[metric],(*Test indicies to see if they are within range of dimension. There is confusion with meaning of \[Epsilon][0,3,2], apply same algorithm. But it is a PROBLEM since there are cases where \[Epsilon] is used with fewer indices then there are dimensions. Maybe we should pass the metric signature.*)
(*Apply metric factors for Raising index. The first index is always 0 for the time.*)
tmp=Map[metric[[#+1]]&,DeleteCases[dn,Void]];
tmp=Apply[Times,Append[tmp,1]];
tmp=tmp Signature[indices];
];
tmp
];(*TESTS
{\[Epsilon]@dd[3,2],\[Epsilon]@ddd[1,2,3],\[Epsilon]@uuu[1,2,3]}
simplifyLeviCivita[4]/@%*);

(*
raiseLeviCivitaDummyIndices[term_Times|Dot|xDot] raises all indices of LeviCivita Tensor in term_Times|Dot|xDot.  *15Oct2012*)
raiseLeviCivitaDummyIndices[term_?MemberQ[Flatten[{Times,dotOps}],#]&]:=Module[{tmp=term,i,LCs,LCdn,dummies,dnup},
dummies=tuIndexParser[tmp][[1]];
LCs=tmp//tuExtractPositionPattern[Tensor[\[Epsilon],up_List,dn_List]];
For[i=1,i<=1(*May want to extend to all \[Epsilon]-Tensors where the last one encountered is dominant.*),i++,
LCdn=tuIndexParser[LCs[[i,2]]][[2,2]];
dnup=Intersection[LCdn,dummies];
tmp=UpDownIndexSwap[dnup][tmp];
];
tmp
];
(*
antisymmetrizeLeviCivitaCoef[term_] antisymmetrizes over dummy indices the coefficient of the first LeviCivita tensor.  Symmetric coefficients are zero. UNTESTED *16Oct2012*)
antisymmetrizeLeviCivitaCoef[term_Times]:=Module[{dum,LCs,LCind,antiInd,tmp1,tmp2,i},
dum=tuIndexParser[term][[1]];
LCs=term//tuExtractPositionPattern[Tensor[\[Epsilon],up_List,dn_List]];
tmp1=term;tmp2=1;
For[i=1,i<=1(*Length[LCs] complicated if there more than one such Tensor.*),i++,
LCind=tuIndexParser[LCs[[i,2]]][[2]]//Flatten;
antiInd=Intersection[LCind,dum];
tmp2*=LCs[[i,2]](Delete[tmp1,LCs[[i,1]]]//AntiSymmetrizeIndices[antiInd])
];
{dum,LCs,LCind,antiInd,tmp2};
tmp2
];
(*
symmetricCoefQ[term_] determines if the coefficients of LeviCivitaTensor are symmetric over dummy sum indices. UNTESTED *16Oct2012*)
symmetricCoefQ[term_Times]:=Module[{dum,LCs,LCind,antiInd,tmp1,tmp2,i},
dum=tuIndexParser[term][[1]];
LCs=term//tuExtractPositionPattern[Tensor[\[Epsilon],up_List,dn_List]];
tmp1=term;tmp2=1;
For[i=1,i<=Length[LCs],i++,
LCind=tuIndexParser[LCs[[i,2]]][[2]]//Flatten;
antiInd=Intersection[LCind,dum];
tmp2*=(Delete[tmp1,LCs[[i,1]]]//AntiSymmetrizeIndices[antiInd])
];
{dum,LCs,LCind,antiInd,tmp2};
tmp2==0
];

(*Returns a {exp_, Down index version of exp_ of indices_List} *)
WithIndexDown[indices_List][exp_]:=Module[{tmp},
{exp,Fold[LowerIndex[#2,#2][#1]&,exp,indices]}//Flatten
];

tuIndexChange::usage="tuIndexChange[pairs_List][exp_] replaces indices in exp_ specified in pairs_List which is of form {{a,b},{c,d}}. In this case a\[Rule]b,c\[Rule]d. This routine can handle indices used in DerivOps. *5Sep2015*";
tuIndexChange[pairs_List][exp_]:=Module[{pos,rules,ipos,indices},
rules=Map[Apply[Rule,#]&,Partition[Flatten[{pairs}],2]];
pos=exp//tuExtractPositionPattern[Tensor[_,_,_]|Map[#[_,_]&,DerivOps]];
For[ipos=1,ipos<=Length[pos],ipos++,
indices=tuIndexParser[pos[[ipos]]]//Flatten;
pos[[ipos]]=pos[[ipos]]//.tuRuleSelect[rules][indices];
];
tuReplacePart[exp,pos]
];
IndexChangeTU[pairs_List][exp_]:=tuIndexChange[pairs][exp];(*Compatibility*)

(*
UpDownSymmetrize[index_][exp_] symmetrizes UpDn index_ in exp_ *11Apr2014*)
UpDownSymmetrize[index_][exp_]:=Module[{tmp1,tmp2,symSub},
symSub[term_]:=Module[{},(term+UpDownIndexSwap[index][term])/2];
tmp1=exp//Expand;
tmp1=Map[symSub[#]&,tmp1]
];

(* Simplifies \[Delta]uu,\[Delta]ud,\[Delta]du,\[Delta]dd and contractions into standard form.  Does not care about Einstein notation. Usage: exp_//.simple\[Delta][dim_]  *)
simple\[Delta][\[Delta]_][exp_]:=Module[{tmp=exp},
tmp=tmp//KroneckerAbsorb[\[Delta]];(* This only works with UpDown \[Delta]'s *)
tmp=tmp//.{
\[Delta]@uu[a_,b_]:>\[Delta]@uu[b,a]/;OrderedQ[b,a],
\[Delta]@dd[a_,b_]:>\[Delta]@dd[b,a]/;OrderedQ[b,a],
\[Delta]@du[a_,b_]:>\[Delta]@ud[b,a]/;OrderedQ[b,a],
(*Following not recognized by KroneckerAbsorb[\[Delta]] *)
\[Delta]@uu[a_,b_]\[Delta]@dd[a_,c_]:>\[Delta]@ud[b,c],(* Einstein sums *)
\[Delta]@uu[a_,b_]\[Delta]@dd[c_,a_]:>\[Delta]@ud[b,c],
\[Delta]@uu[b_,a_]\[Delta]@dd[a_,c_]:>\[Delta]@ud[b,c],
\[Delta]@uu[b_,a_]\[Delta]@dd[c_,a_]:>\[Delta]@ud[b,c],
Tensor[\[Delta],a_List,b_List]:>Length[GetBaseIndices[First[DeleteCases[Join[a,b],Void]]]]/;Apply[Equal,DeleteCases[Join[a,b],Void]]
};
tmp
];

(*Contracts \[Delta] (KroneckerDelta) indices with other expression indices. Does not respect Einstein up/down notation. KroneckerContract works better although needs up-down convention. *)
Contract\[Delta][exp_]:=Module[{tmp=exp,pos,ipos,tmpp,pos\[Delta],ipos\[Delta],indices,post,testindices},
tmp=Expand[tmp];
pos=tmp//tuExtractPositionPattern[Times[a___,Tensor[\[Delta],_,_],b___]];
List[pos];
For[ipos=1,ipos<=Length[pos],ipos++,
tmpp=pos[[ipos,2]];
pos\[Delta]=tmpp//tuExtractPositionPattern[Tensor[\[Delta],_,_]];
List[pos\[Delta]];
tmpp=tmpp/.Tensor[\[Delta],_,_]->1;
post=tmpp//tuExtractPositionPattern[Tensor[_,_,_]];
For[ipos\[Delta]=1,ipos\[Delta]<=Length[pos\[Delta]],ipos\[Delta]++,
indices=Apply[List,pos\[Delta][[ipos\[Delta],2]]][[2;;3]]//Flatten;
indices=DeleteCases[indices,Void];
(*Check if indices match to see if \[Delta] is consumed.*)
testindices=ParseTermIndices[tmpp][[2]]//Flatten;
If[MemberQ[testindices,First[indices]],
post=post//IndexChangeTU[{indices}];
tmpp=ReplacePart[tmpp,post],
tmpp=tmpp pos\[Delta][[ipos\[Delta],2]]
];
];
pos[[ipos,2]]=tmpp;
];
tmp=ReplacePart[tmp,pos]
];

(*Rules for expanding Einstein indices in Dot'd expression.  Handles xPartialD[]'s and Uses \[Eta]dd[] as coefficients in sum and preference for results with lower indices.*)
DotSumExpand[range_List]:={Tensor[a_,b_,c_].xPartialD[d_,e_]:>Sum[Tensor[a,b,c].xPartialD[d,e]/.e->j,{j,range}]/;MemberQ[b,e],

xPartialD[d_,e_].Tensor[a_,b_,c_]:>Sum[xPartialD[d,e].Tensor[a,b,c]/.e->j,{j,range}]/;MemberQ[b,e],

xPartialD[a_,b_].xPartialDu[d_,b_]:>Sum[xPartialD[a,b].xPartialDu[d,b]/.b->j,{j,range}],

xPartialDu[a_,b_].xPartialD[d_,b_]:>Sum[xPartialDu[a,b].xPartialD[d,b]/.b->j,{j,range}]
(* NOT FINISHED
Tensor[a_,b_,c_].Tensor[d_,e_,f_]\[RuleDelayed]Sum[\[Eta]uu[e,e]Tensor[a,b,c].Tensor[d,e,f]/.e\[Rule]j,{j,range}//Flatten]/;MemberQ[b,e](*FIND mutual index*)
*)
};

(*Rules for expanding Einstein indices in Dot'd expression.  Handles xPartialDu[]'s and uses \[Eta]dd[] to convert from xPartialDu->xPartialD *)
DotSumExpand\[Eta][range_List]:={
Tensor[a_,b_,c_].xPartialD[d_,e_]:>Sum[Tensor[a,b,c].xPartialD[d,e]/.e->j,{j,range}]/;MemberQ[b,e],

Tensor[a_,b_,c_].xPartialDu[d_,e_]:>Sum[Tensor[a,b,c].xPartialD[d,e]\[Eta]uu[e,e]/.e->j,{j,range}]/;MemberQ[c,e],

xPartialD[d_,e_].Tensor[a_,b_,c_]:>Sum[xPartialD[d,e].Tensor[a,b,c]/.e->j,{j,range}]/;MemberQ[b,e],

xPartialDu[d_,e_].Tensor[a_,b_,c_]:>Sum[xPartialD[d,e].Tensor[a,b,c]\[Eta]uu[e,e]/.e->j,{j,range}]/;MemberQ[b,e],

xPartialD[a_,b_].xPartialDu[d_,b_]:>Sum[xPartialD[a,b].xPartialD[d,b]\[Eta]uu[b,b]/.b->j,{j,range}],

xPartialDu[a_,b_].xPartialD[d_,b_]:>Sum[xPartialD[a,b].xPartialD[d,b]\[Eta]uu[b,b]/.b->j,{j,range}]
(* NOT FINISHED
Tensor[a_,b_,c_].Tensor[d_,e_,f_]\[RuleDelayed]Sum[\[Eta]uu[e,e]Tensor[a,b,c].Tensor[d,e,f]/.e\[Rule]j,{j,range}//Flatten]/;MemberQ[b,e](*FIND mutual index*)
*)
};

(*DotIndexSum[exp_,range_List] sums indices over range_list in Dot[] expressions in exp_.  This routine removes difficiences in NewIndexChangePatterns and EinsteinSum[].  Replaces DotSumExpand[] *)
DotIndexSum[exp_,range_List]:=Module[{exp0=exp,tmp,onetime,list,dlist,ilist,i,DEBUG=0,mname="DotIndexSum"},
exp0=exp/.Dot->xDot;(* Next line does not work with Dot[], needs xDot[] *)
list=exp0//tuExtractPositionPattern[xDot[__]];
IfDEBUG[mname,DEBUG>0,{list,Length[list],onetime},"list"];
For[i=1,i<=Length[list],i++,
dlist=list[[i,2]]/.xDot->Dot;
IfDEBUG[mname,DEBUG>0,{dlist},"dlist"];
ilist=ParseTermIndices[dlist]//First;
dlist=dlist//EinsteinSum[range];
IfDEBUG[mname,DEBUG>0,{ilist,dlist},"ilist,dlist"];
dlist=dlist/.xPartialD[a_,b_].s___.xPartialDu[d_,b_]:>Sum[xPartialD[a,b].s.xPartialDu[d,b]/.b->j,{j,range}]/;MemberQ[ilist,b];
dlist=dlist/.xPartialDu[a_,b_].s___.xPartialD[d_,b_]:>Sum[xPartialD[a,b].s.xPartialDu[d,b]/.b->j,{j,range}//Flatten]/;MemberQ[ilist,b];
list[[i,2]]=dlist;
IfDEBUG[mname,DEBUG>0,{list},"list"];
];
If[Head[exp0]===xDot,list[[1,2]],
ReplacePart[exp0,list]]
];

DotIndexSum[range_List][exp_]:=DotIndexSum[exp,range]

(*Computes Euler-Lagrange equation for single field (field_)given Lagrangian_ and indices,  t_ {0,1,2,3}.  Uses \[Eta]uu[] for summing over indices t_.  Returns Euler-Lagrange equation \[Rule] 0 *)EulerLagrange[Lagrangian_,field_,t_List]:=Module[{tmp,tL,tEL,tEL0,tEL1,\[Mu],i,j,out,dfield,DEBUG=0,mname="EulerLagrange"},
tL=Lagrangian/.DotSumExpand\[Eta][t];
IfDEBUG[mname,DEBUG>0,{tL},"{tL}"];
dfield=xPartialD[field,\[Mu]];
tEL=xPartialD[xPartialD[tL,xPartialD[field,\[Mu]]],\[Mu]]-xPartialD[tL,field];
tEL0=xPartialD[tL,field];
tEL0=tEL0/.xPartialD[a_,b_]:>D[a,b];
tEL1=xPartialD[tL,dfield];
tEL1=xPartialD[tEL1,\[Mu]];
IfDEBUG[mname,DEBUG>0,{j,t,tEL1},"{j,t,tEL1}"];
tEL1=Sum[tEL1/.\[Mu]->j,{j,t}  ];
IfDEBUG[mname,DEBUG>0,{tEL1},"{tEL1}"];
For[i=1,i<=Length[t],i++,tEL1=tEL1/.xPartialD[a_,dfield/.\[Mu]->t[[i]]]:>D[a,dfield/.\[Mu]->t[[i]]]
];
out=tEL1-tEL0/.Derivative[__][_][__]->0//.xPartialDExpand[{\[Gamma]@u[_],\[Gamma][_]}]//.simpleDot;
out->0
];

(**)
tuBraKetSwap::usage="tuBraKetSwap[exp_] convert Ket[] expressions into Bra[]'s and visa-versa by the ConjugateTranspose operator. *26Mar2017*";
tuBraKetSwap[exp_]:=Module[{$=exp,reals={},scalars={},hermitean={},ct=ConjugateTranspose,cc=Conjugate},
$=ct[$]//tuConjugateTransposeExpand;
(*Convert ct[Ket|Bra[]s] generated above*)
$=$//.ct[Ket[a__]]:> Bra[a]//.ct[Bra[a__]]:> Ket[a]
];
(**)
tuBraKetSimplify::usage="tuBraKetSimplify[scalars_List] are Rules that simplify BraKet[] expressions.  Extracts scalars_ and NumericQ[] *20Feb2015*";
tuBraKetSimplify[ scalars_List:{}]:={
(bb:BraKet|Bra|Ket)[a_+b_]->bb[a]+bb[b],
(bb:BraKet|Bra|Ket)[a_ b_]:>a bb[b]/;NumericQ[a]||ListMemberQ[a,Flatten[{scalars,scalars^_}]],
(bb:BraKet|Bra|Ket)[a_ ]:>a /;NumericQ[a]||ListMemberQ[a,Flatten[{scalars,scalars^_}]],
(**)
(bb:BraKet|Bra|Ket)[q1_,a_+q2_]:>bb[q1,a]+bb[q1,q2],
(bb:BraKet|Bra|Ket)[a_+q1_,q2_]:>bb[a,q2]+bb[q1,q2],
(bb:BraKet|Bra|Ket)[q1_,a_  q2_]:>a bb[q1,q2]/;NumericQ[a]||ListMemberQ[a,Flatten[{scalars,scalars^_}]],
(bb:BraKet|Bra|Ket)[a_ q1_,  q2_]:>a bb[q1,q2]/;NumericQ[a]||ListMemberQ[a,Flatten[{scalars,scalars^_}]],
(**)
(bb:BraKet|Bra|Ket)[q1_,a_+b_,q2_]->bb[q1,a,q2]+bb[q1,b,q2],
(bb:BraKet|Bra|Ket)[q1_,a_ b_,q2_]:>a bb[q1,b,q2]/;NumericQ[a]||ListMemberQ[a,Flatten[{scalars,scalars^_}]],
(bb:BraKet|Bra|Ket)[q1_, b_/a_,q2_]:>bb[q1,b,q2]/a/;NumericQ[a]||ListMemberQ[a,Flatten[{scalars,scalars^_}]],
(bb:BraKet|Bra|Ket)[q1_,a_,q2_ ]:>a bb[q1,q2] /;NumericQ[a]||ListMemberQ[a,Flatten[{scalars,scalars^_}]],
(*Bra[] . A . Ket[] expressions*)
(dd:dotOps)[Bra[a_],(b_+c_) ,Ket[d_]]->dd[Bra[a],b,Ket[d]]+d[Bra[a],c,Ket[d]],
(dd:dotOps)[Bra[a_] , (b_  c_) ,Ket[d_]]:>b dd[ Bra[a] , c , Ket[d]]/;NumericQ[b]||ListMemberQ[b,Flatten[{scalars,scalars^_}]],
(dd:dotOps)[Bra[a_],( c_/b_) , Ket[d_]]:> dd[Bra[a] , c ,Ket[d]]/b/;NumericQ[b]||ListMemberQ[b,Flatten[{scalars,scalars^_}]],
(dd:dotOps)[Bra[a_], b_, Ket[d_]]:>b dd[Bra[a],Ket[d]]/;NumericQ[b]||ListMemberQ[b,Flatten[{scalars,scalars^_}]],
(dd:dotOps)[Bra[a_],(1/b_) ,Ket[d_]]:>dd[Bra[a],Ket[d]]/b/;NumericQ[b]||ListMemberQ[b,Flatten[{scalars,scalars^_}]]
};
simpleBraKet[ scalars_List:{}]:=tuBraKetSimplify[scalars];
(*
Generates a list of Clifford algebra basis in Wedge form
assuming basis ed[i] for vector space V of dimension d.*)
WedgeClifBasis[d_]:=Module[{tmp},
tmp=Subsets[Map[ed[#]&,Table[i,{i,1,d}]]];
tmp=\[ScriptCapitalC]\[ScriptL][V[d],Q]->Map[If[Length[#]>1,Apply[Wedge,Sequence[#]],
If[Length[#]==1,#//First,Id[d]]
]&,tmp]
];
(*Wedge Attributes *)
SetAttributes[Wedge,Attributes[Dot]];
(*TEST removed Attributes to be compatible with diffgeo.m*)

(**)
Clear[tuWedgeSimplify];
tuWedgeSimplify::usage="tuWedgeSimplify[scalar_List:{},product_:Times|dotOps,order_:NotOrdered][exp_] removes term in scalar_List from Wedge expressions in exp_. The scalar terms are product_ed together with the simplified Wedge expression. In the event that there is an isolated scalar in a Wedge expression it will be brought out of the expression. order_ \[Rule]Ordered canonically orders the Wedge[](for 1-forms only).  NOTE: The routine does not assume asymmetry of Wedge arguements. Inverse of scalars must be specified explicitly. *3Feb2016,22July2017*9May2018**5July2018*";
tuWedgeSimplify[scalar_List:{},productOp_:Flatten[Times|dotOps],order_:NotOrdered][exp_]:=Module[{$,$tmp},
SetAttributes[Wedge,Attributes[Dot]];
SetAttributes[xWedge,Attributes[Dot]];
$=exp;
While[$tmp=!=$,
$tmp=$;
$=$//tuOpDistributeF[Wedge|xWedge];
(*remove scalars*)
$=$//.{(ww:Wedge|xWedge)[ a___,((op:productOp)[b1___,c1_^(n_:1),b___]),f___]:>op[c1^n, ww[a,b1,b,f]]/;tuMemberQ[c1,scalar]||NumericQ[c1],
(ww:Wedge|xWedge)[ a___,c1_^(n_:1),f___]:>c1^n ww[a,f]/;tuMemberQ[c1,scalar]||NumericQ[c1]};

$=$//.(ww:Wedge|xWedge)[a__]:>0/;Length[{a}]=!=Length[DeleteDuplicates[{a}]];
$=$//.ww:(Wedge|xWedge)[a_]:>a/;Length[ww]==1;
(*removes Wedge of single arguement*)
If[order === Ordered,(*For 1-forms only*)
$=$/.(ww:Wedge|xWedge)[a__]:>Signature[{a}]ww[Apply[Sequence,Sort[{a}]]]];
];(* **Taken care by Attributes**
ClearAttributes[Wedge,Flat];
ClearAttributes[xWedge,Flat];
$=$//.(ww:Wedge|xWedge)[a_]\[RuleDelayed]a/;Length[ww]\[Equal]1;*)
$
];(*
TEST
Wedge[a,b+c,d c]//tuWedgeSimplify[{c}]*)


(*
Simplifies Wedge expressions leaving Wedge arguement in canonical order *16July2012*)
SimpleWedge[exp_]:=Module[{tmp=exp,tmp0},
SetAttributes[Wedge,Attributes[Dot]];
While[tmp0=!=tmp,
tmp0=tmp;
tmp=tmp/.Wedge[a__]:>Signature[{a}]Wedge[Apply[Sequence,Sort[{a}]]]/;Length[Wedge[a]]>1;(*canonical ordering*)
(*remove Wedge of single variable*)
tmp=tmp/.Wedge[a_]:>a/;MemberQ[{Symbol,Tensor},Head[a]];
tmp=tmp/.ww:Wedge[a_]:>a/;Length[ww]==1;
];
ClearAttributes[Wedge,Flat];
tmp
];
(*
ExpandWedge[scalar_List][exp_] expands Wedge product exp_ accounting for scalar_List.  *16July2012*)
WedgeSimplify[scalar_List:{}][exp_]:=Module[{tmp=exp,sub,tmp0,xtmp},
SetAttributes[Wedge,Attributes[Dot]];
While[tmp0=!=tmp,
tmp0=tmp;
tmp=tmp/.Wedge[a__]:>ExpandWedge[Wedge[a]];
tmp=tmp/.Wedge[c1___,a_,c2___,a_,c3___]:>0/;MemberQ[scalar,a];
(*move scalars out of Wedge[]*)
tmp=tmp//.Wedge[ a___,c1_  b_,f___]:>c1 Wedge[a,b,f]/;ListMemberQ[c1,scalar]||NumberQ[c1];
tmp=tmp//.Wedge[a___,c1_  ,b___]:>c1 Wedge[a  ,b]/;ListMemberQ[c1,scalar]||NumberQ[c1];
tmp=tmp//SimpleWedge;
];
ClearAttributes[Wedge,Flat];
tmp//ExpandAll
];
(*
ExpandWedge from ExpandNCM example. Not needed with SetAttributes above. *16July2012*)
ExpandWedge[(h:Wedge)[a___,b_Plus,c___]]:=Distribute[h[a,b,c],Plus,h,Plus,ExpandWedge[h[##]]&];
ExpandWedge[a_]:=ExpandAll[a];
(*
ExteriorDContract[scalars_List,constants_List][exp_] contracts ExteriorD[a_]PartialD[l_][b_,a_] \[Rule] ExteriorD[b] *16July2012*)
Clear[ExteriorDContract];
ExteriorDContract[exp_]:=exp//.HoldPattern [ExteriorD[a_]PartialD[l_][b_,a_]]->ExteriorD[b];
ExteriorDContract[scalars_List,constants_List][exp_]:=Module[{tmp=exp,tmp0,xtmp},
While[tmp0=!=tmp,
tmp0=tmp;
tmp=WedgeSimplify[Join[scalars,constants]][tmp];(*Expand Wedge ExteriorD[exp_]*)
tmp=tmp//ExteriorDContract;(*Contracts PartialD ExteriorD expressions *)
tmp=tmp//.ExteriorD[c1_ a__]:>Wedge[ExteriorD[c1],a]+c1 Wedge[a]/;ListMemberQ[c1,scalars];
tmp=tmp/.ExteriorD[a_]:>0/;ListMemberQ[a,constants];
];
tmp
];
(*
ExpandExteriorD0[scalars_List,constants_List][exp_] expands ExteriorD[] in exp_ based upon scalars_List,constants_List.  Overlaps with ExpandExteriorD. *17July2012*)
ExpandExteriorD0[scalars_List,constants_List][exp_]:=Module[{tmp=exp,tmp0,d=ExteriorD,xtmp},
While[tmp0=!=tmp,
tmp0=tmp;
tmp=tmp//WedgeSimplify[Join[scalars,constants]];
tmp=tmp/.d[a_  b__]:>Wedge[d[a],b]+Wedge[a, d[Times[b]]];
tmp=tmp/.d[d[a__ ]]->0;
tmp=tmp/.d[a_]:>0/;ListMemberQ[a,constants];
tmp=tmp/.d[Wedge[a_,b__]]:>Wedge[d[a],b]-Wedge[a,d[Wedge[b]]];
];
tmp
];
(*******)
(*
dDifForm[scalars_List,constants_List][exp_] computes the exterior derivative of exp_ accounting for scalars_List and constants_List.  *27Mar2013*)
dDifForm[scalars_List,constants_List][exp_]:=Module[{tmp=difForm[exp],tmp0},
While[tmp0=!=tmp,
tmp0=tmp;
tmp=WedgeSimplify[Join[scalars,constants]][tmp];
tmp=tmp//.difForm[a_ b__]:>Wedge[difForm[a],b]/;ListMemberQ[a,scalars];
tmp=tmp//.difForm[difForm[a__ ]]->0;
tmp=tmp//\[Delta]Expand[difForm,constants];
tmp=tmp//.difForm[a_]:>0/;ListMemberQ[a,constants];
tmp=tmp//.difForm[Wedge[a_,b__]]:>Wedge[difForm[a],b]+(-1)^Length[{a}]Wedge[a,difForm[Wedge[b]]];(*INCORRECT*)
tmp=tmp/.difForm[Wedge[a_]]->Wedge[difForm[a]];
];
tmp
];

(* stdDifForm may replace the need for this routine.
dDifFormX[constants_List,scalars_List,forms_List
][exp_] expands difForm[] where constants_List,scalars_List,forms_List are specified.  
forms_List are as {{a,na},{b,nb}}} where na,nb are n-form values for a,b.  
Restrictions: a_ must not have Times[] operations only have ProductOp=Dot|xDot|Wedge.
Usage: exp_//.difForm[a_]:>dDifFormX[constants_List,scalars_List,forms_List][a]
*31July2014*)
dDifFormX[constants_List,scalars_List,forms_List
][exp_]:=Module[{tmp,tmp0,pos,xdForm,dForms,ProductOp=Dot|xDot|CenterDot|Times,xtmp},
tmp=stdDifForm[constants,scalars,forms][exp];
xPrint["exp_:",tmp];
tmp=tmp//.(op:ProductOp)->Wedge;(**)
tmp=tmp/.Map[#[[1]]->dForm[#[[1]],#[[2]]]&,forms];
tmp=tmp/.dd:difForm[a_]:>dForm[a,1]/;ListMemberQ[a,scalars];xPrint["B:",tmp];
tmp=SimplexWedge[constants,scalars,forms][tmp];
xPrint["C:",tmp];
(*Apply difForm*)
tmp=difForm[tmp];
tmp=tmp//\[Delta]Expand[difForm];
tmp=tmp/.(op:ProductOp)->Wedge;
tmp=SimplexWedge[constants,scalars,forms][tmp];
xPrint["E:",tmp];
While[tmp0=!=tmp,tmp0=tmp;
tmp=tmp/.df:difForm[a_]:>Distribute[df];
tmp=tmp/.Wedge->xWedge//.difForm[xWedge[a_,b__]]:>xWedge[difForm[a],b]+(-1)^nForm[a]xWedge[a,difForm[xWedge[b]]]/.xWedge->Wedge;
xPrint["F:",tmp];
tmp=SimplexWedge[constants,scalars,forms][tmp];
xReturn[tmp];
];
xPrint["G:",tmp];(*
tmp=tmp//stdDifForm[constants,scalars,forms];*)
tmp=SimplexWedge[constants,scalars,forms][tmp];
xPrint["H:",tmp];
tmp
];
tuDifFormWedgeSimplify::usage="tuDifFormWedgeSimplify[constants_List,scalars_List,forms_List][EXP_] simplifies Wedge, dForm, difForm expressions in EXP_.  Converts ProductOp[] into Wedge[]. The scalars/forms differences be sorted out from scalar_List. Return an expression that is { not Distributable in Wedge[], constants_List and scalars_List to the left of each term,\[IndentingNewLine]no Times[] terms}.  EXP_ can have a mix of DF's. All forms are specified by DF's. Used in dDifFormX[]. *31Jul2014";
SimplexWedge:=tuDifFormWedgeSimplify;
tuDifFormWedgeSimplify[constants_List,scalars_List,forms_List][EXP_]:=Module[{tmp=EXP ,tmp0,DF={dForm,difForm},formLabels=Map[#[[1]]&,forms],loop=0,ProductOp=Flatten[dotOps|Times|xWedge],a
},
tmp=tmp//.tuOpSimplify[dotOps];
(*all Products to xWedges. *)
tmp=tmp/.ProductOp->Wedge//.Wedge->xWedge;(*
xPrint["Is1:",tmp];*)
(*move non-Form to the left==default position*)(*
xPrint["FF:",formLabels];*)
While[tmp0=!=tmp,
If[loop++>20,Print["loop limit:",tmp];Return[tmp]];
tmp0=tmp;(*
xPrint["Is:",tmp];*)
(*Move constants to Left*)
tmp=tmp//.xWedge[c0___,a_ , b_,c1___ ]:>xWedge[c0,b,a,c1]/;tuHasNoneQ[b,{DF,formLabels}]&&tuHasAnyQ[a,{DF,formLabels}];(*
xPrint["Hs:",tmp];*)
tmp=tmp//.ww:xWedge[a_]:>a/;Length[ww]==1;(*avoid Wedge Pattern match problem*)
tmp=tmp/.xWedge[c1___,df:difForm[a_]|dForm[a_,1],c2___,df:difForm[a_]|dForm[a_,1],c3___]:>0/;df===dForm[a,1];(*
xPrint["Js:",tmp];*)
(*Simplification of difForm[] expressions*)
tmp=tmp/.df:difForm[a_]:>Distribute[df];
tmp=tmp//tuWedgeSimplify[];
(*
xPrint["Ks:",tmp];*)
tmp=tmp//tudExpand[difForm];(*PROBLEM HERE*)(*
xPrint["Ks0:",tmp];*)
tmp=tmp//tuWedgeSimplify[];(*
xPrint["Ks0a:",tmp];*)
tmp=tmp//.ww:xWedge[a__]:>0/;tuHasAnyQ[ww,{0}];
(*Distribute DerivOps*)
tmp=tmp//.(op:DerivOps )[xWedge[a_, c__],b_]->xWedge[op[a,b],c]+ xWedge[a,op[ xWedge[c],b]];
tmp=tmp//.dd:DerivOps [a_,b_]:>tuDerivativeExpand[constants][dd]/;tuHasNoneQ[a,{DF,formLabels}];
tmp=tmp/.difForm[a_]|dForm[a_,1]:>0/;MemberQ[constants,a];tmp=tmp/.difForm[difForm[a_ ]|dForm[a_,_]]:>0/;ListMemberQ[a,scalars];
tmp=tmp/.difForm [a_^n_]:>xWedge[n , Apply[Sequence,Table[a^(Sign[n]1),{Abs[n-1]}]],dForm[a,1]]/;ListMemberQ[a,scalars];
tmp=tmp//.xWedge[a_]:>a/;Length[{a}]==1;
(*Distribute difForm*)
tmp=tmp//.difForm[xWedge[a_,b__]]:>xWedge[difForm[a],b]+(-1)^nForm[a]xWedge[a,difForm[xWedge[b]]];
tmp=tmp/.ProductOp->Wedge/.Wedge->xWedge;(*
xPrint["Es:",tmp];
xBreak[];*)
];
tmp//.xWedge->Wedge
];
(**)
Clear[tuDifFormSimplify]
tuDifFormSimplify::usage="tuDifFormSimplify[constants_List:{},scalars_List:{},forms_List:{},flags_List:{}][exp_] puts difForm[] expressions into standard form where 0-Forms are to the left of the other terms. ProductOp's between n-Forms are considered Wedge[] products.  constants_List,scalars_List,forms_List are inputs that determine how terms are manipulated.  forms_List are in a form {f1\[Rule]n1,f2\[Rule]n2} where f1,f2 are labels to n1,n2-Forms in expressions, respectively. Functions specified by form fn[arg] in flags_List are expanded by difForm \[PartialD] . Other flags: {NoSymmetric->zeros symmetric Wedge[]s, }. xPartialD[difForm[a_],a_]\[Rule]0 Rule[] is considered. Results include CenterDot[] In Development. *22Jan2016";tuDifFormSimplify[constants_List:{},scalars_List:{},forms_List:{},flags_List:{}][exp_]:=Module[{tmp=exp,tmp0,pos,xdForm,dForms,ProductOp=Flatten[Times|dotOps|Wedge],DF={dForm,difForm},formLabels=Map[#[[1]]&,forms],loopcnt=0},
(*Standard 0-form on left*)
(* Label forms_List *)(*
xPrint["exp_:",tmp];*)
While[tmp=!=tmp0,tmp0=tmp;(*
xPrint["while0:",tmp,ProductOp];*)
tmp=tmp//.ProductOp->Wedge;(*change all operators to Wedge and extract scalars*)
tmp=tmp/.difForm[ff:fn_[aa_]]:>tuDPartial[ff,aa]\[CenterDot]difForm[aa]/;MemberQ[flags,fn[]]&&AtomQ[aa];
(*single arguement function expand*)
tmp=tmp/.(tuDPartial|tuDPartialu)[difForm[a_],a_]->0;(*\[PartialD] and difForm commute*)
tmp=tmp/.df:difForm[a_]:>Distribute[df];
(*Put forms into dForm. dForm have form-degree arguement*)
tmp=tmp/.Map[ff:#[[1]]->dForm[ff,#[[2]]]&,forms];
tmp=tmp/.dd:difForm[a_]:>dForm[a,1]/;tuMemberQ[a,scalars];
(*
xPrint["Bs:",tmp];*)
tmp=tuDifFormWedgeSimplify[constants,scalars,forms][tmp];(*
xPrint["Cs:",tmp];*)
(*put scalars in Dot expression*)tmp=tmp//.Wedge[a_,b__]:>CenterDot[a ,  Wedge[b]]/;ListFreeQ[a,DF]&&ListFreeQ[a,formLabels];(*
xPrint["Estd:",tmp];*)
tmp=tmp/.ww:Wedge[a_]:>a/;Length[ww]==1;
tmp=tmp/.ww:Wedge[_]:>OrderdFormWedge[ww];
(*return to input notation*)
tmp=tmp/.dForm[a_,1]:>difForm[a]/;ListMemberQ[a,scalars];
tmp=tmp/.dForm[a_,_]:>a/;tuMemberQ[a,formLabels];

tmp=If[MemberQ[flags,Ordered],tuWedgeSimplify[scalars,ProductOp,Ordered][tmp],tuWedgeSimplify[scalars,ProductOp,NotOrdered][tmp]];(*
xPrint["Fsimp:",tmp];*)
Inactive[tuRepeat][{tuOpDistribute[ProductOp],tuOpSimplify[ProductOp]},scalars,3];
tmp=tmp//tuRepeat[{tuOpDistribute[ProductOp],tuOpSimplify[ProductOp,scalars]},{}];(*
xPrint["end:",tmp];*)
If[loopcnt++>10,Break[]];
];
tmp
];
(*TEST
PR[$=difForm[a.c.y[x]+Wedge[\[Omega],a]+difForm[a].y[x]];
$=Inactive[tuDifFormSimplify][{},{c,y},{{\[Omega],3},{a,1}}][$];$//ColumnSumExp,
Yield,Activate[$]//ColumnSumExp,
NL,"Next: ",$=difForm[(1/r).difForm[r]];
$=Inactive[tuDifFormSimplify][{},{r},{}][$],
Yield,Activate[$]
]*)

(*Work out later*)
(**)
Clear[tuDifFormStd]
tuDifFormStd::usage="tuDifFormStd[constants_List,scalars_List,forms_List,flags_List][exp_] puts difForm[] expressions into standard form where 0-Forms are to the left of the other terms. ProductOp's between n-Forms are considered Wedge[] products.  constants_List,scalars_List,forms_List are inputs that determine how terms are manipulated.  forms_List are in a form {{f1,n1},{f2,n2}} where f1,f2 represent n1,n2-Form form expressions, respectively. Functions specified by form fn[arg] in flags_List are expanded. Other flags: {NoSymmetric->zeros symmetric Wedge[]s, }. xPartialD[difForm[a_],a_]\[Rule]0 Rule[] is considered. *01Aug2014";

tuDifFormStd[constants_List:{},scalars_List:{},forms_List:{},flags_List:{}][exp_]:=Module[{tmp=exp,tmp0,pos,xdForm,dForms,ProductOp=Times|Dot|xDot|xWedge|CenterDot,DF={dForm,difForm},formLabels=Map[#[[1]]&,forms]},
(*Standard 0-form on left*)
(* Label forms_List *)
xPrint["exp_:",tmp];
While[tmp=!=tmp0,tmp0=tmp;
tmp=tmp//.tuOpSimplify[dotOps,constants];
tmp=tmp//.ProductOp->Wedge;
tmp=tmp/.difForm[ff:fn_[aa_]]:>tuDPartial[ff,aa].difForm[aa]/;MemberQ[flags,fn[]]&&AtomQ[aa];
(*function expand*)
tmp=tmp/.tuDPartial[difForm[a_],a_]->0;(*TEST*)
tmp=tmp/.df:difForm[a_]:>Distribute[df];
tmp=tmp/.Map[ff:#[[1]]->dForm[ff,#[[2]]]&,forms];
tmp=tmp/.dd:difForm[a_]:>dForm[a,1]/;ListMemberQ[a,scalars];xPrint["Bs:",tmp];
tmp=tuDifFormWedgeSimplify[constants,scalars,forms][tmp];
xPrint["Cs:",tmp];
(*put scalars in Dot expression*)tmp=tmp//.Wedge[a_,b__]:>Dot[a ,  Wedge[b]]/;ListFreeQ[a,DF]&&ListFreeQ[a,formLabels];
xPrint["Dstd:",tmp];
tmp=tmp//.Dot[a__ ,ww:Wedge[_]]:>Dot[Times[a],ww]/.Times->Dot;
xPrint["Estd:",tmp];
tmp=tmp/.Wedge->xWedge//.xWedge[a_]:>a/;Length[{a}]==1/.xWedge->Wedge;
tmp=tmp/.ww:Wedge[_]:>OrderdFormWedge[ww];
(*return to input notation*)
tmp=tmp/.dForm[a_,1]:>difForm[a]/;ListMemberQ[a,scalars];
tmp=tmp/.dForm[a_,_]:>a/;ListMemberQ[a,formLabels]
];
tmp=If[MemberQ[flags,NotOrdered],tmp,WedgeSimplify[{}][tmp]];
tmp=tmp//.tuOpSimplify[dotOps,scalars]
];

tuStdDifForm[constants_List:{},scalars_List:{},forms_List:{},flags_List:{}]:=tuDifFormStd[constants,scalars,forms,flags](*Compatibility*)
stdDifForm[constants_List,scalars_List,forms_List][exp_]:=tuStdDifForm[constants,scalars,forms,{}][exp];
(*TEST:
PR[$=difForm[a.c.y+Wedge[\[Omega],a]+difForm[a].y];
$=Inactive[tuDifFormStd][{},{c,y},{{\[Omega],3},{a,1}}][$];$//ColumnSumExp,
Yield,Activate[$]//ColumnSumExp,
NL,"Next: ",$=difForm[(1/r).difForm[r]];
$=Inactive[tuDifFormStd][{},{r},{}][$],
Yield,Activate[$]
]*)

(**)
tuDifFormCnt::usage="tuDifFormCnt[forms_List:{}][wedgeform_List] determines the difForm n-form value in wedgeform_List, which is a List of arguements of a Wedge expression. forms_List specifies non-default n-form values of terms in wedgeform_List as {A\[Rule]n,B\[Rule]m}. Explicit DifForms are accepted.  Default n-Form value is 1. *18Jan2016*";
tuDifFormCnt[forms_List:{}][wedgeform_List]:=Module[{$=wedgeform,$s,ret,tmp},xPrint["tuDifFormCnt:",{forms,wedgeform}];
$=$/.forms;
$=$//.difForm[n_]->n+1;xPrint[$];
$=#/.a_:>1/;!NumberQ[a]&/@$;xPrint[$];
$=Apply[Plus,$]
];
(**)
Clear[tuDifFormExpand]
tuDifFormExpand::usage="tuDifFormExpand[scalars_List:{},constants_List:{},forms_List:{},product_:Times][exp_] expands DifForm's in exp_.forms_List specifies non-(default\[Rule]1) n-form values of terms in exp_ as {A\[Rule]n,B\[Rule]m}.*18Jan2016*5Jul2018*";
tuDifFormExpand[scalars_List:{},constants_List:{},forms_List:{},product_:Times][exp_]:=Module[{tmp=exp,tmp0},
While[tmp0=!=tmp,
tmp0=tmp;
tmp=tmp/.tuOpDistribute[difForm];
tmp=tmp//.difForm[a_]:>0/;(tuMemberQ[a,constants]||NumericQ[a]);

tmp=tmp//.difForm[(pp:product)[a_,b__] ]:>pp[a,difForm[pp[b]]]/;(tuMemberQ[a,constants]||NumericQ[a]);

tmp=tmp//.difForm[(pp:product)[a__,b_]]:>pp[difForm[pp[a]],b]/;(tuMemberQ[b,constants]||NumericQ[b]);

tmp=tmp//.difForm[(pp:product)[a_,b_]]:>Wedge[difForm[a],b]+Wedge[a,difForm[b]]/;tuMemberQ[a,scalars]||tuMemberQ[b,scalars];(*Is this too simplistic*)
tmp=tmp//.difForm[Wedge[a_,b__]]:>Wedge[difForm[a],b]+(-1)^tuDifFormCnt[forms][{a}]Wedge[a,difForm[Wedge[b]]];

tmp=tmp//.difForm[difForm[a__ ]]->0;
tmp=tmp/.Wedge->xWedge/.xWedge[a_]->a/.xWedge->Wedge(*Attribute[Wedge] don't work.*)
];
tmp
];
(**)
tuDifFormFunctionExpand::usage="tuDifFormFunctionExpand[function_List][exp_] expands difForm[]s in exp_ if difForm[]s contain functions in function_List. The functions are expanded via tuDPartial through their argument list.  EG: DifForm[A[r]] \[Rule]tuDPartial[A[r],r] \[CenterDot]DifForm[r]. *21Jan2016*";
tuDifFormFunctionExpand[function_List][exp_]:=Module[{$=exp,$p},
$p=$//tuExtractPositionPattern[difForm[_]];
$p=Select[$p,tuHasAnyQ[#,function]&];Print[$p];
$p=$p/.difForm[(fn:Apply[Alternatives,function])[arg__]]:>Plus@@Map[tuDPartial[fn[arg],#]difForm[#]&,{arg}];
tuReplacePart[$,$p]
];

(*
OrderdFormWedge[exp_Wedge] canonically orders Wedge expression accounting for n-Forms permutations *4Aug2014*)
OrderdFormWedge[exp_Wedge]:=Module[{tmp=exp,tmp0},
tmp=tmp/.Wedge->xWedge;
While[tmp=!=tmp0,tmp0=tmp;
xPrint["OO:",tmp];
tmp=tmp/.xWedge[c0___,a_,b_,c1___]:> xWedge[c0,(-1)^nForm[a] b,a,c1]/;!OrderedQ[{a,b}];
tmp=tmp/.xWedge->Wedge/.Wedge->xWedge(*use Wedge simplification*)
;xReturn[tmp];
];
tmp/.xWedge->Wedge
];
(*
nForm[a_] sums n_ of dForm[_,n]'s in a_. Used in dDifFormX[]. *31July2014*)
nForm[a_]:=Module[{ret,tmp},xPrint["nForm:",a];
tmp=a/.difForm[b_]:>dForm[b,1];
ret=ExtractPattern[dForm[__]][tmp]/.dForm[_,n_]->n//Apply[Plus,#]&;
ret=If[Head[ret]===List,ret[[1]],ret];
xPrint["nForm:ret:",ret];
ret
];
(**)
tuDifFormSimplifydForm::usage="tuWedgeSimplifydForm[constants_List:{},forms_List:{},flags_List:{}][exp_] simplifies exp_ containing difForm[]'s, dForm[]'s and Wedge[]'s.  constants_List:{constants removed from difForm[] and Wedge[] operators},forms_List:{specifies n-form variables in format: var \[Rule] n}. Converts all n-form variables, var, into dForm[var,n] and difForm[var]\[Rule]dForm[var,1]. Scalars are designated: scalar\[Rule]0  Returns exp_ with Wedge[], difForm[] terms and dForm[var,n] terms if not specified in forms_List.  
*22July2017*";
Clear[tuDifFormSimplifydForm]
tuDifFormSimplifydForm[constants_List:{},forms_List:{},flags_List:{}][exp_]:=Module[{tmp=exp ,tmp0,DF={dForm},scalarForm,scalarLabel,$forms,$formvar,formLabels=Map[#[[1]]&,forms],loop=0,ProductOp=Flatten[dotOps|Times|Wedge],looptest=0},
SetAttributes[Wedge,Attributes[Dot]];
(*replace Pattern specified forms in exp_ with explicit variables*)
$forms=Thread[tuExtractPattern[#[[1]]][exp]->#[[2]]]&/@forms//Flatten//DeleteDuplicates;
xPrint["$forms: ",$forms];
(*convert all Form[]s to dForm[_,n]*)
scalarLabel=Cases[$forms,HoldPattern[_->0]];
scalarForm=Map[dForm[#[[1]],0]&,scalarLabel];

tmp=tmp//.tuOpSimplify[dotOps,Flatten[{scalarForm,constants}]];
tmp=tmp//.difForm[aa_]->dForm[aa,1];
tmp=tmp/.Map[#[[1]]->dForm[#[[1]],#[[2]]]&,$forms];

While[tmp0=!=tmp,tmp0=tmp;xPrint["tmp0:",tmp0];looptest++;
If[loop++>20,Print["tuDifFormSimplifydForm:loop limit ",tmp];Return[tmp]];
tmp=tmp//.tuOpDistribute[dForm]//tuOpSimplifyFirst[dForm,constants];
tmp=tmp//.tuOpDistribute[ProductOp];
tmp=tmp//.ProductOp->Wedge;
(*move non n-form(b_) to the left*)
tmp=tmp//.Wedge[c0___,a_ , b_,c1___ ]:>Wedge[c0,b,a,c1]/;(tuFreeQ[b,DF]&&tuFreeQ[b,formLabels]);
(*avoid Wedge Pattern match problem*)
tmp=tmp//tuWedgeSimplify[Flatten[{constants}]];
(*CHECK*)
(*expand dForm[Wedge[],1] CAN WE DO dForm[,n]? *)
tmp=tmp//.dForm[Wedge[a_,b__],1]:>Wedge[dForm[a,1],b]+(-1)^nForm[a]Wedge[a,dForm[Wedge[b],1]];
tmp=tmp//.ww:Wedge[a_]:>a/;Length[ww]==1;
(*expand dForm[scalar^n,1] *)
tmp=tmp/.dForm [aa_^n_,1]:>Times[n , Apply[Sequence,Table[aa^(Sign[n]1),{Abs[n-1]}]],dForm[aa,1]]/;tuMemberQ[aa,scalarForm];
(*simplify dForm[] *)
tmp=tmp//.dForm[a_,n_]:>0/;tuMemberQ[a,constants]&&n>0;
tmp=tmp//.dForm[dForm[a_,n_],m_]:>0/;n>0&&m>0&&tuMemberQ[a,scalarForm];

tmp=tmp//tuOpSimplifyFirst[dForm,constants]; 
tmp=tmp//tuWedgeSimplify[Flatten[{constants,scalarForm}]];
tmp=tmp//.ww:Wedge[a_]:>a/;Length[ww]==1
(*ABOVE tuWedgeSimplify misses this ?? *)
(*If[looptest>5,Return[tmp]];*)
];
tmp=tmp/.dForm[a_,_]:>a/;tuMemberQ[a,formLabels];
tmp=tmp//.dForm[a_,1]:>difForm[a];
ClearAttributes[Wedge,Flat];
tmp
];
(*TEST*)(*
$=difForm[a \[Wedge](b+const c^2+scal)]+difForm[ scal^2  F[xs]]
$s={scal->0,a\[Rule]1,b\[Rule]1,c\[Rule]0,F[xs]\[Rule]2}
$=$//tuDifFormSimplifydForm[{const},$s,{}];$//ColumnSumExp*)

(**************************)
(*Inserts right arguement into operator style xPartialD into xPartialD.
xPartialD[_,mu].RightArguement -> xPartialD[RightArugement,mu]
*)
OperateDotRight=Dot[a___,c___ xPartialD[HoldPattern[_],mu_],b_]->Dot[a,c xPartialD[b,mu]];

(*Forms dot product of Tensor ku_ over index m_*)
dot2[ku_,m_]:=ku.LowerIndex[m,m][ku];

(**)
tuDIndexOrder::usage="tuDIndexOrder[index_List] Rule[]s for canonically ordering indices in index_List of double derivatives *12Jan2016*";
tuDIndexOrder[index_List]:={
(pp1:tuDDown[s_]|tuDUp[s_])[(pp2:tuDDown[s_]|tuDUp[s_])[a_,i_],j_]:>pp2[pp1[a,j],i]/;allMemberQ[{i,j},index]&&OrderedQ[{i,j}] 
};
orderxPartialD:=tuDIndexOrder;(*Compatibility*)

(* permutes xPartialD variables *)
xPartialDPermute[a_,b_]:=xPartialD[xPartialD[v_,b],a]->xPartialD[xPartialD[v,a],b];

(* Permutes IntegralOp's *)
IntegralOpPermute:=IntegralOp[a_,IntegralOp[b_,c_]]->IntegralOp[b,IntegralOp[a,c]];
(**)
tuSeparateIntegralOpVar::usage="tuIntegralOpInnerVar[var_List][int_IntegralOp] separates int_IntegralOp into two IntegralOp with variables not FreeQ of var_List in inner IntegralOp  *6Dec2012*";
tuSeparateIntegralOpVar[var_List][int_IntegralOp]:=Module[{ivars,integrand,tmp},
{ivars,integrand}=Apply[List,int];
xPrint[var,ivars];
tmp=int/.IntegralOp[a_,b_]:>IntegralOp[Select[a,ListFreeQ[#,var]&],IntegralOp[Select[a,!ListFreeQ[#,{var}]&],b]];
tmp
];
IntegralOpInnerVar[var_List][int_IntegralOp]:=tuSeparateIntegralOpVar[var][int];
(*
separateIntegralOp Rule for separating multiple IntegralOp's.*)
separateIntegralOp:=IntegralOp[a_List,b_]:>If[Length[a]>1,IntegralOp[Most[a],IntegralOp[{Last[a]},b]]]
(*
IntegralOpInnerVar[var_List][int_IntegralOp] separates int_IntegralOp into two IntegralOp with variables not FreeQ of var_List in inner IntegralOp  *6Dec2012*)
IntegralOpInnerVar[var_List][int_IntegralOp]:=Module[{ivars,integrand,tmp},
{ivars,integrand}=Apply[List,int];
xPrint[var,ivars];
tmp=int/.IntegralOp[a_,b_]:>IntegralOp[Select[a,ListFreeQ[#,var]&],IntegralOp[Select[a,!ListFreeQ[#,{var}]&],b]];
tmp
];
(*
timespaceIntegralOpVar[var_,index_][int_IntegralOp] takes all var_ in the int_IntegralOp variables and separates their index_ variable into time and space components.  *7Dec2012*)
timespaceIntegralOpVar[var_,index_][int_IntegralOp]:=Module[{ivars,integrand,ivar0,ivar1,ivar10,ivar11},
{ivars,integrand}=Apply[List,int];
xPrint[var,ivars];
ivar0=Select[ivars,ListFreeQ[#,{var}]&];
ivar1=Select[ivars,!ListFreeQ[#,{var}]&];
xPrint[var,ivar1];
ivar10=ivar1/.var:>IndexChangeTU[{index,timespace@0}][var];
ivar11=ivar1/.var:>IndexChangeTU[{index,timespace@1}][var];
IntegralOp[Flatten[{ivar0,ivar10,ivar11},1],integrand]
];
(*
subtimespaceSum[index_] Rule that separates UpDn index_ of Tensor product into sum of products of timespace@0 and timespace@1 Tensors. *7Dec2012*)
subtimespaceSum[index_]:=
Tensor[a_,au_List,ad_List]Tensor[b_,bu_List,bd_List]:>Tensor[a,(au/.index->timespace@0),ad]Tensor[b,bu,(bd/.index->timespace@0)]+
Tensor[a,(au/.index->timespace@1),ad]Tensor[b,bu,(bd/.index->timespace@1)]/;MemberQ[au,index]&&MemberQ[bd,index]
(*
sub\[Delta]func[var_] converts \[Delta][func_[var_] ] to \[Delta][ var_- fn[] ]/Abs[D,var].  NOTE: There is a difference if UpDn contractions are used in func_ of a factor of 2 and Sqrt[].  Only uses last Solve[] result. Also, only for scalar var_.  *8Dec2012*)
sub\[Delta]func[var_]:=\[Delta][func_]:>\[Delta][$$t=Solve[func==0,var][[-1,1]];$$t[[1]]-$$t[[2]]]/Abs[D[func,var]]/;!FreeQ[func,var];
(*
integrate\[Delta]func[var_] applies the relation  DiracDelta[f[x]]\[Equal]Sum[DiracDelta[x-Subscript[x,j]]/Abs[Derivative[1][f][Subscript[x,j]]],{j,1,n}]/;f[Subscript[x,j]]\[Equal]0&&Derivative[1][f][Subscript[x,j]]\[NotEqual]0 
to IntegralOp[var_, \[Delta][func_[var_]] other_ ] -> x\[Delta][var_->fn] other_ / Abs[D[func_,var_].  The x\[Delta][var_->fn] indicates that the integration has been appled and var_->fn is a relationship that must be maintained.
NOTE: There is a difference if UpDn contractions are used in func_ of a factor of 2 and Sqrt[].  Only uses last Solve[] result.  Also, only for scalar var_.    *5May2014*)
integrate\[Delta]funcRule[var_]:=IntegralOp[{{var}},(other_:1)  \[Delta][func_]]:>(other x\[Delta][$$t=Solve[func==0,var][[-1,1]]]/Abs[D[func,var]]/.$$t/.x\[Delta][_]->1)/;!FreeQ[func,var];
(*
integrate\[Delta]funcRule1[var_List][exp_] perform integration where the integrand contains \[Delta][func_].  Mathematica Integrate is used.
var_List is integration variable with limits to distinquish the integral, e.g. {x,-\[Infinity],\[Infinity]}, in multi-integral situation. The result may need further manipulation.  Replaces integrate\[Delta]funcRule. *23Jul2014*)
integrate\[Delta]funcRule1[var_List][exp_]:=Module[{tmp,terms},
tmp=exp//tuExtractPositionPattern[IntegralOp[{var},_]];
tmp=
tmp/.\[Delta][a_]:>DiracDelta[a]/;!FreeQ[a,var[[1]]]/.subxIntegrate/.subIntegrate;
ReplacePartTU[exp,tmp]
];

tuIntegrate\[Delta]func::usage="tuIntegrate\[Delta]func[var_]exp_?(tuMemberQ[#,{xIntegral[_,_],tuIntegral[_,_]}]&) 'integrates' exp_ over var_ if var_ is contained in \[Delta][] by Solve[]ing the integrand at Arguement[\[Delta][]]->0. NOTE: does not check for valid range of var_. Typical use: exp/.ii:xIntegral[_,_]:>integrate\[Delta]func[\!\(\*SubscriptBox[\(x\), \(3\)]\)][ii] *6Jan2017*";
tuIntegrate\[Delta]func[var_][exp_?(tuMemberQ[#,{xIntegral[_,_],tuIntegral[_,_]}]&)]:=Module[{tmp=exp,vars,intvar,integrand,dfuncs,dfunc,df,$$t,x\[Delta],head,args},
head=Head[tmp];
args=Apply[List,tmp];xPrint["args:",head,":",args];
If[!MatchQ[tmp,xIntegral[_,_]],
{vars,integrand}=args,
{integrand=First[args],vars=Rest[args]}
];xPrint["integrand,vars",{integrand,vars}];
dfuncs=ExtractPattern[\[Delta][_]][integrand];
If[FreeQ[vars,var]||FreeQ[dfuncs,var],Return[exp]];(*no OP var*)
(*form of vars: {x}||{x,y}||{{x,_,_},{y,_,_}}*)
If[(intvar=Cases[vars,var]//First),Null,
intvar=Cases[vars,{var,___}]//First;
];
vars=DeleteCases[vars,intvar];
(*use first \[Delta][] with var*)
df=Select[dfuncs,!FreeQ[#,var]&][[1,1]];
integrand=integrand/.(other_:1)  \[Delta][df]:>(other  x\[Delta][$$t=Solve[df==0,var][[-1,1]]]/Abs[D[df,var]]/.$$t/.x\[Delta][_]->1);
If[Length[vars]>0,
If[!MatchQ[tmp,xIntegral[_,_]],
IntegralOp[vars,integrand],
xIntegral[integrand,vars]],
integrand]
];
integrate\[Delta]func[var_][exp_?(tuMemberQ[#,{xIntegral[_,_],tuIntegral[_,_]}]&)_]=tuIntegrate\[Delta]func[var][exp];

(*
integrate\[Delta]funcUpDn[var_] does the same as integrate\[Delta]func[var_] except that convert any UpDn var_ pairs to var_ pairs.   *4May2014*)
integrate\[Delta]funcUpDn[var_,index_][exp_IntegralOp]:=Module[{tmp=exp,subupdn},
subupdn=var UpDownIndexSwap[index][var]->var var;
tmp=tmp//.subupdn;
xPrint[subupdn,tmp];
tmp/.IntegralOp[{{var}},other_ \[Delta][func_]]:>(other x\[Delta][$$t=Solve[func==0,var][[-1,1]]]/Abs[D[func,var]]/.$$t/.x\[Delta][_]->1)/;!FreeQ[func,var]
];

(* Print routine for DEBUGing Modules.  *)
IfDEBUG[name_,DEBUG_,list_,comment_]:=Module[{},
If[DEBUG==True,
Print[name,":",comment,":",list];
];
];

(*Factors exp_ in form 1/(A_ B) into 1/A-1/B form. *)
FactorABinv[exp_,A_]:=Module[{Binv,B,tmp,numer=Numerator[exp]},
B=1/(A exp/numer//Simplify);
tmp=(1/A-1/B)/(B-A);
tmp=numer tmp(B-A)
];

(*Factors exp_ in form (1/A).(1/B) into 1/A-1/B form. *)
FactorDotABinv[exp_]:=Module[{A,Binv,B,tmp,numer=Numerator[exp]},
A=1/First[exp];
B=1/Last[exp];
tmp=B-A/.Dot->Times//Expand//SimplifyTensorSum//UpDownAdjust;
tmp=(1/A-1/B)/tmp
];

(*ReplaceVariableNames{} replaces exp_ with standard set of variables of form S$nnnn for manipulation. *)
StandardVariableNames[exp_]:=Module[{tmp=exp,list},
list=tmp/.Dot|Times|Plus|Power->List//Flatten;
list=Select[list,!NumericQ[#]&]//Union;
Map[{#->Unique[S]}&,list]//Flatten
];

(**)
tuExtractPattern::usage="tuExtractPattern[pattern_,maxlevel_:Infinity][exp_] extracts a List of items in exp_ that match pattern_ to maxlevel_. *3Feb2014* ";
tuExtractPattern[pattern_,maxlevel_:Infinity][exp_]:=Module[{pos},
pos=Position[exp,pattern,{0,maxlevel}];
Extract[exp,pos]
];
ExtractPattern:=tuExtractPattern

(*
ExtractPatternXpat[pattern_][exp_] extracts pattern_ or pattern_List from exp_ and outputs lists of matches to {Xpat[pattern_]} and {exp_} where Xpat[pattern_] was found.  Avoids the Times[] difficulty with Position[].  *26Jul2013*)
ExtractPatternXpat[pattern_][exp_]:=Module[{tmp=exp,$i,test,$pat={},list,sub,$npat,$ii,xpat,ipat,patterns,testpat},
patterns=Flatten[{pattern}];
For[$i=1,test=!=tmp,$i++,
Do[(*for every pattern*)
test=tmp;
tmp=tmp/.(pp:patterns[[ipat]]):>xpat[Last[AppendTo[$pat,Xpat[pp]]]];
tmp=tmp/.xpat[_]:>$npat[Length[$pat]],
{ipat,Length[patterns]}
]
];
For[$ii=1,$ii<=Length[$pat],$ii++,
tmp=tmp/.$npat[$ii]:>$pat[[$ii]]
];
{$pat,tmp}
];
(*
keepPlusTerms[ext_][exp_] keeps terms in Plus[] that are not FreeQ of ext_ *25Oct2014*)
keepPlusTerms[ext_][exp_]:=Module[{},exp/.Plus->xPlus/.xx:xPlus[a__]:>Select[xx,!FreeQ[#,ext]&]/.xPlus->Plus
];
(*Applies function_ to Tensor products in Times expression exp_.*)
ApplyToTensorProductOnly[function_,exp_Times]:=Module[{tmp,tmpt,tmpa},
tmp=Apply[List,exp];
tmpt=Map[If[Head[#]===Tensor,#,1]&,tmp];
tmpa=Map[If[Head[#]===Tensor,1,#]&,tmp];
tmpt=function[Apply[Times,tmpt]];
tmpa=Apply[Times,tmpa];
tmpa tmpt
];
(*returns Tensor product terms in Times expression exp_.*)
TensorProductOnly[exp_Times]:=Module[{tmp},
tmp=Apply[List,exp];
tmp=Map[If[Head[#]===Tensor,#,1]&,tmp];
tmp=Apply[Times,tmp]
];
(*returns Position->Patterns of Tensor products *)
ExtractTensorProducts[exp_]:=Module[{tmp},
tmp=exp//tuExtractPositionPattern[Times[a___,Tensor[___],b___]];
Map[MapAt[TensorProductOnly[#]&,#,2]&,tmp]
];
(*apply function_ to Tensor products in exp_.*)
ApplyToTensorProducts[function_,exp_]:=Module[{tmp},
tmp=exp//tuExtractPositionPattern[Times[a___,Tensor[___],b___]];
tmp=Map[MapAt[ApplyToTensorProductOnly[function,#]&,#,2]&,tmp];
ReplacePart[exp,tmp]
];

(**)

(*ReplaceExtract returns extract_List second items with repl_List*)
ReplaceExtract[extract_List,repl_List]:=Module[{},
MapThread[Rule[First[#1],#2]&,{extract,repl}]
];

(*Tests exp_ to be FreeQ of any patterns_.*)
FreePattern[exp_,patterns_List]:=And@@Map[FreeQ[exp,#]&,patterns];

(*Runs Collect after substituting for matched patterns.  The pattern may be of form P1|P2.  Patterns involving Times do not work, e.g. pattern_-> Tensor[a_,b_,c_]Tensor[d_,e_,f_]
One way around it is to use substitution first:
sub=Tensor[a_,b_,c_]Tensor[d_,e_,f_]\[Rule]Tensor2[a,b,c,d,e,f];
subr=RuleX1[sub, Tensor2[___],{a,b,c,d,e,f}]; \[LongLeftArrow]reverse substitution
tmp=tmp/. sub;
CollectPattern[tmp,Tensor2[___]]/.subr
*)
CollectPattern[exp_,pattern_]:=Module[{pos=Position[exp,pattern],tmp,varlist,sub,uvar},
varlist=Extract[exp,pos]//Union;
uvar=Map[Unique[]&,varlist];
sub=MapThread[Rule,{varlist,uvar}];
tmp=exp/.sub;
tmp=Collect[tmp,uvar];
tmp/.Map[Reverse[#]&,sub]
];


(*Extract from Dot[] expression elements that do not match any of the patterns. Usage: DotKeepPattern1[patternlist][expression].  Returns (nokeeps) Dot[ keeps ]*)
DotKeepPattern1[patterns_][exp_]:=
Module[{tmp=exp,dot,times,test,dots,pos,repl={},i,DEBUG=0},
DotExpandMode[False];
IfDEBUG["DotKeepPattern",DEBUG>0,{exp},"exp"];
pos=Position[exp,HoldPattern[Dot[__]]];
dots=Extract[exp,pos];
For[i=1,i<=Length[dots],i++,
dot={};
tmp=dots[[i]];
IfDEBUG["DotKeepPattern",DEBUG>0,{i,tmp},"{i,tmp}"];
tmp=tmp//.Times->Dot;
tmp=Apply[List,tmp];
test=Map[FreePattern[#,patterns]&,tmp];
times=Pick[tmp,test,True];
times=Apply[Times,times];
dot=Pick[tmp,test,False];
dot=If[Length[dot]>0,Apply[Dot,dot],1];
AppendTo[repl,pos[[i]]->(times dot)];
];
tmp=ReplacePart[exp,repl]
];
(******)

(*Extracts terms in DotExp_ that do not match patterns_ in Dot[]->(no match) Dot[match].  Doesn't work for Power[a b,n m].
*)
DotPatternIn[patterns_][DotExp_]:=Module[{tmp=DotExp,test,times,dot,DEBUG=0},
IfDEBUG["DotPattern",DEBUG>0,{patterns,tmp},"{tmp}"];
tmp=Expand[tmp]//.Times|Dot->List//Flatten;
IfDEBUG["DotPattern",DEBUG>2,{tmp},"{tmp}"];
test=Map[FreePattern[#,patterns]&,tmp];
IfDEBUG["DotPattern",DEBUG>2,{test},"{test}"];
times=Pick[tmp,test,True];
times=Apply[Times,times];
dot=Pick[tmp,test,False];
dot=If[Length[dot]>0,Apply[Dot,dot],1];
IfDEBUG["DotPattern",DEBUG>2,{times,dot},"{times,dot}"];
tmp=times dot;
IfDEBUG["DotPattern",DEBUG>0,{tmp},"result"];
tmp
];

(*4.25.10*)
DotPatternIn1[patterns_][DotExp_]:=Module[{tmp=DotExp,test,times,dot,DEBUG=0},
IfDEBUG["DotPattern",DEBUG>0,{patterns,tmp},"{input}"];
tmp=Expand[tmp]//.Times|Dot->xDot//Flatten;
IfDEBUG["DotPattern",DEBUG>2,{tmp},"{tmp}"];
test=Map[FreePattern[#,patterns]&,tmp];
IfDEBUG["DotPattern",DEBUG>2,{test},"{test}"];
times=Pick[tmp,test,True];
times=times/.xDot->Times;
dot=Pick[tmp,test,False];
dot=If[Length[dot]>0,dot/.xDot->Dot,1];
IfDEBUG["DotPattern",DEBUG>2,{times,dot},"{times,dot}"];
tmp=times dot;
IfDEBUG["DotPattern",DEBUG>0,{tmp},"result"];
tmp
];

(*4.9.2010*)
DotKeepPattern[patterns_][exp_]:=
(*Extract from Dot[] expression elements that do not match any of the patterns. 
Usage: DotKeepPattern[patternlist][expression].
  Returns expression with Dot[]'s->
(nokeeps) Dot[ keeps ].  This is a frontend routine expands xPartialD's and eliminates remembering HoldPattern[] on Dot[__]. *)
Module[{tmp,dot,times,test,dots,pos,DEBUG=0},
DotExpandMode[True];
IfDEBUG["DotKeepPattern",DEBUG>0,{exp},"input"];
tmp=exp/.xPartialD[a_,b_]:>xPartialDDot[a,b];
pos=Position[tmp,HoldPattern[Dot[__]]];
IfDEBUG["DotKeepPattern",DEBUG>0,{pos},"pos"];
tmp=MapAt[DotPatternIn1[patterns],tmp,pos];
(*Apply twice to clean up*)
pos=Position[tmp,HoldPattern[Dot[__]]];
IfDEBUG["DotKeepPattern",DEBUG>0,{pos},"pos"];
tmp=MapAt[DotPatternIn1[patterns],tmp,pos]
];

(*
Solves for pattern_ in EqualExp_. Returns solution using first variable from ExtractPositionPattern[_,pattern]  *19Oct2013*)
Solve4Pattern[EqualExp_,pattern_]:=Module[{tmp=EqualExp/.Rule->Equal,pos,posd},
pos=tmp//tuExtractPositionPattern[pattern];
posd=Map[#[[1]]->$$XX&,pos];
tmp=ReplacePart[tmp,posd];
tmp=Solve[tmp,$$XX][[1]];
tmp=tmp/.$$XX->pos[[1,2]](*Substitute for only first variable.*)
];
(*
Simpler version of above.  Forgot why previous one was rewritten that way. *6Sep2012*)
(*Solve4Pattern[EqualExp_,pattern_]:=Module[{tmp=EqualExp/.Rule->Equal,$XX},
tmp=tmp//.pattern\[Rule]$XX;
tmp=Solve[tmp,$XX];
tmp=tmp/.$XX\[Rule]pattern
];*)
(*
Solves for pattern_ in RuleExp_ 29June2012 *)
Rule4Pattern[RuleExp_,pattern_]:=Module[{tmp=RuleExp,patList,$X},
tmp=tmp/.Rule->Equal;
patList=ExtractPattern[pattern][tmp];
xPrint[patList];
tmp=tmp/.pattern->$X;
tmp=Solve[tmp,$X];
tmp=tmp/.$X->patList[[1]]
];
(*
MatrixSubs applies Rules->sublist_ to matrix equation where Plus[] is disabled.  The auto-evaluation of Plus[] creates unwanted results. *)
MatrixSubs[exp_,sublist_]:=Module[{tmp=exp,i,DEBUG=0},
tmp=tmp/.Plus->xPlus;
IfDEBUG["MatrixSubs",DEBUG>0,{tmp},"tmp"];
Do[
tmp= ReplaceAll[tmp,sublist[[i]]],
{i,Length[sublist]}];
tmp=tmp/.xPlus->Plus
];

(*EvenPowers eliminates odd powers of var_List in exp_.*)
EvenPowers[var_List][exp_]:=Module[{sub,tmp,delete,n,V,L},
{V,L}=Unique[{V,L}];
sub=Map[Rule[V:#,L V]&,var];
tmp=exp/.sub;
tmp=CoefficientList[tmp,L];
delete=Range[2,Length[tmp],2];
tmp=Delete[tmp,{delete}];
Apply[Plus,tmp]
];
(*IntegralOpDeleteOddPowers deletes odd powers of var_List from the deepest level IntegralOp in exp_ *)
IntegralOpDeleteOddPowers[var_List][exp_]:=Module[{tmp=exp,tmpe,tmpd,tmpn},
tmpe=ExtractIntegrand[tmp];
tmpd=tmpe[[2,1]]//Denominator;
tmpn=tmpe[[2,1]]//Numerator;
tmpn=tmpn//EvenPowers[{ pu[_],pd[_] }];
tmp=ReplacePart[tmp,tmpe[[1]]->tmpn/tmpd]
];


(*DifNoDependance[exp_,set1_List,set2_List] zeros xPartialD[a,b] if a\[Element]set1 and b\[Element]set2 or a\[Element]set2 and b\[Element]set1 *)
DifNoDependance[exp_,set1_List,set2_List]:=Module[{tmp=exp},
tmp=tmp/.xPartialD[a_,b_]:>0/;(ListMemberQ[a,set1]&&ListMemberQ[b,set2]||ListMemberQ[b,set1]&&ListMemberQ[a,set2]
);
tmp=tmp/.xPartialDu[a_,b_]:>0/;(ListMemberQ[a,set1]&&ListMemberQ[b,set2]||ListMemberQ[b,set1]&&ListMemberQ[a,set2]
)
];

(*Rule that lowers all indices in Tensor if possible*)
sLowerAllIndices=
Tensor[a_,b_,c_]:>Tensor[a,MapThread[If[#2===Void,Void,#1]&,{b,c}],
MapThread[If[#2===Void,#1,#2]&,{b,c}]];

(*Rule that raises all indices in Tensor except except_List*)
sRaiseAllIndices[except_List]=
{Tensor[a_,b_,c_]:>Tensor[a,
MapThread[If[#1===Void&&!MemberQ[except,#2],#2,#1]&,{b,c}],MapThread[If[#1===Void&&!MemberQ[except,#2],Void,#2]&,{b,c}]],
xPartialD[a_,b_]:>xPartialDu[a,b]/;!MemberQ[except,b],xCovariantD[a_,b_]:>xCovariantDu[a,b]/;!MemberQ[except,b]
};
(*Lowers indices in Tensor's based upon index_List.  Applies \[Eta]uu (signature factor) on Tensor indices that are lowered.  
Usage:  LowerIndex\[Eta][{i1,i2,...}][expression] *)
LowerIndex\[Eta][index_List][exp_]:=Module[{tmp,tmp1,DEBUG=0,mname="LowerIndex\[Eta]"},
IfDEBUG[mname,DEBUG>0,{index,exp},"{index,exp}"];m
tmp=exp/.
Tensor[a_,b_,c_]:>Tensor[a,
MapThread[If[#2===Void&&MemberQ[index,#1],Void,#1]&,{b,c}],MapThread[If[#2===Void&&MemberQ[index,#1],#1,#2]&,{b,c}]
]Apply[Times,MapThread[If[#2===Void&&MemberQ[index,#1],\[Eta]uu[#1,#1],1]&,{b,c}]];
tmp/.fixTensorWithArg
];

(*Rule version of LowerIndex\[Eta].  Does not fixTensorWithArg *)
sLowerIndex\[Eta][index_List]:=Tensor[a_,b_,c_]:>Tensor[a,
MapThread[If[#2===Void&&MemberQ[index,#1],Void,#1]&,{b,c}],MapThread[If[#2===Void&&MemberQ[index,#1],#1,#2]&,{b,c}]
]Apply[Times,MapThread[If[#2===Void&&MemberQ[index,#1],\[Eta]uu[#1,#1],1]&,{b,c}]];
(*repairs notation of Tensor with arguements, e.g. (-Au[i])[x]->-Au[i][x] *)
fixTensorWithArg:={(a_ Tensor[b_,c_,d_])[e_]->a Tensor[b,c,d][e]
};

(*Manipulates limit expression into integration variable specification, e.g., a<x<b && c<y<d -> {{x,a,b},{y,c,d}}  *)
Limits2IntRange[limit_]:=Module[{tmp=limit,tmp1},
tmp=tmp/.LessEqual->Less;(*multiple Alternative does not work*)
tmp1=ExtractPattern[Inequality[a_,Less,b_,Less,c_]][tmp];
Map[{#[[3]],#[[1]],#[[5]]}&,tmp1]
];

(*
Zeros are Rules of local functions that are 0. *17Oct2013*)
Zeros:={IntegralOp[_,0]->0,xSum[0,__]->0,DerivOps[0,__]->0,xProduct[0,__]->0}
(*
includeFactors[op_Pattern,pos_][exp_] includes Times factor into op_Pattern, e.g., xSum[_,_], at position pos_ in argument of op_Pattern.  Takes terms like A xSum[B,n]->xSum[A B,n] *17Nov2013*)
includeFactors[op_Pattern,pos_][exp_]:=Module[{tmp=exp},
tmp=tmp//.a_ (oo:op):>MapAt[# a&,oo,pos]
]
(*
contourIntegralPrep[exp_] prepares exp_ for applying Residue--attempts to reduce express so that IntegralOp is on the interior most arguement. PROTOTYPE *17Nov2013*)
contourIntegralPrep[exp_]:=Module[{tmp=exp,tmp1},
tmp=tmp//ExpandAll;
tmp=tmp//DistributeOp[xSum[_,_]];
tmp=tmp//DistributeOp[xPartialD[_,_]];
tmp=tmp//.xPartialD[xSum[a_,n_],b_]->xSum[xPartialD[a,b],n]//ExpandAll;
tmp=tmp//DistributeOp[IntegralOp[_,_]];
tmp=tmp//includeFactors[xSum[_,_],1];
tmp=tmp//.IntegralOp[b_,xSum[a_,n_]]->xSum[IntegralOp[b,a],n];
tmp
]


(* ::Input::Initialization:: *)
Unprotect[Transpose];
Transpose[(dd:dotOps)[a_,b_]]:=dd[Transpose[b],Transpose[a]]
Transpose[Times[c_,(dd:dotOps)[a_,b_]]]:=c dd[Transpose[b],Transpose[a]]/;FreeQ[c,dotOps]
Transpose[Times[c_,a_]]:=c Transpose[a]/;NumericQ[c]
Transpose[Transpose[a_]]:=a
Transpose[a_+b_]:=Transpose[a]+Transpose[b]
Protect[Transpose];

Unprotect[ConjugateTranspose];

ConjugateTranspose[(op:dotOps)[a_,b_]]:=op[ConjugateTranspose[b],ConjugateTranspose[a]]
ConjugateTranspose[Times[a_,b_]]:=Times[ConjugateTranspose[b],ConjugateTranspose[a]]
ConjugateTranspose[Times[c_,Dot[a_,b_]]]:=ConjugateTranspose[c] Dot[ConjugateTranspose[b],ConjugateTranspose[a]]/;FreeQ[c,Dot]
ConjugateTranspose[ConjugateTranspose[a_]]:=a
ConjugateTranspose[a_+b_]:=ConjugateTranspose[a]+ConjugateTranspose[b]
ConjugateTranspose[Exp[a_]]:=Exp[ConjugateTranspose[a]]

ConjugateTranspose[Rule[a_,b_]]:=Rule[ConjugateTranspose[a],ConjugateTranspose[b]]
ConjugateTranspose[a_]:=Conjugate[a]/;NumericQ[a]
Protect[ConjugateTranspose];

(*Rule for distributing Transpose over Sums and Dot.
Usage:  exp//.sTransposeExpand  *)
sTransposeExpand:=
{Transpose[a__+b__]->Transpose[a]+Transpose[b],
Transpose[Dot[a__]]:>Map[Transpose[#]&,Dot[Reverse[a]]]};

(*Rule to ease typing of ConjugateTranspose.*)
subDaggerCT={SuperDagger->ConjugateTranspose,SuperStar->Conjugate};
(*
egRule: distribute SuperDagger over Matrix elements:$s=SuperDagger[a_]\[RuleDelayed]Map[Thread[SuperDagger[#]]&,Transpose[a]]/;MatrixQ[a]
*)

(* Replaces Conjugate[realVar]|ConjugateTranspose[realVar]->realVar in exp_ if realVar is MemberQ of reals_  *)
ConjugateReals[exp_,reals_List]:=Module[{tmp=exp},
tmp=ExpandConjugateTranspose[tmp];
tmp=tmp//.Conjugate[a_]:>a/;a\[Element]Reals;
tmp=tmp//.Conjugate[a_]:>a/;ListMemberQ[a,reals];
tmp=ExpandConjugateTranspose[tmp];
tmp=tmp/.ConjugateTranspose[a_]:>Transpose[a]/;ListMemberQ[a,reals]
];

(**)
Clear[tuConjugateSimplify]
tuConjugateSimplify::usage="tuConjugateSimplify[reals_List:{}][exp_] simplifies Conjugate[]'s in exp_ with optional reals_List of variables.";
tuConjugateSimplify[reals_List:{}][exp_]:=Module[{tmp=exp},
tmp=Expand[tmp];
tmp=tmp//.tuConjugateDistribute//.tuOpSimplify[dotOps];
tmp=tmp//.Conjugate[a_]:>a/;a\[Element]Reals;
tmp=tmp//.Conjugate[a_]:>a/;tuMemberQ[a,reals]
];
ConjugateSimplify[exp_,reals_List:{}]:=tuConjugateSimplify[reals][exp](*Compatibility*)
(**)
tuConjugateDistribute::usage="tuConjugateDistribute are Rules for distribution Conjugate[] over an expression. EG. exp_//.tuConjugateDistribute *19Jul2015*20Apr2018** ";
tuConjugateDistribute:={Conjugate[a_+b_]->Conjugate[a]+Conjugate[b],
Conjugate[a_ b_]->Conjugate[a] Conjugate[b],
Conjugate[Power[a_,b_]]->Power[Conjugate[a],Conjugate[b]],
Conjugate[a_==b_]->Conjugate[a]==Conjugate[b],
Conjugate[a_->b_]->Conjugate[a]->Conjugate[b],
Conjugate[Sum[a_,b__]]:>Sum[Conjugate[a],b],
Conjugate[xSum[a_,d__]]->xSum[Conjugate[a],d],
Conjugate[Integrate[a_,b__List]]->Integrate[Conjugate[a],b],
Conjugate[xIntegral[a_,b__List]]->xIntegral[Conjugate[a],b],
Conjugate[IntegralOp[a_,d_]]->IntegralOp[a,Conjugate[d]],
Conjugate[(oo:DerivOps)[a_,d_]]->oo[Conjugate[a],Conjugate[d]],
Conjugate[(op:dotOps|Times)[a_,b_]]->op[Conjugate[a] , Conjugate[b]]
};
DistributeConjugate[exp_]:=Module[{},exp//.tuConjugateDistribute]; (*Compatibility*)

tuConjugateTransposeExpand::usage="tuConjugateTransposeExpand[exp_] expands ConjugateTranspose and Conjugate terms in exp_. Aware of IntegralOp and DerivOps. *30Jul2015*";
tuConjugateTransposeExpand[exp_]:=
Module[{tmp=exp,tmp1=Null,sub,cOps=Conjugate|ConjugateTranspose},
tmp=tmp//.subDaggerCT;(* superDagger mean ConjugateTranspose *)
sub={
ConjugateTranspose[Conjugate[a_]]->Transpose[a],
Conjugate[ConjugateTranspose[a_]]->Transpose[a] ,
(cOp:cOps)[(op:Sum|xSum)[a_,b__]]->op[cOp[a],b],
(cOp:cOps)[xIntegral[a_,b__]]:>xIntegral[cOp[a],b],
Conjugate[Power[a_,b_]]->Power[Conjugate[a],Conjugate[b]],
Conjugate[a_]:>Map[Conjugate[#]&,a]/;MemberQ[Flatten[{List,Plus,Equal,Rule,productOps,DerivOps}],Head[a]],
ConjugateTranspose[(op:DerivOps)[a_,d_]]->op[ConjugateTranspose[a],Conjugate[d]],(*d always scalar*)
ConjugateTranspose[(op:dotOps)[a_,Longest[b__]]]:>
If[Length[{b}]>1,
op[ConjugateTranspose[op[b]],ConjugateTranspose[a]],
op[ConjugateTranspose[b],ConjugateTranspose[a]]
],
ConjugateTranspose[a_]:>Map[ConjugateTranspose[#]&,a]/;MemberQ[{List,Plus,Equal,Rule,CircleTimes,CirclePlus},Head[a]]
};
tmp=tmp//.sub
];
(**)
tuConjugateTransposeSimplify::usage="tuConjugateTransposeSimplify[reals_List:{}][exp_] simplifies ConjugateTranspose and Conjugate terms in exp_ accounting for reals_List.  
tuConjugateTransposeSimplify[reals_List:{},scalars_List:{}][exp_] simplifies ConjugateTranspose and Conjugate terms in exp_ accounting for reals_List and scalars_List.
tuConjugateTransposeSimplify[reals_List:{},scalars_List:{},hermitian_List:{}][exp_] simplifies ConjugateTranspose and Conjugate terms in exp_ accounting for reals_List, scalars_List, and hermitian_List. *30Jul2015*";
tuConjugateTransposeSimplify[reals_List:{}][exp_]:=Module[{tmp=exp},
tmp=Expand[tmp];
tmp=tuConjugateTransposeExpand[tmp]//tuOpSimplifyF[dotOps];
tmp=tmp//tuConjugateSimplify[reals];
tmp=tmp//.ConjugateTranspose[a_]:>Transpose[a]/;tuMemberQ[a,reals];
tmp=tmp//.ConjugateTranspose[a_^n_]:>ConjugateTranspose[a]^n/;tuMemberQ[n,reals];
tmp=tmp//tuConjugateSimplify[reals]
(*tmp=tmp//.Conjugate[a_]:>a/;ListMemberQ[a,reals]>0*)
];
tuConjugateTransposeSimplify[reals_List:{},scalars_List:{}][exp_]:=Module[{tmp=exp,scal},
scal=Flatten[{scalars,Conjugate/@scalars}];
tmp=Expand[tmp];
tmp=tuConjugateTransposeExpand[tmp]//tuOpSimplifyF[dotOps,scal];
tmp=tmp//tuConjugateSimplify[reals];
tmp=tmp//.ConjugateTranspose[a_]:>Transpose[a]/;tuMemberQ[a,reals];
tmp=tmp//.ConjugateTranspose[a_^n_]:>ConjugateTranspose[a]^n/;tuMemberQ[n,reals];
tmp=tmp//.tuTransposeSimplify[scal];
tmp=tmp//.tuOpSimplify[dotOps,scal](*;
tmp=tmp/.Conjugate[a_]:>a/;ListMemberQ[a,reals]>0*)
];
tuConjugateTransposeSimplify[reals_List:{},scalars_List:{},hermitian_List:{}][exp_]:=Module[{tmp=exp,scal},
scal=Flatten[{scalars,Conjugate/@scalars}];
tmp=Expand[tmp];
tmp=tuConjugateTransposeExpand[tmp]//tuOpSimplifyF[dotOps,scal];
tmp=tmp//tuConjugateSimplify[reals];
tmp=tmp//.ConjugateTranspose[a_]:>Transpose[a]/;tuMemberQ[a,reals];
tmp=tmp//.ConjugateTranspose[a_^n_]:>ConjugateTranspose[a]^n/;tuMemberQ[n,reals];
tmp=tmp//.tuTransposeSimplify[scal];
tmp=tmp//.simpleHermitian[hermitian];
tmp=tmp//.tuOpSimplify[dotOps,scal](*;
tmp=tmp/.Conjugate[a_]:>a/;ListMemberQ[a,reals]>0*)
];

(* Distributes Conjugate and ConjugateTranspose over exp_. Replaces SuperDagger with ConjugateTranspose.*)
DistributeConjugateCT[exp_]:=
Module[{tmp=exp,tmp1=Null,sub},
tmp=tmp//.subDaggerCT/.Dot->xDot;(*Dot interferes with Rule sometimes.*)
sub={
Conjugate[Power[a_,b_]]->Power[Conjugate[a],Conjugate[b]],
Conjugate[Sum[a_,b__]]:>Sum[Conjugate[a],b],
Conjugate[xSum[a_,d__]]->xSum[Conjugate[a],d],
Conjugate[Integrate[a_,b__List]]->Integrate[Conjugate[a],b],
Conjugate[IntegralOp[a_,d_]]->IntegralOp[a,Conjugate[d]],
Conjugate[a_]:>Map[Conjugate[#]&,a]/;MemberQ[{List,Plus,Equal,Rule,Times,xPartialD,xPartialDu,Dot,xDot},Head[a]],
(**)
ConjugateTranspose[Sum[a_,b__]]->Sum[ConjugateTranspose[a],b],
ConjugateTranspose[xSum[a_,d__]]->xSum[ConjugateTranspose[a],d],
ConjugateTranspose[IntegralOp[a_,d_]]->IntegralOp[a,ConjugateTranspose[d]],
ConjugateTranspose[xPartialD[a_,d_]]->xPartialD[ConjugateTranspose[a],Conjugate[d]],(*d scalar*)
ConjugateTranspose[xPartialDu[a_,d_]]->xPartialDu[ConjugateTranspose[a],Conjugate[d]],
ConjugateTranspose[xDot[a_,b_]]->xDot[ConjugateTranspose[b] , ConjugateTranspose[a]],
ConjugateTranspose[a_]:>Map[ConjugateTranspose[#]&,a]/;MemberQ[{List,Plus,Equal,Rule},Head[a]],

ConjugateTranspose[Conjugate[a_]]->Transpose[a],
Conjugate[ConjugateTranspose[a_]]->Transpose[a]
};
tmp=tmp//.sub/.xDot->Dot
];
(* 
ExpandConjugateTranspose[exp_] expands ConjugateTranspose and Conjugate terms in exp_. (Replaces DistributeConjugateCT.) *10Sep2012*)
ExpandConjugateTranspose[exp_]:=
Module[{tmp=exp,tmp1=Null,sub,cOps=Conjugate|ConjugateTranspose},
tmp=tmp//.subDaggerCT;(* superDagger mean ConjugateTranspose *)
sub={
ConjugateTranspose[Conjugate[a_]]->Transpose[a],
Conjugate[ConjugateTranspose[a_]]->Transpose[a] ,
(cOp:cOps)[(op:Sum|xSum)[a_,b__]]->op[cOp[a],b],
(cOp:cOps)[IntegralOp[a_List,d_]]->IntegralOp[a,cOp[d]],
(cOp:cOps)[Integrate[a_,b__List]]->Integrate[cOp[a],b],

Conjugate[Power[a_,b_]]->Power[Conjugate[a],Conjugate[b]],
Conjugate[a_]:>Map[Conjugate[#]&,a]/;MemberQ[Flatten[{List,Plus,Equal,Rule,Times,DerivOps,Dot,xDot}],Head[a]],
ConjugateTranspose[(op:DerivOps)[a_,d_]]->op[ConjugateTranspose[a],Conjugate[d]],(*d scalar*)
ConjugateTranspose[(op:dotOps)[a_,b__]]->op[ConjugateTranspose[op[b]] , ConjugateTranspose[a]],
ConjugateTranspose[a_]:>Map[ConjugateTranspose[#]&,a]/;MemberQ[{List,Plus,Equal,Rule},Head[a]]
};
tmp=tmp//.sub
];
(*
SimpleConjugateTranspose[reals_List,scalars_List,hermitian_List][exp_] expands and simplifies exp_ based upon reals_List,scalars_List,hermitian_List  *10Sep2012*)
SimpleConjugateTranspose[reals_List,scalars_List,hermitian_List][exp_]:=Module[{tmp=exp},
tmp=Expand[tmp];
tmp=ExpandConjugateTranspose[tmp];
tmp=tmp//simpleDot1a[scalars];
tmp=tmp//.Conjugate[a_]:>a/;a\[Element]Reals;
tmp=tmp//.Conjugate[a_]:>a/;ListMemberQ[a,reals];
tmp=tmp//.ConjugateTranspose[a_]:>Transpose[a]/;ListMemberQ[a,reals];
tmp=tmp//.simpleTranspose[scalars];
tmp=tmp//.simpleHermitian[hermitian];
tmp=tmp//simpleDot1a[scalars];
tmp
];

(*Rules for simplifying Hermitian variables.*)
simpleHermitian[hermitian_List]:=
{ConjugateTranspose[a_]:>a/;ListMemberQ[a,hermitian]};
(**)
tuCommutatorExpand::usage="tuCommutatorExpand is Rule[] to replace Commutator expression into Dot[]d notation. *21Mar2016*";
tuCommutatorExpand:={CommutatorP->ACommutator,CommutatorM->MCommutator};
commutatorDot:=tuCommutatorExpand;(*Compatibility*)

tuCommutatorSimplify::usage="tuCommutatorSimplify[constant_List:{}][exp_] expands and simplify CommutatorM|P in exp_. *12Oct2015*7Apr2018*";
tuCommutatorSimplify[constant_List:{}][exp_]:=Module[{tmp=exp,tmp1,cOp=CommutatorM|CommutatorP,$const},
$const[a_]:=tuMemberQ[a,constant]||NumericQ[a];
While[tmp1=!=tmp,
tmp1=tmp;
xPrint["tmp:  ",tmp];
tmp=tmp/.(op:cOp)[a_,b_]:>op[Expand[a],Expand[b]];
tmp=tmp//.(op:cOp)[a_+a1_,b_]:>op[a,b]+op[a1,b];
tmp=tmp//.(op:cOp)[a_,b_+b1_]:>op[a,b]+op[a,b1];
tmp=tmp//.(op:cOp)[a_  a1_,b_]:>a  op[a1,b]/;$const[a];
tmp=tmp//.(op:cOp)[a_  ,b_ b1_]:>b  op[a,b1]/;$const[b];
tmp=tmp//.(op:CommutatorP)[a_  ,b_]:>2 a  b/;$const[a]||$const[b];
tmp=tmp//.(op:CommutatorM)[a_  ,b_]:>0/;$const[a]||$const[b];
tmp=tmp//.(op:cOp)[(ss:(Sum|xSum))[a_,b_],c_]->ss[op[a,c],b];
tmp=tmp//.(op:cOp)[c_,(ss:(Sum|xSum))[a_,b_]]->ss[op[c,a],b];

tmp=tmp//.(cop:CommutatorM)[a_ ,(dop:dotOps)[b_ ,b1__]]:>dop[cop[a,b],b1]+dop[b,cop[a,dop[b1]]];
tmp=tmp//.(cop:CommutatorM)[(dop:dotOps)[a_ ,b__],b1_]:>dop[a,cop[dop[b],b1]]+dop[cop[dop[a],b1],b];

tmp=tmp/.(cop:CommutatorM)[a_,a_]->0;
tmp=tmp/.(cop:CommutatorP)[a_,b_]:>cop[b,a]/;OrderedQ[{b,a}];
tmp=tmp/.(cop:CommutatorM)[a_,b_]:>-cop[b,a]/;OrderedQ[{b,a}]

];
tmp
];
simpleCommutator[constant_List:{}][exp_]:=tuCommutatorSimplify[constant][exp];(*Compatibility*)

tuCommutatorSolve::usage="tuCommutatorSolve[nterm_Integer][commutator_] Solves for CommutatorM|CommutatorP Rules where nterm_Integer select the term; 1\[Rule]Solve for first term in commutator. If commutator is not a Rule then an expression is output with the commutator_ is used in the solution. *6May2016*";Clear[tuCommutatorSolve]
tuCommutatorSolve[nterm_Integer:1][commutator_]:=Module[{$,$0=commutator,term},
$=$0/.tuCommutatorExpand;
If[Head[commutator]===Rule,
term=If[nterm==1,Apply[Dot,$0[[1]]],Apply[Dot,Reverse[$0[[1]]]]];xPrint[term];
$=tuRuleSolve[$,term]//First,
term=If[nterm==1,Apply[Dot,$0],Apply[Dot,Reverse[$0]]];xPrint[term];
$=(tuRuleSolve[$->0,term]//First);
$[[2]]=$[[2]]+If[nterm==1,1,-1]$0];
$
];

tuCommutatorForm::usage="tuCommutatorForm Rules for combining sum of two terms into either CommutatorM|CommutatorP if possible.  Used in combination: tuRepeat[{tuCommutatorForm,tuOpSimplify[Dot]},{tuCommutatorSimplify[]},1]. *1Sep2016*";
tuCommutatorForm:={
tt:((sa_:1) a_ .a1_+(sb_:1) a1_ .a_) :>If[sa==-sb,(sa a.a1 +sb (CommutatorM[a1,a] +a.a1)),If[sa==sb,(sa a.a1 +sb (CommutatorP[a1,a] -a.a1)),tt]]
};

(*
jacobiID[a_,b_,c_] generates Jacobi identity form from a_,b_,c_. *25Nov2013*)
jacobiID[a_,b_,c_]:=Module[{$aa,$bb,$cc,$p,$t},
$t=CommutatorM[$aa,CommutatorM[$bb,$cc]];
$p=Permute[{$aa,$bb,$cc},AlternatingGroup[3]];
$p=Map[Thread[#->{a,b,c}]&,$p];
$p=Apply[Plus,Map[$t/.#&,$p]];
$p
]


(* ::Input::Initialization:: *)
"e[] == unit vector.";
(*Distributes pair operator op_ in expression op_.A.op_ over each term in exp_, e.g.,
op_.A B.op_->op_.A.op_.op_.B.op_ *)
ExpandPairOp[op_,exp_]:=Module[{tmp=exp,tmp1},
While[tmp1=!=tmp,
tmp1=tmp;
tmp=tmp/.{(*Odd that //. yields different results.*)
DotExpand,
Dot[op,b_ c_,op]:>Dot[op,b,op,op,c,op]/;FreeQ[b,op]&&FreeQ[c,op],
Dot[op,b_,c_,op]:>Dot[op,b,op ,op,c,op]/;FreeQ[b,op]&&FreeQ[c,op]
};
tmp=tmp//.simpleDot;
];
tmp
];

(*NOTE: DotExpand works for only simple sums.  Need to precede it with ExpandAll. *)
DotExpand={(op:Dot|xDot)[a___,b_+c_,d___]:>op[a,b,d]+op[a,c,d]};
(**)

(*Keeps under Dot items in clist. Usage  expression/.Dot[a___]\[RuleDelayed]dotKeep[{ keep_list }]  [a].  Returns  nokeep_list Dot[ keep_list ]*)
(* Newer version. 2010.2.16 *)
DotKeep1[clist_,seq_]:=
Module[{tmp=seq,i,j,member,dot={},times={1},test,DEBUG=0},
tmp=tmp/.Times->Dot/.simpleDot;
If[DEBUG>0,Print["DotKeep< ",clist," : ",tmp," ",Length[tmp]]];
For[i=1,i<=Length[tmp],i++,
test=tmp[[i]];
If[DEBUG>1,Print["DotKeep: ",test," : ",clist]];
member=False;
If[MemberQ[clist,test],member=True];
For[j=1,j<=Length[clist],j++,
If[! FreeQ[test,clist[[j]]],member=True]
];
If[ member,
AppendTo[ dot,test],
AppendTo[ times,test]
];
If[DEBUG>1,Print["DotKeep: ",dot,times]];
];
tmp=1;
If[Length[times]>0,
tmp=Apply[Times,times]];
If[Length[dot]>0,
tmp=tmp Apply[Dot,dot]];
If[DEBUG>0,Print["DotKeep>> ",tmp]];
tmp
];

(**)
Clear[tuDotTermLeft];
tuDotTermLeft::usage="tuDotTermLeft[term_,block_List:{},commuteRule_List:{},scalars_List:{}] [ exp_ ] commutes term_ to the left in dotOps expressions in exp_. block_List contains terms that block the movement of term_.  commuteRule_List contains Rule[]s that are used when terms are commuted.  scalars_List lists scalars that are used in tuOpSimplify. NOTE: all dotOps need to be the same in expressions. *6Sep2018*";
tuDotTermLeft[term_,block_List:{},pairRule_List:{},scalars_List:{}][exp_]:=Module[{tmp=exp,tmp1,$,cnt=0,$pair,$newpair},
While[tmp1=!=tmp&&cnt++<20,
tmp1=tmp;
tmp=tmp/.dd0:(dd:dotOps)[a0___,Shortest[a_] ,term,b0___] :>If[ListFreeQ[a,block],
$pair=dd[a,term];
$newpair=$pair/.pairRule;
If[$pair==$newpair,(*no pairRule*)
$newpair=Reverse[$pair]];(*default*)
dd[a0,$newpair,b0],
dd0
];
tmp=tmp//Expand//tuOpDistributeF[dotOps]//tuOpSimplifyF[dotOps,scalars];
xPrint[tmp];
];
tmp
];
(*
TEST
$scc=tuGammaIdentities//tuRuleSelect[T[\[Gamma],"d",{a_}].T[\[Gamma],"d",{b_}],{\[Nu]}]//tuPatternRemove//(#/.\[Nu]\[Rule]k/.Dot\[Rule]CenterDot&)//tuAddPatternVariable[\[Mu]]
T[\[Gamma],"d",{i}]\[CenterDot]T[\[Gamma],"d",{j}]\[CenterDot]T[\[Gamma],"d",{k}]\[CenterDot]T[\[Gamma],"d",{l}]
%//tuDotTermLeft[T[\[Gamma],"d",{k}],{T[\[Gamma],"d",{i}]},$scc]*)
Clear[tuDotTermRight]
tuDotTermRight::usage="tuDotTermRight[term_,block_List:{},commuteRule_List:{},scalars_List:{}][exp_] commutes term_ to the right in dotOps expressions in exp_. block_List contains terms that block the movement of term_.  commuteRule_List contains Rule[]s that are used when terms are commuted.  scalars_List lists scalars that are used in tuOpSimplify. NOTE: all dotOps need to be the same in expressions. *6Sep2018*";
tuDotTermRight[term_,block_List:{},pairRule_List:{},scalars_List:{}][exp_]:=Module[{tmp=exp,tmp1,$,cnt=0,$pair,$newpair},
While[tmp1=!=tmp&&cnt++<20,
tmp1=tmp;
tmp=tmp/.dd0:(dd:dotOps)[a0___,term,Shortest[a_] ,b0___] :>If[ListFreeQ[a,block],
$pair=dd[term,a];
$newpair=$pair/.pairRule;
If[$pair==$newpair,(*no pairRule*)
$newpair=Reverse[$pair]];(*default*)
dd[a0,$newpair,b0],
dd0
];
tmp=tmp//Expand//tuOpDistributeF[dotOps]//tuOpSimplifyF[dotOps,scalars];
xPrint[tmp];
];
tmp
];
(*
TEST
$scci=tuGammaIdentities//tuRuleSelect[T[\[Gamma],"d",{a_}].T[\[Gamma],"d",{b_}],{\[Nu]}]//tuPatternRemove;
$scci={$scci/.\[Mu]\[Rule]\[Nu]//tuRuleSolveF[T[\[Gamma],"d",{\[Nu]}].T[\[Gamma],"d",{\[Nu]}]],$scci/.\[Mu]\[Rule]i}/.Dot\[Rule]CenterDot//Flatten//tuAddPatternVariable[\[Nu]]
T[\[Gamma],"d",{i}]\[CenterDot]T[\[Gamma],"d",{j}]\[CenterDot]T[\[Gamma],"d",{i}]\[CenterDot]T[\[Gamma],"d",{l}]
%//tuDotTermRight[T[\[Gamma],"d",{i}],{T[\[Gamma],"d",{x}]},$scci,{T[g,"dd",{_,_}]}]*)


MoveDotLeft[term_,block_List][exp_Dot]:=tuDotTermLeft[term,block][exp];
MoveDotRight[term_,block_List][exp_Dot]:=tuDotTermRight[term,block][exp];

GammaRight[exp_,gamma_]:=(* Moves gamma_ in Dot[] expression to the right until the end or the term disappears.  Usage: expression/.Dot[a__]:> GammaRight[a].  Returns replacement for Dot[]. *)
Module[{ tmp=exp,tmp1,out,gpos,Ngpos,igpos,indu=Null,indd=Null,pair,DEBUG=0},
If[DEBUG>0,Print["GammaRight: ",tmp," : ",gamma]];
While[tmp1=!=tmp,
tmp1=tmp;
indu=gamma/.\[Gamma]@u[a_]->a;
indd=gamma/.\[Gamma]@d[a_]->a;
tmp=tmp/.Dot[a___,gamma,b_,c___]:>Dot[a,CommuteG[gamma,b],c]/;(MemberQ[{b},\[Gamma]@u[_]||MemberQ[{b},\[Gamma]@d[_]]]);
tmp=Expand[tmp]/.simpleDot//Expand;

If[DEBUG>0,Print["GammaRight>  ",tmp]];
tmp=tmp/.Dot->xDot;
tmp=tmp//.xDot[a__]:>DotKeep1[{\[Gamma]@d[_],\[Gamma]@u[_]},{a}];
tmp=Expand[tmp]/.simpleDot;
tmp=tmp//.{Dot[a___,\[Gamma]@d[b_],\[Gamma]@u[b_],c___]:>dim[x]Dot[a,c],Dot[a___,\[Gamma]@u[b_],\[Gamma]@d[b_],c___]:>dim[x] Dot[a,c]};

If[DEBUG>0,Print["GammaRight>> ",tmp]];
];
tmp
];
GammaRight[exp_,gamma_Tensor]:=(* Moves gamma matrix gamma_ in expression with Dot[,gamma_,\[Gamma],\[Gamma]...]'s through \[Gamma]'s to the far right or until it disappears.  
Usage: GammaLeft[exp_,gamma_].  Returns exp_ with Dot[,gamma_,...]'s replaced with Dot[,gamma_,] where gamma_ is moved to the right. *)
Module[{ tmp=exp,tmp1,gammaT,isgamma,out,DEBUG=0,mname="GammaRight"},
IfDEBUG[mname,DEBUG>0,{tmp,gamma},"{tmp,gamma}"];
gammaT=Apply[List,gamma];
isgamma=Count[{gamma},Tensor[\[Gamma],{_},{_}]]==1;
While[tmp1=!=tmp&&isgamma,
tmp1=tmp;
tmp=tmp/.Dot[a___,gamma,b_,c___]:>Dot[a,CommuteG[gamma,b],c]/;Count[{b},Tensor[\[Gamma],{_},{_}]]==1;
tmp=Expand[tmp]//.DotExpand//.simpleDot//Expand;
];
tmp
];


GammaLeft[exp_,gamma_Tensor]:=(* Moves gamma matrix gamma_ in expression exp_ with Dot[,\[Gamma],\[Gamma],gamma_,...]'s through \[Gamma]'s to the far left or until it disappears.  
Usage: GammaLeft[exp_,gamma_].  Returns exp_ with Dot[,gamma_,...]'s replaced with Dot[,gamma_,] where gamma_ is moved to the left. *)
Module[{ tmp=exp,tmp1,gammaT,isgamma,DEBUG=0,mname="GammaLeft"},
IfDEBUG[mname,DEBUG>0,{tmp,gamma},"{tmp,gamma}"];
gammaT=Apply[List,gamma];
isgamma=Count[{gamma},Tensor[\[Gamma],{_},{_}]]==1;
While[tmp1=!=tmp&&isgamma,
tmp1=tmp;
tmp=tmp/.Dot[a___,b_,gamma,c___]:>Dot[a,CommuteG[b,gamma],c]/;Count[{b},Tensor[\[Gamma],{_},{_}]]==1;
tmp=Expand[tmp]//.DotExpand//.simpleDot//Expand;
];
tmp
];

GammaRight[gamma_Tensor][exp_]:=(* Moves gamma matrix gamma_ in expression exp_ with Dot[,gamma_,\[Gamma],\[Gamma],...]'s through \[Gamma]'s to the far right or until it disappears.  
Usage: GammaRight[gamma_][exp_].  Returns exp_ with Dot[,gamma_,...]'s replaced with Dot[...,gamma_,] where gamma_ is moved to the right through other gamma's. *)
Module[{ tmp=exp,tmp1,gammaT,isgamma,DEBUG=0,mname="GammaRight"},
IfDEBUG[mname,DEBUG>0,{tmp,gamma},"{tmp,gamma}"];
gammaT=Apply[List,gamma];
isgamma=Count[{gamma},Tensor[\[Gamma],{_},{_}]]==1;
While[tmp1=!=tmp&&isgamma,
tmp1=tmp;
tmp=tmp/.Dot[a___,gamma,b_,c___]:>Dot[a,CommuteG[gamma,b],c]/;Count[{b},Tensor[\[Gamma],{_},{_}]]==1;
tmp=Expand[tmp]//.DotExpand//.simpleDot//Expand;
];
tmp
];

GammaLeft[gamma_Tensor][exp_]:=(* Moves gamma matrix gamma_ in expression exp_ with Dot[,\[Gamma],\[Gamma],gamma_,...]'s through \[Gamma]'s to the far left or until it disappears.  
Usage: GammaLeft[exp_,gamma_].  Returns exp_ with Dot[,gamma_,...]'s replaced with Dot[,gamma_,] where gamma_ is moved to the left. *)
Module[{ tmp=exp,tmp1,gammaT,isgamma,DEBUG=0,mname="GammaLeft"},
IfDEBUG[mname,DEBUG>0,{tmp,gamma},"{tmp,gamma}"];
gammaT=Apply[List,gamma];
isgamma=Count[{gamma},Tensor[\[Gamma],{_},{_}]]==1;
While[tmp1=!=tmp&&isgamma,
tmp1=tmp;
tmp=tmp/.Dot[a___,b_,gamma,c___]:>Dot[a,CommuteG[b,gamma],c]/;Count[{b},Tensor[\[Gamma],{_},{_}]]==1;
tmp=Expand[tmp]//.DotExpand//.simpleDot//Expand;
];
tmp
];

(* Commutes \[Gamma] matrices g1_, g2_, Returns -g2_.g1_+2 \[Eta]__[,] *)
CommuteG[g1_Tensor,g2_Tensor]:=
Module[{tmp,g1T,g2T,iup,idown,is5,twog,gtmp=1,out,DEBUG=0,mname="CommuteG"},
IfDEBUG[mname,DEBUG>0,{g1,g2},"{g1,g2}"];
g1T=Apply[List,g1];
g2T=Apply[List,g2];
iup=Flatten[{g1T[[2]],g2T[[2]]}];
idown=Flatten[{g1T[[3]],g2T[[3]]}];
is5=!FreeQ[{iup,idown},5];
IfDEBUG[mname,DEBUG>0,{iup,idown},"{iup,idown}"];
twog=(Count[{g1},Tensor[\[Gamma],{_},{_}]]+Count[{g2},Tensor[\[Gamma],{_},{_}]])==2;
Which[!twog,out=g1.g2 (* not 2 \[Gamma]'s return\[Rule]no change *),
twog&&g1===g2,
out=If[is5,1,Tensor[\[Eta],iup,idown]],
twog,
gtmp=If[is5,0,Tensor[\[Eta],iup,idown]];
out=-g2.g1+2gtmp
]
];

(*
Sorts Grassmanian variables {a_,b_} in Dot[a_,b_] expression..
Usage: exp/.Dot[a_,b_]\[RuleDelayed]GrassmanDotSort[a,b].*)
GrassmanDotSort[a_,b_]:=Module[{order=Order[a,b],tmp=Sort[{a,b}]},
If[order===0,order=1];
Apply[Dot,tmp]order
];
(*
Dot product of vectors {a_,b_} of Grassmanian variables. *)
GrassmanDot[a_,b_]:=Module[{tmp,tmpa,tmpb},
If[Dimensions[a][[1]]==1&&Dimensions[b][[2]]==1&&Dimensions[a][[2]]==Dimensions[b][[1]],
tmpa=Flatten[a];
tmpb=Flatten[b];
tmpa=MapThread[Dot,{tmpa,tmpb}]/.simpleDot;
tmp=tmpa/.Dot[c_,d_]:>GrassmanDotSort[c,d];
Apply[Plus,tmp]
]
];

(*
seqLabelTerm[matrix_,seq_] labels matrix_ elements with seq$[seq_][element] where matrix is MatrixQ, ArrayQ, or none.  This routine is used in NonCommutativeDot[] where seq_ is the arguement position of the matrix_ in ncDot[].  NOTE: label seq$ is global.  *1Apr2014*)
seqLabelTerm[matrix_,seq_]:=Module[{tmp=matrix,dim},
If[MatrixQ[matrix],
dim=Dimensions[tmp,2];
dim=Array[List,dim]//Flatten[#,1]&;
tmp=MapAt[seq$[seq][#]&,tmp,dim],
If[ArrayQ[matrix],
dim=Dimensions[tmp,2][[1]];
dim=Array[List[List[#]]&,dim]//Flatten[#,1]&;Print[dim,tmp];
tmp=MapAt[seq$[seq][#]&,tmp,dim],
tmp=seq$[seq][tmp]
]
]
];
(*
NonCommutativeDot[exp_ncDot] takes ncDot[] expressions and performs Dot[] operations among is terms so that the elements of each resulting term have the same ordering as in exp_ncDot.  NOTE: all Times[]->Dot[].  Usage: $exp/.dd:ncDot[__]:>NonCommutativeDot[dd]  *1Apr2014*)
NonCommutativeDot[exp_ncDot]:=Module[{tmp=exp},
tmp=MapIndexed[seqLabelTerm[#1,#2[[1]]]&,tmp];
tmp=tmp/.ncDot->Dot;
tmp=tmp/.Times->Dot;
tmp=tmp/.seq$[_][a_]->a;
tmp
]

(*Example of routine that moves the left arguement in pair_List contained in exp_ to the right until they are adjacent alternating arguement pairs each tranposition.*)
MovePairRight[pair_List][exp_]:=Module[{tmp=exp,tmpv=pair,tmpx1,x1,x2,tmpp},
While[(tmpp=Position[tmp,Apply[Alternatives,tmpv]];(x2=tmpp[[2,1]])-(x1=tmpp[[1,1]])>1),
tmpx1=Extract[tmp,{x1}];
If[tmpx1 === tmpv[[1]],tmpx1=tmpv[[2]],If[tmpx1 === tmpv[[2]],tmpx1=tmpv[[1]]]];
tmp=Permute[tmp,Cycles[{{x1,x1+1}}]];
tmp=ReplacePart[tmp,{x1+1}->tmpx1];
];
tmp
]


(* ::Input::Initialization:: *)
(*Returns Rule[First[mn_]\[Rule]_] for exp_\[Equal]0 for pair mn_. e.g., ZeroMN[I 2 \[Pi] m t/\[Beta],{m,n}] => m->0*)
ZeroMN[exp_,mn_]:=Module[{tmp},
tmp=Solve[exp==0,First[mn]];
If[Length[First[tmp]]>0,
tmp=First[First[tmp]],
tmp=Solve[exp==0,Last[mn]];
If[Length[First[tmp]]>0,
tmp=First[First[tmp]],
tmp=exp;
];
];
tmp
];
(* Returns xDiscreteDelta[First[mn_,_] for exp_\[Equal] 0 for pair mn_={m,n}. e.g., ZeroMN[I 2 \[Pi] (m-n) t/\[Beta],{m,n}]->xDiscreteDelta[First[m,n]]  *)
ZeroMNDiscreteDelta[exp_,mn_]:=Module[{tmp,DEBUG=0},
tmp=ZeroMN[exp,mn];
If[DEBUG>0,Print["ZeroMNDiscreteDelta: ",{exp,mn,tmp,Head[tmp]}]];
If[Head[tmp]===Rule,
tmp=tmp/.Rule->xDiscreteDelta,
tmp=exp
];
tmp
];

(*Returns \[Delta]uu[First[mn_,_], DiscreteDelta[] for exp_\[Equal] 0 for pair mn_={m,n}. e.g., ZeroMN[I 2 \[Pi] (m-n) t/\[Beta],{m,n}] *)
ZeroMN\[Delta][exp_,mn_]:=Module[{tmp,DEBUG=0,mname="ZeroMN\[Delta]"},
tmp=ZeroMN[exp,mn];
IfDEBUG[mname,DEBUG>0,{exp,mn,tmp},""];
If[Head[tmp]===Rule,
tmp=tmp/.Rule->\[Delta]uu,
tmp=exp
];
tmp
];
tuSumGatherR::usage="tuSumGatherR Rules for consolidating Sum,xSum expressions.  Returns expression with all Sum[]s replaced by xSum[]s. *27Aug2018*";
tuSumGatherR:={Sum->xSum,
xSum[xSum[a_,b__],c__]:>xSum[a,Apply[Sequence,Sort[{b,c}]]],
d_ xSum[a_,b__]:>xSum[Expand[d a],b],
(dd:dotOps)[d1___ ,xSum[a_,b__],d2___]->xSum[dd[d1,a,d2],b],
xSum[a_,b__]+xSum[c_,b__]->xSum[a+c,b]
}(*
TEST
$=(Sum[a[i],{i,m}]+f\[CenterDot]Sum[b[i],{i,m}]\[CenterDot]d)Sum[dd[j],{j,n}]
$//.tuSumGatherR*)

(*Consolidation Rule[]'s for IntegralOp *)
GatherIntOpSubs=subGatherIntOp={IntegralOp[a_List,IntegralOp[b_List,c_]]:>IntegralOp[{a, b},c],d_ IntegralOp[a_,b_]:>IntegralOp[a,Expand[d b]],
IntegralOp[a_,b_]+IntegralOp[a_,c_]->IntegralOp[a,c+b]
};

Clear[tuIntegralGather]
tuIntegralGather::usage="tuIntegralGather[EXP_] gathers expressions with xIntegral[] under the integral if possible. Applies tuIntegralGatherR repeatedly with tuRepeat[] since ReplaceRepeated[tuIntegralGatherR] does not seem to work in some cases. *1Apr2018*";
tuIntegralGather:=tuRepeat[{tuIntegralGatherR}];

tuIntegralGatherR::usage="tuIntegralGatherR are Rule[]s  for consolidating expressions with xIntegral's. BUG: does not work in all cases. *10Mar2016**1Apr2018*";

tuIntegralGatherR:={
Conjugate[xIntegral[a_,b_]]->xIntegral[Conjugate[a],b],
ConjugateTranspose[xIntegral[a_,b_]]->xIntegral[ConjugateTranspose[a],b],
xIntegral[a_,b_]:>a (b[[3]]-b[[2]])/;NumericQ[a]&&Head[b]===List&&Length[b]===3,
xIntegral[a_,b__]:>xIntegral[a,Apply[Sequence,Sort[{b}]]],

(dd:productOps)[a___,xIntegral[ia_,ib_],b___]:>xIntegral[dd[a, ia, b],ib],

(dd:productOps)[xIntegral[a_,d_] , xIntegral[b_,c_] ]:>xIntegral[dd[a,  b],d,c],

xIntegral[b_,a__]+xIntegral[c_,a__]->xIntegral[c+b,a],(*??Why needed if next*)
(c1_:1)^(n1_:1) xIntegral[b_,a__]+(c2_:1)^(n2_:1) xIntegral[c_,a__]:>xIntegral[c2  ^n2 c+c1^n1 b,a],

xIntegral[(d_:1)  xIntegral[b_,c_],a_  ]:>xIntegral[d b, c ,a]
};
(*EG
xIntegral[3,x,{w,a,b},y]//tuIntegralGather
xIntegral[a,b] \[CenterDot](A1 xIntegral[a1,b1])//tuIntegralGather
xIntegral[aa \[CenterDot] xIntegral[a1 a2,b]\[CenterDot] bb,b1]//tuIntegralGather
BB xIntegral[aa,b]-AA xIntegral[a1,b]//tuIntegralGather*)

(*
SwitchOps[op1_,op2_][exp_] switches positions of op1_,op2_ in exp_.  op1_[op2_[arg2,parm2],parm1]->op2_[op1_[arg2,parm1],parm2] *3Oct2014*)SwitchOps[op1_,op2_][exp_]:=Module[{tmp=exp},
If[op1===IntegralOp &&op2===IntegralOp,
tmp=tmp/.IntegralOp[a1_,IntegralOp[a2_,b_]]->IntegralOp[a2,IntegralOp[a1,b]],
If[op1===IntegralOp,
tmp=tmp/.IntegralOp[intvars_,op2[arg2_,parms2___]]->op2[IntegralOp[intvars,arg2],parms2],
If[op2===IntegralOp,
tmp=tmp/.op1[op2[intvars_,arg_],parms1___]->op2[intvars,op1[arg,parms1]]],
tmp=tmp/.op1[op2[arg2_,parms2___],parms1___]->op2[op1[arg2,parms1],parms2]];
];
tmp
];

tuSwitchDerivOpsIntegralOp::usage="tuSwitchDerivOpsIntegralOp Rule for moving DerivOps into xIntegral|IntegralOp *16Jan2017*";
tuSwitchDerivOpsIntegralOp:={(dop:DerivOps)[IntegralOp[a_,b_],c_]->IntegralOp[a,dop[b,c]],
(dop:DerivOps)[xIntegral[a_,b_],c_]->xIntegral[dop[a,c],b]
};
DerivOpsInIntegralOp:=tuSwitchDerivOpsIntegralOp;
switchDerivOpsIntegralOp:=tuSwitchDerivOpsIntegralOp;
(*
IntegralOp to Integrate Rules.  *18Sep2012*)
subxIntegrate:=IntegralOp[a_,b_]:>xIntegral[b,Apply[Sequence,Map[If[Length[#]==3,#,First[#]]&,a]]];
subxIntegrateOne:=IntegralOp[a_,b_]:>IntegralOp[Most[a],xIntegral[b,Last[a]]];
subIntegralOp:=xIntegral[a_,b__]:>IntegralOp[{b},a];
subIntegrate:=xIntegral[a_,b__]:>Integrate[a,b];
addAssumptions[assume_]:=xIntegral[a_,b__]->xIntegral[a,b,Assumptions->assume];
subIntegrateAssume[assume_]:=xIntegral[a_,b__]->Integrate[a,b,Assumptions->assume];
toIntegralOp=Integrate[a_,b__]->IntegralOp[If[Depth[{b}]<3,{{b}},{b}],a];
(**)
tuIntegralAssumptions::usage="tuIntegralAssumptions[assume_] Rule to add Assumptions->assume_ to xIntegral terms *2May2018*";
tuIntegralAssumptions[assume_]:=xIntegral[a_,b__]->xIntegral[a,b,Assumptions->assume];
(**)
tuIntegrate::usage="tuIntegrate[assume_][exp_] applies Integrate[] to tuIntegral[] terms in exp_.   Assumptions may be introduced by setting assume_ *21Feb2015"; 
tuIntegrate[assume_:{}][exp_]:=Module[{$=exp,xIntegral},
$=$/.tuIntegral[a_,b_]:>xIntegral[b,Apply[Sequence,Map[If[Length[#]==3,#,First[#]]&,a]]];
If[Length[assume]>0,$=$/.
xIntegral[a_,b__]->xIntegral[a,b,Assumptions->assume]];
$=$/.xIntegral->Integrate
];

(* 
ExchangexPartialDSum[exp_] switches (dop:DerivOps)[(op:sum)[a_,c__],b_]\[RuleDelayed]op[dop[a,b],c] (added DerivOps) *20Oct2013*)
ExchangexPartialDSum[exp_]:=Module[{tmp=exp,tmp1,sum=Sum|xSum,DEBUG=0},
If[DEBUG>0,Print["ExchangePartialDSum: ",tmp]];
(*Partiald does not substitute, change to xPartialD *)
tmp=tmp/.distributePartialD;
tmp=tmp//.(dop:DerivOps)[(op:sum)[a_,c__],b_]:>op[dop[a,b],c];(*
tmp=tmp/.xPartialD[xSum[a_,c__],b_]\[RuleDelayed]xSum[xPartialD[a,b],c];*)
tmp
];

(*Contracts xDiscreteDelta[n_,m_] in xSum.  Eliminates on xSum[]. 
3.1.2010*)
SumDiscreteDelta[exp_]:=Module[{tmp,tmp1=Null,pos,arg,index,sumvar,xsum,xdelta,posd,n,m,repl={},sub,i,DEBUG=0},
tmp=exp//DistributeSum;
While[tmp=!=tmp1,
If[DEBUG>0,Print["SumDiscreteDelta: ",tmp]];
tmp1=tmp;
pos=Position[tmp,xSum[__]];
For[i=1,i<=Length[pos],i++,
xsum=Extract[tmp,pos[[i]]];
{arg,index}=Apply[List,xsum];
If[Head[index]===List,
sumvar=First[index],sumvar=index];

If[DEBUG>0,Print["SumDiscreteDelta{arg,index}: ",{arg,index}]];

xdelta=Extract[arg,posd=Position[arg,xDiscreteDelta[__]]]//First;
sub=Null;
If[!FreeQ[xdelta,sumvar],
If[Length[xdelta]==2,
sub=Solve[Apply[Equal,xdelta],sumvar][[1]];
];
If[Length[xdelta]==1,
sub=Solve[First[xdelta]==0,sumvar][[1]];
];
];

If[DEBUG>0,Print["SumDiscreteDelta{Length[xdelta],xdelta,sub}: ",{Length[xdelta],xdelta,sub}]];
If[DEBUG>0,Print["SumDiscreteDelta{sub,arg}: ",{sub,arg}]];

If[sub=!=Null,arg=arg/.sub/.xDiscreteDelta[__]->1;AppendTo[repl,pos[[i]]->arg]];

If[DEBUG>0,Print["SumDiscreteDelta{index,sub,repl}: ",{index,sub,repl}]];

];
];
tmp=ReplacePart[tmp,repl]
];

(**)
tuExtractIntegrand::usage="tuExtractIntegrand[exp_] returns position\[Rule]integrand Rule of first IntegralOp[a_,b_]|tuIntegral[a_,b_]|xIntegral[a_,b__] found in exp_. Adjustment is made for the arguement postion of the integral arguement list. *8Nov2015*";
tuExtractIntegrand[exp_]:=Module[{pos,tmp},
tmp=tuExtractPositionPattern[IntegralOp[a_,b_]|tuIntegral[a_,b_]|xIntegral[a_,b__]][exp]//First;
If[FreeQ[tmp,Integrate],
{   Append[First[tmp],2]->tmp[[2,2]] },
{   Append[First[tmp],1]->tmp[[2,1]] }
]//First
];
ExtractIntegrandP:=tuExtractIntegrand;

(**)Clear[tuIntegralSimplify]
tuIntegralSimplify::usage="tuIntegralSimplify[keep_:{}][exp_] applies tuIntegralSimplify0[,] to all xIntegral's in exp_ which removes from integrand_ of xIntegral[] terms that are not functions of the integration variables. keep_ is an optional list of variables to keep inside the integral. EG: exp//tuIntegralSimplify  *8Mar2016*" ;
tuIntegralSimplify[keep_:{}][exp_]:=Module[{tmp=exp}, 
tmp=tmp/.xIntegral[a_,b__]:>tuIntegralSimplify0[a,b,keep]
];
tuIntegralSimplify0[integrand_,vars0__,extra_:{}]:=Module[{vars,terms,pick,keep,out,ret},
(*Make list of integration variables where vars is List of Lists.*)
vars=Map[If[Head[#]===List,First[#],#]&,{vars0}];xPrint[vars];
(*Integrand must be a Product of terms to be factorable.*)
ret=If[Head[integrand]===Times,
terms=Apply[List,integrand];xPrint[terms];
pick=Map[tuFreeQ[#,Flatten[{vars,extra}]]&,terms];xPrint[pick];
keep=Apply[Times,Pick[terms,pick,False]];xPrint[keep];
out=Apply[Times,Pick[terms,pick]];xPrint[out];
out xIntegral[keep,vars0],
xIntegral[integrand,vars0]
];
ret/.xIntegral[0,_]->0
];

tuOpMerge::usage="tuOpMerge[op_:xIntegral] Rule for merge nested operator into one *8Mar2016*";
tuOpMerge[op_:xIntegral]:={op[op[a_,b__],c__]->op[a,c,b]};

(*
simpleIntegralOp[vars0_List,integrand_] removes from integrand_ of IntegralOp[] terms that are not functions of the integration variables. 
Usage: exp//.IntegralOp->simpleIntegralOp  *2Oct2014*)
simpleIntegralOp[vars0_List,integrand_]:=Module[{vars,terms,pick,keep,out,ret},
(*Make list of integration variables where vars is List of Lists.*)
vars=Map[{#[[1]]}&,vars0]//Flatten;
(*Integrand must be a Product of terms to be factorable.*)
ret=If[Head[integrand]===Times,
terms=Apply[List,integrand];
pick=Map[ListFreeQ[#,vars]&,terms];
keep=Apply[Times,Pick[terms,pick,False]];
out=Apply[Times,Pick[terms,pick]];
out IntegralOp[vars0,keep],
IntegralOp[vars0,integrand]
];
ret/.IntegralOp[_,0]->0
];

(**)
tuSimpleIntegralOp::usage="tuSimpleIntegralOp[exp_] applies simpleIntegralOp to all IntegralOp's in exp_ which removes from integrand_ of IntegralOp[] terms that are not functions of the integration variables. EG: exp//tuSimpleIntegralOp  *7Jan2015" ;
tuSimpleIntegralOp[exp_]:=Module[{tmp=exp}, 
tmp=tmp/.IntegralOp->simpleIntegralOp
];
tuSimpleIntegralOp[exp_]:=Module[{tmp=exp}, 
tmp=tmp/.IntegralOp[a_,b_]:>(tuIntegralSimplify[b,Apply[Sequence[a]]]/.xIntegral[ii_,vv__]->IntegralOp[{vv},ii]);
];(*UNTESTED*)

(*
IntegrandKeep[vars_List][exp_] simplifies IntegralOp's by moving integrand terms not containing any vars_List (Patterns OK) outside of IntegralOp expression. *13Jun2013*)
IntegrandKeep[vars_List][exp_]:=Module[{tmp,pos,ipos,args,intg,vars0,integrand,terms,pick,keep,out},
(*First IntegralOp Times terms*)
pos=exp//tuExtractPositionPattern[IntegralOp[_,_]];
Do[
{vars0,integrand}=Apply[List,pos[[ipos,2]]];
xPrint[{vars0,integrand}];
(*Integrand must be a Product of terms.*)
If[Head[integrand]==Times,
terms=Apply[List,integrand];
pick=Map[ListFreeQ[#,vars]&,terms];
keep=Apply[Times,Pick[terms,pick,False]];
out=Apply[Times,Pick[terms,pick,True]];
pos[[ipos,2]]=out IntegralOp[vars0,keep]
];
xPrint[{vars0,pos[[ipos,2]]}];
,{ipos,Length[pos]}
];
ReplacePartTU[exp,pos]
];

(*
IntegrandWithout[vars_List] simplifies IntegralOp's by moving integrand terms containing any vars_List (Patterns OK) to outside of IntegralOp expression. Moves NumericQ[] terms outside IntegralOp.  *13Jun2013*)
IntegrandWithout[vars_List][exp_]:=Module[{tmp,pos,ipos,args,intg,vars0,integrand,terms,pick,keep,out},
(*First IntegralOp Times terms*)
pos=exp//tuExtractPositionPattern[IntegralOp[_,_]];
Do[
(*Only applies to first IntegralOp encountered.*)
{vars0,integrand}=Apply[List,pos[[ipos,2]]];
(*Integrand must be a Product of terms.*)
If[Head[integrand]==Times,
terms=Apply[List,integrand];
pick=Map[ListFreeQ[#,vars]&&!NumericQ[#]&,terms];
keep=Apply[Times,Pick[terms,pick,True]];
out=Apply[Times,Pick[terms,pick,False]];
pos[[ipos,2]]=out IntegralOp[vars0,keep]
];
xPrint[{vars0,pos[[ipos,2]]}];
,{ipos,Length[pos]}
];
ReplacePartTU[exp,pos]
];

(**)
tuIntegralSwitchVar::usage="tuIntegralSwitchVar[rule_Rule][exp_]\[IndentingNewLine]switches integration variables specified by rule_Rule (systax::newvar->exp[old var]) in all xIntegral terms in exp_ so xIntegral[integrand,currentVar]->xIntegral[jacobian integrand,newVar] Only good with Integrals with single variables *7Mar2016**18Nov2017*";
tuIntegralSwitchVar[rule_Rule][exp_]:=Module[{$=exp},
$/. ii:xIntegral[_,_]:>tuOpIndependentVarActivate[][Inactive[tuIntegralSwitchVar0][rule][ii]]
];
tuIntegralSwitchVar0::usage="tuIntegralSwitchVar0[rule_Rule][exp_xIntegral]\[IndentingNewLine]switches integration variables in exp_ specified by rule_Rule (systax::newvar->exp[old var]) so xIntegral[integrand,currentVar]->xIntegral[jacobian integrand,newVar] Only works with Integrals with single variables *18Nov2017*";
tuIntegralSwitchVar0[rule_Rule][exp_xIntegral]:=Module[{$=exp,$int,$newvar,$sivar,$ivar,$ivar0,dd},
$int=exp;
$ivar0=$ivar=$int[[2]];
$ivar=Flatten[{$ivar}]//First;xPrint[$ivar0," ",$ivar,"::",$int,"::",rule];
If[tuHasNoneQ[rule,$ivar],Return[exp]];
(*switch to new variable*)
$newvar=rule[[1]];
$sivar=tuRuleSolve[rule,$ivar]//Last;
$jacob=$sivar;
$jacob=tuRuleSolve[$jacob,$ivar]//First;
$jacob=dd[#]&/@$sivar//tuDExpandF[dd];xPrint[$jacob];
$jacob=$jacob[[2]]/.dd[$newvar]->1/.dd[_]->0;
(*add jacobian to integrand *)
$int=$int//tuRuleApply[$sivar];
$int[[1]]=$int[[1]]$jacob;
$int[[2]]=$newvar;xPrint[$jacob," ",$int];
If[Head[$ivar0]===List,(*adjust limits*)
$ivar0[[2;;3]]=($ivar->#&/@$ivar0[[2;;3]])/.$sivar;
$ivar0[[2;;3]]={#[[2]]&/@(tuRuleSolve[{#},$newvar]&/@$ivar0[[2;;3]]//Flatten)}//Flatten;
$ivar0[[1]]=$newvar;
$int[[2]]=$ivar0;
];
$int
];
(*EG: tuIntegralSwitchVar0[z\[Rule]Exp[x]][xIntegral[a x,{x,2,3}]]*)
(*EG: tuIntegralSwitchVar[z\[Rule]Exp[x]][AA xIntegral[a x,{x,2,3}]]*)
(*EG: tuIntegralSwitchVar[y\[Rule]Subscript[x, +]fn[x]][xIntegral[a x Subscript[x, w],{x,A,B}]]*)

(*
switchIntegralOpVariable[dRule_Rule][exp_IntegralOp] switches integration variables specified by dRule_Rule ( systax: d[currentVar]->jacobian d[newVar] ) so IntegralOp[{{currentVar}},integrand]->IntegralOp[{{newVar}},jacobian integrand] Requires varlist->{{x},{y},...}  *20Nov2013*)
switchIntegralOpVariable[dRule_Rule][exp_IntegralOp]:=Module[{tmp,tmp1,varlist,var1,var2,jacob},
tmp=exp;
var1=dRule[[1,1]];
tmp1=dRule[[2]]//tuExtractPositionPattern[ d[_]];
var2=tmp1[[1,2,1]];
jacob=Delete[dRule[[2]],tmp1[[1,1]]];
tmp=tmp/.IntegralOp[{a0___,a_,a1___},b_]:>IntegralOp[{a0,{var2},a1},b jacob]/;a==={var1};
tmp
];

(**)
tuIntegrateOne::usage="tuIntegrateOne[$parm_,$options_:{}][$exp_] applies Integrate[]s parm_ of xIntegral[] in exp_. Integrate $options_ are optional. *4Jan2015*3Feb2018*";
tuIntegrateOne[$parm_,$options_:{}][$exp_]:=Module[{$=$exp,$s},
$s=xIntegral[a_,b__]:>Fold[xIntegral,a,Flatten[Sort[Flatten[{b},0],Flatten[{#1}][[1]]===$parm&],0]];

$=$/.$s;
$s=$//tuExtractPositionPattern[xIntegral[_,_]]//First;
If[Length[$options]>0,
$s=$s/.xIntegral[a_,b_]->xIntegral[a,b,Assumptions->$options]
];xPrint[$s];
If[tuHasAnyQ[$s[[2,2]],$parm],$s=$s//Activate];;
$=tuReplacePart[$,Flatten[{$s},0]]
];
IntegrateOne[parm_,exp_]:=tuIntegrateOne[parm][exp];

(*
addIntegralOpVar[var_List] adds var_List to IntegralOp[vars,_] var_List must be a List of Lists. *28Nov2012*)
addIntegralOpVar[var_List]:=IntegralOp[a_,b_]:>IntegralOp[Join[a,var],b];
(*
simpleIntegralOpVar[var_,vRule_][exp_IntegralOp] simplifies the integration variables, vars_ in IntegralOp[vars,integrand] when vars_ have coefficients attached.  The integrand is compensated for coefficients of var. The optional vRule_ is to change the limits of the integration in case it is a function of another variable.
Usage: tmp/.int:IntegralOp[a_,b_]:>simpleIntegralOpVar[{ku1[{1,2}],ku1[{3,4}]},
tp->t ][ int ]  /;!FreeQ[a,ku1[{1,2}]]   *26Apr2014*)
simpleIntegralOpVar[var_,vRule_:{}][exp_IntegralOp]:=Module[{tmp=exp,intvars,newv,integrand,apply,vfact},
{intvars,integrand}=Apply[List,exp];xPrint[{intvars,integrand}];
apply[v_]:=Module[{},intvars=Map[
If[FreeQ[#,v],
(*Do nothing*)
#,
(*factor intgrand, adjust limits*)
integrand =integrand(#[[1]]/.v->1);
newv=#;vfact=(#[[1]]/.v->1);newv=Map[#/vfact&,newv];newv[[2;;3]]=newv[[2;;3]]/.vRule;
xPrint[#,":",v,":",vfact,":",newv];
{newv}]&,intvars]
];
Map[apply[#]&,Flatten[{var}]];
IntegralOp[intvars,integrand]/.formIntegralOpVar
]
(*
formIntegralOpVar is a Rule that correctly formats the vars_ in IntegralOp. *29May2014*)
formIntegralOpVar:=IntegralOp[var_List,grand_]:>IntegralOp[Sort[Flatten[{#}]&/@var],grand]
(*
TotalDiffByParts[productexp_, derivative_] generates a expression generated by differentiating by parts where productexp_ is the expression to be converted into a sum of two expressions \[Rule] TotalDerivative - Derivative[term-derivative_] derivative_. 
derivative_ defines the differential used for conversion.  Handles Times|Dot|xDot productexp_'s. *15Jul2014*)
tuTotalDiffByParts::usage="tuTotalDiffByParts[productexp_,derivative_] generates a expression generated by differentiating productexp_ by parts. productexp_ is converted into a sum of two expressions: DD[TotalDerivative] - Derivative[productexp_[without derivative_]] derivative_.  The differential operator in derivative_ is used for the resulting expression.  Handles Times|Dot|xDot|CenterDot productexp_'s. EG: tuTotalDiffByParts[a tuDPartial[b,x], tuDPartial[,x]] \[LongRightArrow] DD[tuDPartial[a b, x]] - b tuDPartial[a,x].  *15Jul2014*";
tuTotalDiffByParts[productexp_, derivative_]:=Module[{tmp=productexp,var,f1,tmp2,tmp3,dHead=Head[derivative],OP=Times|Dot|xDot|CenterDot,xOP,$s,$placeholder},
{f1,var}=Apply[List,derivative];(*break out derivative arguements*)
tmp=tmp/.op:OP->xOP[op];(*Freeze OPs ordering*)
$s=derivative->f1/.op:OP->xOP[op];
tmp2=tmp/.$s;
$s=derivative->$placeholder/.op:OP->xOP[op];
tmp3=tmp/.$s;
tmp3=dHead[tmp3,var]//.xOP[op_]->op;
tmp3=tmp3//tuDerivativeExpand[{$placeholder}];
tmp3=tmp3/.$placeholder->f1;
tmp2=dHead[tmp2,var]//.xOP[op_]->op;(*Replace OPs*)
Return[DD[tmp2]- tmp3];
];
(**)
tuTotalDiffByPartsConvert::usage="tuTotalDiffByPartsConvert[productexp_, derivative_] converts a product expression productexp_ by tuTotalDiffByParts[] applied to derivative_ term within productexp_.  Returns Rule[] productexp_ \[Rule] (equivalent expression where DD[] identifies the total derivative term). *22Feb2019*";
tuTotalDiffByPartsConvert[productexp_, derivative_]:=Module[{$},
$=productexp/.derivative->derivative[[1]];
$=tuTotalDiffByParts[$,derivative]->0;
tuRuleSolve[$,productexp]
];

tuTotalDiffByParts0::usage="tuTotalDiffByParts[productexp_,derivative_] generates an equivalent expression for productexp_ which is generated by differentiating by parts. productexp_ is the expression to be converted into a sum of two expressions: {TotalDerivative-Derivative[coefficient of derivative_] derivative_}. \[IndentingNewLine]derivative_ defines the differential used for conversion.  Handles Times|Dot|xDot|CenterDot productexp_'s. Power[derivative_,_] expressions result in xDot[] expressions. The DD[] term is the total derivative.  *23Dec2016*";
tuTotalDiffByParts0[productexp_, derivative_]:=Module[{tmp=productexp,var,f1,tmp2,tmp3,dHead=Head[derivative],OP=Times|Dot|xDot|CenterDot,xOP,$s,$p,$p0,totD},
{f1,var}=Apply[List,derivative];(*break out derivative arguements*)
tmp=tmp/.op:OP->xOP[op];(*Freeze OPs ordering*)
(*factor one derivative in Power expression. Connect with xDot to be dealt with later*)
tmp=tmp/.Power->xPower/.xPower[dd:derivative,n_]:>xDot[dd,xPower[dd,n-1]];
$p=tmp//tuExtractPositionPattern[derivative];
$s=derivative->f1/.op:OP->xOP[op];
$p0=$p[[1]]=$p[[1]]/.$s;
$p0[[2]]=1;
(*replace only first occurance of derivative*)
tmp2=tuReplacePart[tmp,$p];
tmp3=tuReplacePart[tmp,{$p0}];
tmp3=f1 dHead[tmp3,var];
totD=dHead[tmp2,var]/.xOP[op_]->op;
tmp3=DD[totD]-tmp3/.xOP[op_]->op/.xPower->Power
];

(*TotalDiffByParts1[productexp_, derivative_] generates a expression generated by differentiating by parts where productexp_ is the expression to be converted into a sum of two expressions\[Rule]total derivative + term with double derivative_. 
derivative_ is the differential used for conversion. Corrected to include proper handling of OP's terms. Terms with Dot[] are treated simply.  *22Mar2014*)
(*TotalDiffByParts1[productexp_, derivative_]:=Module[{tmp=productexp,var,f1,tmp1,tmp2,tmp3,dHead=Head[derivative],xderiv,dLocCheck,OP=Times|Dot|xDot,xOP,head,terms,with,without,g,f,gdf,dfg,DEBUG=1},
{f1,var}=Apply[List,derivative];(*break out derivative arguements*)
(*in case \[Exists] power of derivative use only one*)
tmp2=tmp/.derivative\[Rule]f1;
(*for more complex derivatives, but not mixed operations: Times, Dot*)
head=Head[tmp];
terms=Apply[List,tmp];
with=Apply[head,Select[terms,!FreeQ[#,f1]&]]/.f1->f1[var]/.xPartialD->D;
f=Apply[head,Select[terms,FreeQ[#,f1]&]];
g=Integrate[with,var] ;(**)
gdf=head[g,Head[derivative][f,var]];
dfg=Head[derivative][head[f,g],var];(*
Print["tmp: ",tmp];*)
If[FreeQ[tmp,Dot|xDot]
,tmp=dfg-gdf (*This is result if no Dot|xDot is not involved in IBP.*)
,(*The following is simplistic IBP for Dotted expressions.*)
tmp=tmp/.(a:derivative)^n_\[RuleDelayed]a xderiv^(n-1);(*CHECK*)
tmp1=tmp/.derivative\[Rule]dLocCheck;
xPrint[">>",tmp,":",derivative,":",dHead,":",tmp1];
If[!FreeQ[tmp1,dLocCheck],
(*find immediate operator for dLocCheck *)
tmp3=tmp1/.(op:OP)[a___,dLocCheck,b___]->xOP[op];
tmp3=ExtractPattern[xOP[_]][tmp3][[1]];xPrint["tmp3: ","  >>",tmp3,"<< "];
tmp3=tmp3[[1]][dHead[tmp1,var]];xPrint["tmp3: ","  >>",tmp3,"<< "];
tmp3=tmp3//tuDerivativeExpand[{dLocCheck}];xPrint["tmp3: ","  >>",tmp3,"<< "];
tmp3=tmp3/.dLocCheck->f1;xPrint["tmp3: ",f1," : ",tmp1,"  >>",tmp3,"<< "];
tmp=dHead[tmp2,var]-tmp3//simpleDot3[{}];(*
If[DEBUG>0,Print[">>f1 ",tmp,":",tmp1,":",tmp2,":",f1]];*)
tmp=tmp/.xderiv\[Rule]derivative;(*
Print["TotalDiffByParts1: ",{derivative,tmp,f1,var,tmp1,tmp2}]*)
,
tmp=productexp
]
];
tmp
];*)

(*Generates a list from pure product of terms including Power terms with defined power.*)
Product2List[exp_]:=Module[{},
If[FreeQ[exp,Plus],
exp/.Power[a_,b_]:>DotPower[a,b]/.Times->Dot/.Dot->List,
exp]
];
(*
gatherDerivOp is a Rule that gathers DerivOps into one DerivOp.  Usage: exp_//.gatherDerivOp.
Eg. -\[ImaginaryI] (Subscript[Underscript["\[PartialD]", _], t][(J^-)[t]]-Subscript[Underscript["\[PartialD]", _], t][(J^+)[t]])\[LongRightArrow]Subscript[Underscript["\[PartialD]", _], t][-\[ImaginaryI] ((J^-)[t]-(J^+)[t])]  *10Jul2014*)
gatherDerivOp:={
a_ ( dd:DerivOps)[b_,c_]->dd[a b,c],
 ( dd:DerivOps)[b_,a_]+ (dd:DerivOps)[c_,a_]->dd[ c+ b,a]
};

(*
Expansion Rules for various Differentials {xD[_],xPartialD,xCovariantD} etc. *5Aug2012*)
xPartialDExpand[constants_List]:={tuPartialD,tuPartialDu,DifExpand[xPartialD|xPartialDu,constants]}//Flatten;
xCovariantDExpand[constants_List]:={DifExpand[xCovariantD|xCovariantDu,constants]}//Flatten
xLieDExpand[constants_List]:={DifExpand[xLieD,constants]}//Flatten;
xD\[Delta]Expand[constants_List]:=DifExpand[xD[_]|xDu[_],constants]//Flatten;
(*
Multiple differential expansion Rule  *)
ExpandDerivDvar:={(head:tuDExpand)[a_,b_List]:>head[head[a,First[b]],Rest[b]]/;Length[b]>1,(head:DerivOps)[a_,b_List]:>head[a,b[[1]]]/;Length[b]==1};

(**)
(**)
tudExpand::usage="tudExpand[\[Delta]1_,constants_List:{}][exp_] expands differential operator \[Delta]1_ using basic Liebnitz Rule[]s. *29Nov2012*12Nov2017*3Sep2018*";
tudExpand[\[Delta]1_,constants_List:{}][exp_]:=Module[{tmp=exp,sub,name,tmp0,$dum,n$,ProductOp=Flatten[BraKet|Times|dotOps|Wedge|xWedge|CircleTimes]},
sub={
(name:\[Delta]1)[a_]:>0/;NumericQ[a],
(name:\[Delta]1)[a_]:>0/;ListMemberQ[a,constants],
(name:\[Delta]1)[a_^n_]:>0/;ListMemberQ[a,constants]&&NumericQ[n],
(name:\[Delta]1)[1/a_]:>0/;ListMemberQ[a,constants],
(name:\[Delta]1)[1/a_^n_]:>0/;ListMemberQ[a,constants]&&NumericQ[n],
(name:\[Delta]1)[Conjugate[a_]]:>Conjugate[name[a]],
(name:\[Delta]1)[ConjugateTranspose[a_]]:>ConjugateTranspose[name[a]],
(name:\[Delta]1)[Transpose[a_]]:>Transpose[name[a]],
(name:\[Delta]1)[Tr[a_]]:>Tr[name[a]],
(name:\[Delta]1)[a__]:>Thread[name[a]]/;(Head[a]==List),
(name:\[Delta]1)[(OP:DerivOps)[T_,i___]]->OP[name[T],i],
(name:\[Delta]1)[Exp[a_]]->Exp[a] name[a],
(name:\[Delta]1)[Log[a_]]-> name[a]/a,
(name:\[Delta]1)[a_^n_]:>n name[a]a^(n-1),
(name:\[Delta]1)[(tt:Apply[Alternatives,tuTrigFunc])[t_]]:>(D[tt[$dum],$dum]name[t]/.$dum->t),
(0&->0) (*in case \[Delta]1 is Derivative[1] which produces 0& for NumberQ. *),
(name:\[Delta]1)[(ww:Wedge|xWedge)[a_,b__]]->ww[name[a],b]+ww[a,ww[b]]
}//Flatten;
While[tmp=!=tmp0,
tmp0=tmp;
tmp=tmp//ExpandAll;
tmp=tmp//.(name:\[Delta]1)[a_ +  b_]->name[a]+ name[b];
tmp=tmp//.(name:\[Delta]1)[(oo:ProductOp)[a_  ,b__]]:>oo[name[a],b]+oo[a ,If[Length[{b}]>1,name[oo[b]],name[b]]];
tmp=tmp//.sub;
(*Use Mathematica Dt function \[Implies] some Rules obsolete.*)
(*Cludge code to handle the hidden variables properly with Dt, i.e., Dt[f[1]]\[Rule]0 *)
(*
Print["0:",tmp];*)
tmp=tmp/.(dname:\[Delta]1)[a_]:> dname[a/. h_[n_?NumberQ]->h[n,n$]];
tmp=tmp/. \[Delta]1->Dt/.Dt->$Dt;(*
Print["1:",$tmp=tmp];*)
tmp=tmp//.($Dt[n$]Derivative[0,1][z_][m_?NumberQ,n$]):>\[Delta]1[z[m]];
tmp=tmp//.($Dt[n$]^(n_:1) Derivative[0,1][z_][m_?NumberQ,n$]^(nn_:1)):>\[Delta]1[z[m]]^nn $Dt[n$]^(n-nn);(*
Print["2:",tmp];*)
tmp=tmp//.z_[n_?NumberQ,n$]:>z[n]/.$Dt->\[Delta]1;
(*Print["3:",tmp];*)
tmp=tmp/.Derivative[__][dForm][__]->0(*special for dForm*)
];
tmp
];

(**)
tudExpandvI::usage="tudExpandvI[ops_,constants_List:{}] wrapper for tudExpand[]. Calls  tuOpIndependentVar[tudExpand,op$[ops,constants][exp]] *13Nov2018*";
tudExpandvI[ops_,constants_List:{}][exp_]:=Module[{},
tuOpIndependentVar[tudExpand,op$[ops,constants][exp]]
];

(**)
tudFnc::usage="tudFnc[var_,dOp_:d,constants_:{}][exp_] apply dOp_ via tuDExpandF[dOp,constants] and then does d[exp_]->D[exp_,var] dOp_[var]. var_ can be a List of var's. Applies tuD2tuDOp[tuDPartial] to result.  *22Aug2014*13Dec2017*";
tudFnc[var_,dOp_:d,constants_:{}][exp_]:=Module[{tmp=exp,vars=Flatten[{var}]},
tmp=tmp//tuOpIndependentVar[tuDExpandF,op$[dOp,constants][#]]&;
tmp=tmp/.dOp[fn_]:>(Apply[Plus,Map[D[fn[#],#]dOp[#]&,vars]]);(*add dOp[var]*)
tmp//tuD2tuDOp[tuDPartial]
];
dFnc[var_,dOp_:d,constants_:{}][exp_]:=tudFnc[var,dOp,constants][exp];
(**)
tudFncRule::usage="tudFncRule[var_,dOp_:d,constants_:{}] creates Rule for applying tudFnc[].  Expands d[ exp_[var_] ] using D[,] operator. Generate D[exp_,var] d[var] dOp_ via \[Delta]Exapnd[dOp,constants] and then does d[exp_]->D[exp_,var] dOp_[var].  var_ can be a List of var's. NEED TO HIDE tuRuleIndependentVarPattern. *22Aug2014*";
tudFncRule[var_,dOp_:d,constants_:{}]:=dOp[exp_]:>tudFnc[var,dOp,constants][dOp[exp]];
dFncRule[var_,dOp_:d,constants_:{}]:=tudFncRule[var,dOp,constants];

(*
dFncfn[fn_,dOp_:d,constants_:{}][exp_] expands exp_ containing term d[fn_[]] and expanding it by taking derivatives of fn_[arg__] for each arg. Works like dFnc but by function name fn_. *29Sep2014*)dFncfn[fn_,dOp_:d,constants_:{}][exp_]:=Module[{tmp=exp,vars,narg},
tmp=tmp//Inactive[tuDExpandF][dOp,constants]//tuOpIndependentVarActivate[];
vars=tmp//ExtractPattern[dOp[fn[a__]]]//First;
vars=vars/.dOp[fn[a__]]:>{Length[{a}],a}//Flatten;
narg=Array[$arg,vars[[1]]];
tmp=tmp/.dOp[fn[a__]]:>dOp[fn[Apply[Sequence,narg]]];
tmp=tmp/.dOp[fn[a__]]:>Apply[Plus,Map[D[fn[a],#]dOp[#]&,narg]];
narg=narg->Rest[vars]//Thread;
tmp/.narg
];
(**)
Clear[tuDArgSwitch];
tuDArgSwitch::usage="tuDArgSwitch[derIn_List,derOut_List][exp_] switches order of derivative between variables {derIn_,derOut_} in exp_.  The pair of derivatives must be adjacent pairs with no other variables in between. i.e., tuDPartial[tuDPartialu[A,i],j].  *14Nov2014*";
tuDArgSwitch[derIn_List,derOut_List][exp_]:=Module[{tmp=exp,sub,XXX},
tmp=tmp//.\[Delta][a_]->xD[XXX][a,XXX];(*include \[Delta] make uniform arguements*)
If[!IntersectingQ[derIn,derOut],
sub=(OP1:DerivOps)[(OP2:DerivOps)[c_,d_],e_]:>OP2[OP1[c,e],d]/;(MemberQ[derIn,d]&&MemberQ[derOut,e]);
xPrint[sub];
tmp=tmp//.sub,
tmp=SwitchDerivERROR[derIn,derOut][tmp]
];
tmp=tmp//.xD[XXX][a_,XXX]->\[Delta][a]
];
SwitchDeriv[derIn_List,derOut_List][exp_]:=tuDArgSwitch[derOut,derIn][exp];(*Compatibility*)

(* 
Integration by parts assume total derivative->0 example: 
{
xPartialDu[a_,b_]c_:>-xPartialDu[c,b]a/;!(FreeQ[a,T[\[CurlyEpsilon],"u",_]]&&FreeQ[a,T[\[CurlyEpsilon],"d",_]]),
xPartialD[a_,b_]c_:>-xPartialD[c,b]a/;!(FreeQ[a,T[\[CurlyEpsilon],"u",_]]&&FreeQ[a,T[\[CurlyEpsilon],"d",_]])
}*)

(*
IncludeConstantxPartial[constant_List][exp_] will include into xPartialD's the terms in constant_List if they are connected by simple Times.  Changes the Attributes of xTimes.  *17Sep2013*)
IncludeConstantxPartial[constant_List][exp_]:=Module[{tmp,ops=xTimes,xP=xPartialD|xPartialDu,pat,newpat={},cpat,i},
SetAttributes[xTimes,{Flat,Listable,OneIdentity,Orderless,Protected}];
cpat=Apply[Alternatives,constant];
tmp=exp//.(cp:cpat)(xp: xP)[a_,b_]:>xp[xTimes[cp, a],b];
pat=tmp//tuExtractPositionPattern[xTimes[__]];
For[i=1,i<=Length[pat],i++,
If[FreeQ[Apply[List,pat[[i,2]]],ops],(*simple ops only*)
xPrint[pat[[i]]];
pat[[i,2]]=pat[[i,2]]/.(op:ops)[(cp:cpat),(xp:xP)[a_,b_]]->xp[op[cp, a],b];
AppendTo[newpat,pat[[i]]];
];
];
SetAttributes[xTimes,{}];
ReplacePartTU[tmp,newpat]/.xTimes->Times
];

Clear[tuDotOpsNest];
tuDotOpsNest::usage:="tuDotOpsNest[dotOp_:Dot][exp_] reforms a dotOps operator into nested functional form, e.g., tuDotOpsNest[][ (\!\(\*SubscriptBox[\(\[Delta]\), \(1\)]\).\!\(\*SubscriptBox[\(\[Delta]\), \(2\)]\)-\!\(\*SubscriptBox[\(\[Delta]\), \(2\)]\).\!\(\*SubscriptBox[\(\[Delta]\), \(1\)]\))[fn,f2] ]\[Rule]\!\(\*SubscriptBox[\(\[Delta]\), \(1\)]\)[\!\(\*SubscriptBox[\(\[Delta]\), \(2\)]\)[fn,f2]]-\!\(\*SubscriptBox[\(\[Delta]\), \(2\)]\)[\!\(\*SubscriptBox[\(\[Delta]\), \(1\)]\)[fn,f2]].  dotOp_ defines the dot operator forming the dot expression. tuDotOpsNest does nothing if the Head[exp_] does not contain dotOp_.
*20Feb2019*";
tuDotOpsNest[dotOp_:Dot][exp_]:=Module[{$0=exp,$1,$,$argn,$Arg,$head,xBlank,$right},
$=Head[$0];
If[FreeQ[$,dotOp],Return[exp]];
xPrint[$=dotOp [$ , Apply[$Arg,$0]]];
xPrint[$=$//tuRepeat[{tuOpDistribute[dotOps],tuOpSimplify[dotOps],(dd:dotOps)[a___,b_,aa:c_]:>dd[a,b[aa]]/;!FreeQ[aa,$Arg]},{},5]
];
$=$/.$Arg[a__]:>Sequence[a];
$
];
(*TEST
(Subscript[\[Delta], 1].Subscript[\[Delta], 2]-Subscript[\[Delta], 2].Subscript[\[Delta], 1])[fn,f2]
%//tuDotOpsNest[]
*)
Clear[tuOperatorDot2Nest];
tuOperatorDot2Nest::usage="tuOperatorDot2Nest[exp_] replaces Dot|xDot operator expressions in exp_ with nested expression, i.e.,  xDot[op1[_],op2[_],op3[_]]\[Rule]op1[op2[op3[_]]].  The arguement of each operator is expressed as Blank[].  *13Nov2015*";
tuOperatorDot2Nest[exp_]:=Module[{$0=exp,$1,$argn,$Arg,$head,xBlank,$right},
If[!MatchQ[$head=Head[$0],dotOps],Return[$0]];(*Only dotOps allowed*)
$0=$0//.tuOpSimplify[dotOps]/.Blank->$Arg/.$head->xDot;(*Operator arguements specified by Blank[]. Dot causes problems. *)
$1=$0//tuExtractPositionPattern[$Arg[]];xPrint["MM:",$1];
While[Length[$1]>0,
$argn=$1[[-1,1,1]];
$right=$0[[$argn+1;;-1]]/.xDot->xBlank;xPrint["PP ",$argn,":",$1[[-1,2]]=$right," : ",$0];
$0=Drop[tuReplacePart[$0,{$1[[-1]]}],{$argn+1,-1}];
$1=Delete[$1,-1]
];
$0/.xBlank[]->Blank[]//.xBlank->xDot/.xDot->$head
];
(*
evalDifferentialOps[opdef_][exp_] evaluates nested Ops,eg., op1[op2[op3[arg]]] expressed as xDot[op1,op2,op3] where opdef_ is name of DelayedRules the discribes the op's, eg, opdef_[arg_]:={a\[Rule]a[arg],b\[Rule]b[arg],c[yy_]\[Rule]xPartialD[arg,yy]} The label arg must be used to specify the position the arguement. Even multiplicative operation must be specified in opdef_ ,eg., x xPartialD[] . *17Aug2014*)evalDifferentialOps[opdef_][exp_]:=Module[{$=exp,op},
$=$/.dd:xDot[a__]:>Fold[op,arg,Reverse[dd]];
op[a_,b_]:=(b/.opdef[a]);
$
];
(*
$sa[arg_]:={a\[Rule]a[arg],b\[Rule]b[arg],c[yy_]\[Rule]xPartialD[arg,yy]}
xDot[a,c[Y],b]
%//evalDifferentialOps[$sa]
*)
(*
derivativeSummedIndices[varPat_,var_,index_,constants_List][exp_] differentiates exp_ by varPat_ with target variable var_ with implicit summed index_.  Replaces varPat_ index with index_ in exp_.  Returns exp_ with the xPartialD[varPat_,var_] replaced by \[Delta][].  *18Sep2014*)
derivativeSummedIndices[var_,index_,dummy_List,constants_List][exp_]:=Module[{varPat,tmp,ipos},
tmp=UniqueDummyIndices[dummy][exp];
tmp=xPartialD[tmp,var];
tmp=tmp//tuDerivativeExpand[constants];
ipos=var//tuExtractPositionPattern[index];
ipos[[1,2]]=vv__;
varPat=ReplacePartTU[var,ipos];
tmp=tmp/.pp:xPartialD[varPat,var]:>DD[derivativeToDelta[index][pp]]//Expand//simpleDot3[{DD[_]}];
xPrint["KK",tmp];
tmp=tmp/.b__  DD[a_]:>ContractUpDn[\[Delta],{a[[2,1]]}][b a[[1]]];(*CHECK only product of Tensor*)
Return[tmp];
];
(*TEST: T[g,"uu"][i,j]T[x,"d"][i]T[x,"d"][j]//derivativeSummedIndices[T[x,"d"][k],k,{T[g,"uu"][_,_]}]
*)
(*
derivativeToDelta[index_][exp_] converts exp_ == xPartialD[x^(i K),x^(j L)] into \[Delta]^(i j) where x's are Tensors with up-down indices. Return[0] if Tensors are not the same shape or name. Returns {i} the index that is not referenced by derivative index. *18Sep2014*)
derivativeToDelta[index_][exp_]:=Module[{tmp=exp,ipos,ud,lengths},
tmp=Apply[List,tmp];
If[tmp[[1,1]]=!=tmp[[2,1]],Return[0]];(*not same variable name*)
tmp=tuIndexParser/@tmp;
If[(Last[#]&/@tmp)=!=({{},{}}) , Return[0]];
If[ FreeQ[tmp[[2,2]],index] ,Return[0] ];
tmp=#[[2]]&/@tmp;(*up-down indices*)
lengths=Length/@#&/@tmp;
If[lengths[[1]]=!=lengths[[2]],Return[0]];(*different up-down structure*)
ipos=Position[tmp[[2]],index];
tmp=Extract[tmp[[1]],ipos];
tmp={tmp,index}//Flatten;
ud=If[ipos[[1,1]]===1,"ud","du"];
Return[{T[\[Delta],ud][Apply[Sequence,tmp]],tmp}]
];(*
derivativeToDelta::1="general index error";
derivativeToDelta::2="no index found";*)
(*xPartialD[T[x,"uu"][i,k],T[x,"uu"][j,L]]
%//derivativeToDelta[j]
*)

(**)
tuTrigFunc={Cos,Sin,Tan,Tanh,Cot,Coth,Sinh,Cosh,Sec,Sech,Csc,Csch};
tuTrigFunc=Join[tuTrigFunc,Map[ToExpression["Arc"<>ToString[#]]&,tuTrigFunc]];
tuTrigDerivativeExpand::usage="tuTrigDerivativeExpand[constants_List:{}][exp_] expands DerivOps of Trig functions by applying Rule[] DerivOps->D.  TODO: replace resulting D[]'s with original DerivOps and determine if constants_List is necessary since arguements of functions are explicit. *17Jan2015*";
tuTrigDerivativeExpand[constants_List:{}][exp_]:=Module[{tmp=exp},tmp=tmp//.(op:DerivOps)[a_,b_]:>D[a,b]/;!ListFreeQ[a,{Cos,Sin,Tan,Tanh,Cot,Coth,Sinh,Cosh,Sec,Sech,Csc,Csch}];
tmp=tmp/. HoldPattern[D[a_,b_]]:>0/;MemberQ[constants,a]
];

tuOrderDerivativeArguements[exp_]:=Module[{tmp=exp,derivOp=xPartialD|xPartialDu|xD[_]|xDu[_]},
tmp=tmp//.(dd1:tuDerivOps)[(dd2:tuDerivOps)[a_,b_],c_]:>dd2[dd1[a,c],b]/;OrderedQ[{b,c}]
];



(* ::Input::Initialization:: *)
(**)
tuTensorQ::usage="tuTensorQ[exp_] returns True if exp_ is Tensor or tuDerivOps *11Sep2015*";
tuTensorQ[exp_]:=tuMemberQ[Head[exp],List@@Flatten[Tensor|tuDerivOps]];

(* Adds/modifies index to existing indices.*)
AddBaseIndex[index_List]:=Module[{tmp,DEBUG=0,mname="AddBaseIndex"},
IfDEBUG[mname,DEBUG>0,{index},"in"];
tmp=Append[CompleteBaseIndices,index];
IfDEBUG[mname,DEBUG>0,{tmp},"tmp"];
tmp=tmp/.{index[[1]],a_}->index//DeleteDuplicates;
IfDEBUG[mname,DEBUG>0,{tmp},"tmp"];
DeclareBaseIndices[Apply[Sequence,tmp]];
CompleteBaseIndices
];
(*
CheckIndices applies ParseTermIndices to eech level 2 term in exp_. 4Jul2012*)
CheckIndices[exp_]:=Module[{tmp=exp},
Map[ParseTermIndices[#]&,Apply[List,tmp]]
];
(*
SwitchLabel[exp_,{a,b}] switches label a,b in exp_ *)
SwitchLabel[exp_,mn_List]:=Module[{tmp=exp,XXXX},
tmp=tmp/.First[mn]->XXXX/.Last[mn]->First[mn]/.XXXX->Last[mn]
];
(*SwitchLabel[exp_,{a,b}] switches label a,b in exp_ *)
SwitchLabel[mn_List][exp_]:=Module[{tmp=exp,XXXX},
tmp=tmp/.First[mn]->XXXX/.Last[mn]->First[mn]/.XXXX->Last[mn]
];

(**)
tuIndexSymmetrize::usage="tuIndexSymmetrize[indexPair_List][exp_] symmetrizes exp_ over indexPair_. eg: tuIndexSymmetrize[{i,j}][\!\(\*SubscriptBox[\(A\), \(ij\)]\)]->(\!\(\*SubscriptBox[\(A\), \(ij\)]\)+\!\(\*SubscriptBox[\(A\), \(ji\)]\))/2 . *7Aug2012*";
tuIndexSymmetrize[indexPair_List][exp_]:=Module[{tmp1,tmp2},
(exp+tuIndexSwap[indexPair][exp])/2
];
Symmetrize2[indexPair_List][exp_]:=tuIndexSymmetrize[indexPair][exp];
(**)
tuIndexAntiSymmetrize::usage="tuIndexAntiSymmetrize[indexPair_List][exp_] antisymmetrizes exp_ over indexPair_. eg: tuIndexAntiSymmetrize[{i,j}][\!\(\*SubscriptBox[\(A\), \(ij\)]\)]->(\!\(\*SubscriptBox[\(A\), \(ij\)]\)-\!\(\*SubscriptBox[\(A\), \(ji\)]\))/2 . *7Aug2012*";
tuIndexAntiSymmetrize[indexPair_List][exp_]:=Module[{tmp1,tmp2},
(exp-tuIndexSwap[indexPair][exp])/2
];
AntiSymmetrize2[indexPair_List][exp_]:=tuIndexAntiSymmetrize[indexPair][exp](*Compatibility*)


(*Symmetrize[tensorindex_List][exp_] applies a list of {tensorindex={tensorName,order,index_List} to exp_.  If order < 0 then index_List specify AntiSymmetric relationship.  Uses Tensorial routines. Name changed to SymmetrizeTU to eliminate conflicts with V.9.  *3Jan2013*)
SymmetrizeTU[tensorindex_][exp_]:=Module[{tmp=exp,tmp1,tmp2,up0,dn0,up1,dn1,order,Symmetrize1},
Symmetrize1[tensorindex1_List][exp1_]:=If[tensorindex1[[2]]>0,SymmetrizeSlots[tensorindex1[[1]],tensorindex1[[2]],Symmetric[Apply[Sequence,tensorindex1[[3]]]]][exp1],
SymmetrizeSlots[tensorindex1[[1]],-tensorindex1[[2]],AntiSymmetric[Apply[Sequence,tensorindex1[[3]]]]][exp1]];
Fold[Symmetrize1[#2][#1]&,tmp,tensorindex]
];

(*
symmetrize[vars_List][exp_] symmetrizes exp_ wrt vars_List by summing permutations over vars_List.  NOTE: check for unusual results!! *16Dec2013*)
symmetrize[vars_List][exp_]:=Module[{tmp=exp},
tmp=tmp//ExpandAll;
tmp=Distribute[Hold[tuSymmetrizeSymbol][1,vars][tmp]];(*Hold to stop evaluation before Distribute.*)
tmp//ReleaseHold
];
(*
antisymmetrize[vars_List][exp_] antisymmetrizes exp_ wrt vars_List by summing permutations over vars_List.  *16Dec2013*)
antisymmetrize[vars_List][exp_]:=Module[{tmp=exp},
tmp=tmp//ExpandAll;
tmp=Distribute[Hold[tuSymmetrizeSymbol][-1,vars][tmp]];(*Hold to stop evaluation before Distribute.*)
tmp//ReleaseHold
];

tuSymmetrizeSymbol::usage="tuSymmetrizeSymbol[sign_,vars_List][exp_] (anti)symmetrizes exp_ over vars_ with sign_ used as factor for antisymmetric(-1) or symmetric(1) operation. The result is divided by the number of resulting terms. *10Jan2019*";
tuSymmetrizeSymbol[sign_,vars_List][exp_]:=Module[{tmp=exp,tmp1,sum=0,pos,posp,is,vs,cycle,perms,nperm,perm},
xPrint["vars,tmp : ",vars,tmp];
pos=tmp//tuExtractPositionPattern[vars];
is=Map[#[[1]]&,pos]; 
vs=Map[#[[2]]&,pos]; If[Length[vs]===0,Return[exp]];
perms=Permutations[vs];
nperm=Length[perms];
xPrint[pos,",",perms];
Do[
posp=Thread[Rule[is,perms[[$$i]]]];
xPrint[posp];
sum=sum+(sign)^($$i-1)tuReplacePart[tmp,posp],
{$$i,nperm}
];
Return[ sum/nperm]
];
(*
TEST
T[A,"ddd",{a,e,d}]\[CenterDot]T[B,"ddd",{a,b,c}]//tuSymmetrizeSymbol[-1,{c,b}]
f[A,B]//tuSymmetrizeSymbol[-1,{A,B}]*)

(*OrderSymmetricTensor[tensor_Tensor] Canonical orders all slots of tensor_Tensor.  May be useful in simplifying Tensor expressions. 
*)
OrderSymmetricTensor[tensor_Tensor]:=Module[{tmp,name,ups,dns,indices},
{name,ups,dns}=Apply[List,tensor];
indices=Table[i,{i,Length[ups]}];(*25Apr2012 untested*)
OrderSymmetricTensor[tensor,indices]
];
(*OrderSymmetricTensor[tensor_Tensor,indices_List] Canonical orders slots indices_List (Integers) of tensor_Tensor 
*)
OrderSymmetricTensor[tensor_Tensor,indices_List(*Integer*)]:=Module[{tmp,tmps,tmp0,sub,name,ups,dns,nosym,cases},
{name,ups,dns}=Apply[List,tensor];
cases=Map[{#}&,indices];
nosym=Table[{i},{i,Length[ups]}];
nosym=Delete[nosym,cases];
tmp0=Thread[List[ups,dns]];
tmps=Delete[tmp0,nosym];
tmp=MapIndexed[DeleteCases[#,Void][#]&,tmps];
tmp=tmp//Sort;
tmp=Map[#/.f_[a_]->a&,tmp];
sub=Thread[Rule[cases,tmp]];
tmp=ReplacePart[tmp0,sub]//Transpose;
Tensor[name,tmp[[1]],tmp[[2]]]
];

tuTensorAntiSymmetricOrdered::usage="tuTensorAntiSymmetricOrdered[tensor_Tensor,indices_List(*Integer*)]  Canonically order indices_List Slots of tensor_Tensor multiplied by (-1)^Signature[indices] *22May2015*)";
tuTensorAntiSymmetricOrdered[tensor_Tensor,indices_List(*Integer*)]:=Module[{tmp,tmps,tmp0,sub,name,ups,dns,nosym,cases,signature},
{name,ups,dns}=Apply[List,tensor];
cases=Map[{#}&,indices];
nosym=Table[{i},{i,Length[ups]}];
nosym=Delete[nosym,cases];
tmp0=Thread[List[ups,dns]];
tmps=Delete[tmp0,nosym];
tmp=MapIndexed[DeleteCases[#,Void][#]&,tmps];
signature=Signature[tmp];
tmp=tmp//Sort;
tmp=Map[#/.f_[a_]->a&,tmp];
sub=Thread[Rule[cases,tmp]];
tmp=ReplacePart[tmp0,sub]//Transpose;
signature Tensor[name,tmp[[1]],tmp[[2]]]
];
OrderAntiSymmetricTensor[tensor_Tensor,indices_List]:=tuTensorAntiSymmetricOrdered[tensor,indices];(*Compatibility*)

(*OrderAntiSymmetricTensor[tensor_Tensor] Canonical orders all slots of anti-symmetric tensor_Tensor.  May be useful in simplifying Tensor expressions. 
*)
OrderAntiSymmetricTensor[tensor_Tensor]:=Module[{tmp,name,ups,dns,indices},
{name,ups,dns}=Apply[List,tensor];
indices=Table[i,{i,Length[ups]}];(*25Apr2012 untested*)
OrderAntiSymmetricTensor[tensor,indices]
];

(**)
tuOrderRiemann::usage="tuOrderRiemann[exp_] canonically orders the indices of a 4-indexed Riemann tensor ((\!\(\*SuperscriptBox[\(R\), \(i\)]\)\!\(\*SubscriptBox[\()\), \(jkl\)]\)] *24Jan2015* ";
tuOrderRiemann[exp_]:=Module[{tmp,pos},
tmp=exp;
pos=tmp//tuExtractPositionPattern[Tensor[R,_,_]];
pos=pos/.T[R,"uddd"][i_,j_,k_,l_]:>-T[R,"uddd"][i,j,l,k]/;OrderedQ[{l,k}];
pos=pos/.T[R,"uddd"][i_,j_,k_,l_]:>-T[R,"uddd"][j,i,k,l]/;OrderedQ[{j,i}];
tmp=tuReplacePart[tmp,pos]
];
(**)
tuSwap::usage="tuSwap[this_,that_][exp_] swaps the symbols this_ for that_ in exp_. *16Feb2016*";
tuSwap[this_,that_][exp_]:=Module[{tmp=exp,pair={this,that},XXXX,YYYY},
If[this=!=that,
pair=SortBy[pair,Length];
tmp=tmp//.pair[[2]]->XXXX//.pair[[1]]->YYYY//.XXXX->pair[[1]]//.YYYY->pair[[2]];
];
tmp
];
Swap[pair_List][exp_]:=tuSwap[pair[[1]],pair[[2]]][exp];(*Compatibility*)
(*Swaps sequential pairs of anything in expressions.*)
Swaps[pairs_List][exp_]:=Module[{tmp=exp,DEBUG=0,mName="Swaps"},
IfDEBUG[mName,DEBUG>0,{tmp,pairs,Depth[pairs]},"tmp,pairs"];
tmp= Fold[Swap[#2][#1]&,exp,pairs];
tmp
];
(*
SwapVarFromAtoB[var_,A_List,B_List] Swap var_ in A_ for the corresponding one in B_.  Returns {A_List,B_List} with var_ Swapped.   *8May2013*)
SwapVarFromAtoB[var_,A_List,B_List]:=Module[{tmp,pos,xpos,i,len,xA=A,xB=B},
If[Length[xA]==Length[xB],
pos=Position[xA,var,1]//Flatten;
len=Length[pos];
If[len>0,
For[i=1,i<=len,i++,
xpos=pos[[i]];
tmp=xB[[xpos]];
xB[[xpos]]=xA[[xpos]];
xA[[xpos]]=tmp;
];
];
];
{xA,xB}
];

(* Returns list of positions in list_ of form_ or {} if none found.*)
IndicesQ[list_List,form_]:=Module[{i,pos={}},
For[i=0,i<=Length[list],i++,If[list[[i]]===form,AppendTo[pos,i]]];
pos
];

(*ContractMetric[\[Delta]_][term_Times] Einstein like contraction (up/dn) of term_Times using \[Delta]_ as metric variable. The choice of contraction indices is not controlled and does not check for proper up/dn relationship in term_Times, only the presence of \[Delta] indices as symbol in term_Times.  Assumes properly formed index relationships in term_Times.  Works only for 2-component \[Delta]_ metric functions.  Operates on numerator only. Leaves Tr[\[Delta]_] to be computed outside of this routine.  *28Jul2013.*)
ContractMetric[\[Delta]_][term_]:=Module[{tmp=Numerator[term],denom=Denominator[term],test,pos,i,contractindex,dummy,gindex,flatgindex},
If[Head[term]=!=(Times|xTimes)&&FreeQ[term,Tensor[\[Delta],_,_]],Return[term]];
While[tmp=!=test,
test=tmp;
dummy=tuIndexParser[tmp] [[1]];(*
Print["test: ",test,dummy];*)
pos=tmp//tuExtractPositionPattern[Tensor[\[Delta],_,_]];
For[i=1,i<=Length[pos],i++,
gindex=tuIndexParser[pos[[i,2]]] [[2]];(*
Print["gindex:",gindex];*)
If[gindex[[1]]===gindex[[2]],(*Self contraction?*)
(*tmp=ReplacePartTU[tmp,{pos[[i,1]]->NDim}];*)
(*Leave Tr[g] to be determined<-depends on dimension.*)
Break[]
,(*else*)
flatgindex=Flatten[gindex];(*
Print["g: ",pos[[i,2]]];*)
If[(contractindex=Intersection[flatgindex,dummy])=!={},(*contract?*)
tmp=Delete[tmp,pos[[i,1]]];(*
Print["g1: ",pos[[i,2]]," : ",tmp];*)
If[!MemberQ[dummy,flatgindex[[1]]],(*contraction direction?*)
flatgindex=Reverse[flatgindex]];(*
Print[">>",contractindex,":",flatgindex];*)
If[gindex[[1]]=={}||gindex[[2]]=={},(*UpDn adjust*)tmp=UpDownIndexSwap[flatgindex[[1]]][tmp]
];
tmp=ReplaceIndexTU[Apply[Sequence,flatgindex]][tmp];
Break[];
];
Continue[]
];
];
];
tmp/denom
];

(*ContractUpDn[\[Delta]_][exp_] Einstein like contraction (up/dn) of terms in exp_ using \[Delta]_ as metric variable contained in each term of exp_. The choice of contraction indices is not controlled and does not check for proper up/dn relationship in exp_, only the presence of \[Delta] indices as symbol in exp_. Assumes properly formed index relationships in exp_. Works only for 2-component \[Delta]_ functions. 
Replaced *1Mar2013.*)
ContractUpDn[\[Delta]_][exp_]:=Module[{tmp=exp(*Do ExpandAll to Reduce complexity. But may generate inconsistent dummy indices.*),pos,tmp1,indices,sub,up,dn,test,dummy,contract,i,gindex,contractindex},
(*Extract Times[\[Delta],...]*)
pos=tmp//tuExtractPositionPattern[Tensor[\[Delta],a_,b_] c_];(* BUG does not find straight Times term *)
pos=Map[#[[1]]->ContractMetric[\[Delta]][#[[2]]]&,pos];
tmp=ReplacePartTU[tmp,pos]
];
(* [\[Delta]_,index_List][exp_] Einstein like contraction (up/dn) of terms in exp_ using \[Delta]_ as metric variable. The contraction uses indices ONLY in index_List.  Does nothing if exp_ indices in error, only the presence of \[Delta] indices as symbol in exp_. 
\[Delta]_ is Tensor of rank 2.  Expanded to handle ops at Level 1.  *19Sep2014.*)
ContractUpDn[\[Delta]_,index_List][exp_]:=Module[{tmp=ExpandAll[exp](*Minimize complex expressions*),sub,test,ops=Times|Dot|xDot},
tmp=tmp//simpleDot3[{Tensor[\[Delta],up_List,dn_List]}];(*Assume \[Delta]_ is scalar*)
tmp=tmp/.op:ops[ A__]:>tuIndexContractUpDn[op,\[Delta],index](*Only level 1 product terms.*)
];

(**)
Clear[tuIndexEliminateEta]
tuIndexEliminateEta::usage="tuIndexEliminateEta[exp_,noEta_,eta_,ups_List,dns_List,index_List] applies Einstein summing in exp_ over Tensor[eta_,ups_,dns_] containing indices index_. noEta_ contains exp_ without the eta_ Tensor. *11Nov2015*";
tuIndexEliminateEta[exp_,noEta_,eta_,ups_List,dns_List,index_List]:=Module[{up,dn,upi,dni,noEtadummies,noEtaup,noEtadn,noEtabad},
up=DeleteCases[ups,Void];
dn=DeleteCases[dns,Void];
xPrint["tuIndexEliminateEta:",noEta,",",eta,",",up,dn,index];
upi=Intersection[up,index];
dni=Intersection[dn,index];xPrint["upi,dni:",upi,dni,Length[Flatten[upi,dni]]];
{noEtadummies,{noEtaup,noEtadn},noEtabad}=tuIndexParser[noEta];
xPrint[{noEtadummies,{noEtaup,noEtadn},noEtabad}];
If[tuFreeQ[Flatten[up,dn],index]||up===dn||Length[Flatten[upi,dni]]<1||
Union[Intersection[up,noEtadn],Intersection[dn,noEtaup]]=={}
,Return[exp]];(*eta has no sum index or same indices*)
xPrint["BB:",up,dn,index,upi,dni];
If[Length[up]==1&&Length[dn]==1,(*updn situation*)
If[tuMemberQ[upi,index]&&Intersection[upi,noEtadn]!={},
tuIndexReplace[upi[[1]],dn[[1]]][noEta],
tuIndexReplace[dni[[1]],up[[1]]][noEta]],

If[Length[up]==2,(*upup situation*)
If[MemberQ[index,up[[1]]]&&Intersection[{up[[1]]},noEtadn]!={},xPrint["UU ",up[[1]],":",up[[2]],":",noEta,":",exp];
tuIndicesRaise[up[[1]],up[[2]]][noEta],
tuIndicesRaise[up[[2]],up[[1]]][noEta]],

If[MemberQ[index,dn[[1]]]&&Intersection[{dn[[1]]},noEtaup]!={},(*dndn situation*)
tuIndicesLower[dn[[1]],dn[[2]]][noEta],
tuIndicesLower[dn[[2]],dn[[1]]][noEta]]

]
]
];

Clear[tuIndexContractUpDn];
tuIndexContractUpDn::usage="tuIndexContractUpDn[\[Delta]_,index_List][exp_] Einstein contracts over index_List for Tensor[\[Delta]_,_,_] contained in exp_(a contractable term: {Times, dotOps}). Only works on expressions with valid index combinations. e.g., exp/. pp: productOps[a_,b__]\[RuleDelayed]tuIndexContractUpDn[g,{d}][pp] *11Nov2015*";
tuIndexContractUpDn[\[Delta]_,index_List][exp_]:=Module[{$=exp,doIt,$test,dummy,error,updn,tensors,$deltas,$pos,$a},(*terms are product of these operators*)
{dummy,updn,error}=tuIndexParser[$];xPrint["00: ",$,":",{dummy,updn,error},":",index];
If[Intersection[dummy,index]=={}||error!={},Return[$]];(*No proper dummy index*)
(***********)
$deltas=$//tuExtractPositionPattern[Tensor[\[Delta],_,_]];(*List of possible deltas*)
xPrint["$deltas: ",$deltas,":",$];
Do[
$pos=$deltas[[ipos]];xPrint["$pos: ",$pos];
If[tuHasNoneQ[$pos[[2]],index],Continue[] ];(*No index*)
$pos=$//tuExtractPositionPattern[  $pos[[2]]  ];xPrint[">>> ",$pos];(*Get $ position*)
If[$pos=={},Continue[]];(*Not found*)
xPrint[">>",$,":",\[Delta],":",$pos[[1]],":",$pos[[1,2,2]],$pos[[1,2,3]]];
$a=Delete[$,$pos[[1,1]]]; xPrint["$a: ",$,":",$a,":",\[Delta],":",$pos[[1,2,2]],$pos[[1,2,3]]];
$=tuIndexEliminateEta[$,$a,\[Delta],$pos[[1,2,2]],$pos[[1,2,3]],index]
,{ipos,Length[$deltas]}
];
$
];
tuIndexContractUpDn[exp_,\[Delta]_,index_]:=tuIndexContractUpDn[\[Delta],index][exp];
subContractUpDn[exp_,\[Delta]_,index_List]:=tuIndexContractUpDn[\[Delta],index][exp];(*Compatibility*)

(*ContractUpDnNot[\[Delta]_,index_List][exp_] Einstein like contraction (up/dn) of terms in exp_ using \[Delta]_ as metric variable. The contraction does NOT use indices in index_List, but the use of other indices is not controlled.  Does not check for proper up/dn relationship in exp_, only the presence of \[Delta] indices as symbol in exp_. Assumes properly formed index relationships in exp_.
CHECK WITH NEW VERSION of ContractUpDn
Repaired*11Dec2012.*)
ContractUpDnNot[\[Delta]_,index_List][exp_]:=Module[{tmp=ExpandAll[exp](*Minimize complex expressions*),sub,up,dn,test,dummy},
test[A_,from_,to_]:=!FreeQ[A,from]&&!MemberQ[{from,to},Void]&&ListFreeQ[from,index];
sub={
Tensor[\[Delta],{up1_,up2_},{dn1_,dn2_}]A_:>tuIndicesLower[dn1,dn2][A]/;test[A,dn1,dn2],
Tensor[\[Delta],{up1_,up2_},{dn1_,dn2_}]A_:>tuIndicesLower[dn2,dn1][A]/;test[A,dn2,dn1],
Tensor[\[Delta],{up1_,up2_},{dn1_,dn2_}]A_:>tuIndicesLower[up1,up2][A]/;test[A,up1,up2],
Tensor[\[Delta],{up1_,up2_},{dn1_,dn2_}]A_:>tuIndicesLower[up2,up1][A]/;test[A,up2,up1],
term:Tensor[\[Delta],ups_,dns_]A_:>If[
Length[up=DeleteCases[ups,Void]]==1&&
Length[dn=DeleteCases[dns,Void]]==1&&
(dummy=tuIndexParser[Tensor[\[Delta],ups,dns]A][[1]])=!={},(*expect only 1 index*)
xPrint[dummy,dn,up];
If[MemberQ[dn,dummy[[1]]],ReplaceIndexTU[dummy[[1]],up[[1]]][A],
If[MemberQ[up,dummy[[1]]],ReplaceIndexTU[dummy[[1]],dn[[1]]][A]]  ]
,
term
]
};
tmp=tmp//.sub
]

(*
Contract[\[Delta]_][exp_] does Kronecker like contraction on exp_ containing Subscript[\[Delta], i,j ]over all i,j indices. No control over which index is used.  Ignores up/dn positions of indices. 
*16Oct2014.*)
Contract[\[Delta]_][exp_]:=Module[{$tmp=ExpandAll[exp](*Minimize complex expressions*),contract,$XX},
(**)
contract[term_,updn0_List,A_]:=Module[{updn,ret=term},
updn=DeleteCases[Flatten[updn0],Void];xPrint[updn];
If[Length[updn]==2,
If[updn[[1]]===updn[[2]],ret=A,xPrint[Xupdn];
If[!ListFreeQ[A,updn],xPrint[xupdn];
ret=If[FreeQ[A,updn[[1]]],
A/.Rule[updn[[2]],updn[[1]]],
A/.Rule[updn[[1]],updn[[2]]]],
xPrint[A];
],
Print[ret];
]
];
ret
];
$tmp//.dd:Tensor[\[Delta],ups_,dns_]A_:>contract[Tensor[$XX[\[Delta]],ups,dns]A,{ups,dns},A]/.$XX[a_]->a (*The $XX helps cover multiple \[Delta]'s. *)
];

Clear[tuKroneckerDeltaEliminate]
tuKroneckerDeltaEliminate::usage="tuKroneckerDeltaEliminate[\[Delta]_,index_List][exp_] eliminates KroneckerDelta \[Delta] indices specified by index_List of productOps terms found in exp_. Leaves 1 in place of \[Delta][] in exp_. *6Oct2016*";
tuKroneckerDeltaEliminate[\[Delta]_,index_List][exp_]:=Module[{$=exp,$p},
$p=$//tuExtractPositionPattern[productOps[__]];
$p=$p//tuPositionNestDelete;
$p=Map[MapAt[Fold[tuKroneckerDeltaEliminate1[\[Delta],{#2}][#1]&,#,index]&,#,2]&,$p];
tuReplacePart[$,$p]
];
tuKroneckerDeltaEliminate1[\[Delta]_,index_List][exp_]:=Module[{$=exp,$1,$s},
If[!MatchQ[Head[exp],productOps],Return[exp]];
$1=$//tuExtractPattern[Tensor[\[Delta],_,_]];
$1=Select[$1,!tuFreeQ[#,index]&];
$1={$1[[1]]};(*Only contract on First \[Delta]*)
$s=tuIndexParser[$1][[2]]//Flatten;
$s=$s[[1]]->$s[[2]];
$s=tuRuleSolve[$s,index];
$=$/.$s/.{T[\[Delta],"dd"][a_,a_]->1,T[\[Delta],"uu"][a_,a_]->1,T[\[Delta],"ud"][a_,a_]->1,T[\[Delta],"du"][a_,a_]->1};
$
];

(*Contract[\[Delta]_,index_List][exp_] does Kronecker contraction on terms in exp_ containing \[Delta] over ONLY indices contained in index_List.  Ignores up/dn positions of indices. 
26Apr2012.*)
Contract[\[Delta]_,index_List][exp_]:=Module[{tmp=ExpandAll[exp](*Minimize complex expressions*),sub,updn},
sub={
Tensor[\[Delta],ups_,dns_]A_:>If[
Length[(updn=Flatten[{DeleteCases[ups,Void],DeleteCases[dns,Void]}])]==2&&! ListFreeQ[A,updn]&&!ListFreeQ[updn,index],
(A/.updn[[1]]:>updn[[2]]/;MemberQ[index,updn[[1]]]/.updn[[2]]:>updn[[1]]/;MemberQ[index,updn[[2]]]),
Tensor[\[Delta],ups,dns]A
]
};
tmp=tmp//.sub
];
(*ContractNot[\[Delta]_,index_List][exp_] does Kronecker contraction on terms in exp_ containing \[Delta] over all indices EXCEPT ones in index_List.  Ignores up/dn positions of indices. 
26Apr2012.*)
ContractNot[\[Delta]_,index_List][exp_]:=Module[{tmp=ExpandAll[exp](*Minimize complex expressions*),sub,updn},
sub={
Tensor[\[Delta],ups_,dns_]A_:>If[
Length[(updn=Flatten[{DeleteCases[ups,Void],DeleteCases[dns,Void]}])]==2&&! ListFreeQ[A,updn],
(A/.updn[[1]]:>updn[[2]]/;!MemberQ[index,updn[[1]]]/.updn[[2]]:>updn[[1]]/;!MemberQ[index,updn[[2]]]),
Tensor[\[Delta],ups,dns]A
]
};
tmp=tmp//.sub
];

(*
SwapListsN[a1_List,b1_List,i_Integer] swaps element i_Integer between a1_List and b1_List. *13Sep2012*)
SwapListsN[a1_List,b1_List,i_Integer]:=Module[{$h,a=a1,b=b1},
$h=a[[i]];  a[[i]]=b[[i]];  b[[i]]=$h;
{a,b}
];
(**)
tuIndicesLower::usage="tuIndicesLower[from_,to_:{}][exp_] lowers from_ indices to to_ indices. from_ and to_ may be lists of indices then the lowering is performed pairwise.  If to_ is omitted or not equal in Length then to_ = from_.  *29May2015*";
tuIndicesLower[from_,to_:{}][exp_]:=Module[{$=exp,$s,$f=Flatten[{from}],$t=Flatten[{to}]},
If[Length[$f]!=Length[$t],$t=$f];
$s=Thread[tuIndexLowerAll[$f,$t]];
Fold[#2[#1]&,$,$s]
];
(**)
tuIndexLowerAll::usage="tuIndexLowerAll[from_,to_][exp_] lowers one index from_ to to_ found in exp_.  Handles indices in DerivOpsD to DerivOpsU *20Jun2015*";
tuIndexLowerAll[from_,to_][exp_]:=
Module[{upD,dnD,opD,subd,ipos,ip,xexp,xfrom,xto,$Pattern},
opD=DerivOpsU;
upD=Apply[List,opD];
dnD=Apply[List,DerivOpsD];
subd=Thread[Rule[upD,RemovePatterns[dnD]]];
subd=Map[Map[#/.a_:>If[Head[a]===Symbol,a,Head[a]]&,#]&,subd];
{xexp,xfrom,xto}=Map[#//.Pattern->$Pattern&,{exp,from,to}];
xexp=xexp//.t$:Tensor[A_,u_List,d_List]:>tuIndexLower[xfrom,xto][t$];
xexp=xexp//.(OP:opD)[a_,b_]:>(OP//.subd)[a,xto]/;(b//.Pattern->$Pattern)==xfrom;
xexp//.$Pattern->Pattern
];
(**)
tuIndexRaiseAll::usage="tuIndexRaiseAll[from_,to_][exp_] raises one index from_ to to_ found in exp_.  Handles indices in DerivOpsD to DerivOpsU *20Jun2015*"
tuIndexRaiseAll[from_,to_][exp_]:=
Module[{upD,dnD,opD,subd,ipos,ip,xexp,xfrom,xto,$Pattern},
opD=DerivOpsD;
dnD=Apply[List,opD];
upD=Apply[List,DerivOpsU];
subd=Thread[Rule[dnD,RemovePatterns[upD]]];
subd=Map[Map[#/.a_:>If[Head[a]===Symbol,a,Head[a]]&,#]&,subd];
{xexp,xfrom,xto}=Map[#//.Pattern->$Pattern&,{exp,from,to}];
xexp=xexp//.t$:Tensor[A_,u_List,d_List]:>tuIndexRaise[xfrom,xto][t$];
xexp=xexp//.(OP:opD)[a_,b_]:>(OP/.subd)[a,xto]/;(b//.Pattern->$Pattern)==xfrom;
xexp//.$Pattern->Pattern
];
(**)
tuIndicesRaise::usage="tuIndicesRaise[from_,to_:{}][exp_] raises from_ indices to to_ indices. from_ and to_ may be lists of indices then the raising is performed pairwise.  If to_ is omitted or not equal in Length then to_ = from_.  *29May2015*";
tuIndicesRaise[from_,to_:{}][exp_]:=Module[{$=exp,$s,$f=Flatten[{from}],$t=Flatten[{to}]},
If[Length[$f]!=Length[$t],$t=$f];
$s=Thread[tuIndexRaiseAll[$f,$t]];
Fold[#2[#1]&,$,$s]
] ;

tuIndexRaise::usage="tuIndexRaise[var1_,var2_][A_Tensor] raises index var1_ to var2_ in A_Tensor. eg: $exp/. tt:Tensor[\[Gamma],{_},{ii:_}]\[RuleDelayed]tuIndexRaise[ii,ii][tt] *23Apr2015*";
tuIndexRaise[var1_,var2_][A_Tensor]:=
Module[{Name$,u$,d$,$swap},{Name$,u$,d$}=Apply[List,A];
{d$,u$}=If[MemberQ[d$,var1],d$=d$//.var1->$swap;SwapVarFromAtoB[$swap,d$,u$],{d$,u$}];
{d$,u$}={d$,u$}//.$swap->var2;
Tensor[Name$,u$,d$]
];
RaiseTensorIndex[A_Tensor,var1_,var2_]:=tuIndexRaise[var1,var2][A];

(**)
tuIndexLower::usage="tuIndexLower[var1_,var2_][A_Tensor] lowers index var1_ to var2_ in A_Tensor. eg: $exp/. tt:Tensor[\[Gamma],{ii:_},{_}]\[RuleDelayed]tuIndexLower[ii,ii][tt] *23Apr2015*";
tuIndexLower[var1_,var2_][A_Tensor]:=
Module[{Name$,u$,d$,$swap},{Name$,u$,d$}=Apply[List,A];
{u$,d$}=If[MemberQ[u$,var1],u$=u$//.var1->$swap;SwapVarFromAtoB[$swap,u$,d$],{u$,d$}];
{d$,u$}={d$,u$}//.$swap->var2;
Tensor[Name$,u$,d$]
];
LowerTensorIndex[A_Tensor,var1_,var2_]:=tuIndexLower[var1,var2][A];

(**)
tuIndexReplace::usage="tuIndexReplace[from_,to_][exp_] replaces all indices in exp_ from from_ to to_. *16Sep2015"
tuIndexReplace[from_,to_][exp_]:=Module[{
upD,dnD,subd,
ipos,xexp,xfrom,xto,ip,$Pattern
},
upD=DerivOpsU;
dnD=DerivOpsD;
{xexp,xfrom,xto}=Map[#//.Pattern->$Pattern&,{exp,from,to}];
xexp=xexp//.Tensor[A_,u_,d_]:>Tensor[A,ReplacePart[u,ip->xto],d]/;
Length[u]>0&&(ipos=Position[u,xfrom,1])=!={}&&(ip=ipos[[1,1]])>0;
xexp=xexp//.Tensor[A_,u_,d_]:>Tensor[A,u,ReplacePart[d,ip->xto]]/;
(Length[d]>0&&(ipos=Position[d,xfrom,1])=!={}&&(ip=ipos[[1,1]])>0);
xexp=xexp//.(OP:Apply[Alternatives,Join[upD,dnD]])[a_,b_]:>OP[a,xto]/;(b//.Pattern->$Pattern)==xfrom;xPrint["ReplaceIndexTU:",xexp];
xexp//.$Pattern->Pattern
];
ReplaceIndexTU[from_,to_][exp_]:=tuIndexReplace[from,to][exp];(*Compatibility*)
(**)
tuTensorIndexSwap::usage="tuTensorIndexSwap[slot1_Integer,slot2_Integer][tensor_Tensor] swaps slot1_ and slot2_ indices of tensor_  *22May2015*";
tuTensorIndexSwap[slot1_Integer,slot2_Integer][tensor_Tensor]:=Module[{$n,$u,$d,$},
{$n,$u,$d}=Apply[List,tensor];xPrint[{$n,$u,$d}];
If[Length[$u]<Max[slot1,slot2],Return[tensor]];(*Input Error. Do nothing.*)

If[$u[[slot1]]=!=Void&&$u[[slot2]]=!=Void,
$=$u[[slot1]];$u[[slot1]]=$u[[slot2]];$u[[slot2]]=$,
If[$d[[slot1]]=!=Void&&$d[[slot2]]=!=Void,
$=$d[[slot1]];$d[[slot1]]=$d[[slot2]];$d[[slot2]]=$,
If[$d[[slot1]]=!=Void&&$u[[slot2]]=!=Void,
$=$d[[slot1]];$d[[slot1]]=$u[[slot2]];$u[[slot2]]=$,
If[$u[[slot1]]=!=Void&&$d[[slot2]]=!=Void,
$=$u[[slot1]];$u[[slot1]]=$d[[slot2]];$d[[slot2]]=$
]]]];
Apply[Tensor,{$n,$u,$d}]
];
(**)
tuIndexSwap::usage="tuIndexSwap[index1_,index2_][exp_] swaps indexPair of Tensor's in exp_. EG: tuIndexSwap[i,j][\!\(\*SubscriptBox[\(A\), \(ikj\)]\)]->\!\(\*SubscriptBox[\(A\), \(jki\)]\) .  [index1_,index2_] can be input as [{index1_,index2_}].  *4Nov2014*";
tuIndexSwap[index1_,index2_|PatternSequence[]][exp_]:=Module[{tmp=exp,ind1,ind2,$ii,subi,CX},
{ind1,ind2}=Flatten[{index1,index2}];
subi[i_List]:=If[SameQ[#,ind2],CX[ind1],If[SameQ[#,ind1],CX[ind2],#]]&/@i;
tmp=tmp//. Tensor[A_,u_,d_]:>xTensor[A,subi[u],subi[d]];

tmp=tmp//.(dd:DerivOps)[A_,i_]:>CX[dd][A,ind2]/;SameQ[i,ind1];
tmp=tmp//.(dd:DerivOps)[A_,i_]:>CX[dd][A,ind1]/;SameQ[i,ind2];
tmp=tmp//.CX[a_]->a//.xTensor->Tensor
];
IndexSwap:=tuIndexSwap;
(**)
tuIndexSwapUpDown::usage="tuIndexSwapUpDown[index_][exp_] swaps UpDn position of index_ in exp_. index_ may be List in which case the indices are Fold[]d over List. *22Oct2015*";
tuIndexSwapUpDown[index_][exp_]:=Module[{tmp=exp,XXXX,YYYY},
If[Head[index]=!=List,
tmp=tmp//tuIndicesLower[index,XXXX];
tmp=tmp//tuIndicesRaise[index,YYYY];
tmp=tmp/.XXXX->index/.YYYY->index,
tmp=Fold[tuIndexSwapUpDown[#2][#1]&,exp,index]
];
tmp
];
UpDownIndexSwap[index_][exp_]:=tuIndexSwapUpDown[index][exp];(*Compatibility*)

(*
UpDownIndexSwap[upos_Integer,dpos_Integer][tensor_Tensor] swaps indices of tensor_Tensor by position [upos_Integer,dpos_Integer] There are NoChecks on inputs. *23July2012 *)
UpDownIndexSwap[upos_Integer,dpos_Integer][tensor_Tensor]:=Module[{tmp=tensor,$d,$u,xtmp},
xtmp=tmp=Apply[List,tmp];
$u=tmp[[2]];
$d=tmp[[3]];
tmp[[2]]=ReplacePart[$u,{dpos->$d[[dpos]],upos->$d[[upos]]}];
tmp[[3]]=ReplacePart[$d,{upos->$u[[upos]],dpos->$u[[dpos]]}];
Apply[Tensor,tmp]
];
(* Eliminates index m_ from exp_ containing \[Delta]uu[m_,n].  NEEDS expanding to \[Delta]ud, \[Delta]du, \[Delta]dd.  A strick version would check for proper up and down indices. *)
Simplify\[Delta]uu[exp_,m_]:=Module[{tmp=exp,tmp1,ind=m,DEBUG=0,mname="Simplify\[Delta]uu"},
While[tmp1=!=tmp,
tmp1=tmp;
tmp=tmp//.{
a_ \[Delta]@uu[m,b_]:>(a/.m->b)/;!FreeQ[{a},m]&&m=!=b,
a_ \[Delta]@uu[b_,m]:>(a/.m->b)/;!FreeQ[{a},m]&&m=!=b
};
IfDEBUG[mname,DEBUG>0,{m,tmp},"{m,tmp}"];
];
tmp
];

(*Simple index swapping routine across xPartialD.  A^m xPartialD[Subscript[A, m],n]-> Subscript[A, m] xPartialD[A^m,n].  WARNING there are no checks. *)
RaiseIndexInxPartialD[exp_]:=Module[{tmp,DEBUG=0,mName="RaiseIndexInxPartialD"},
IfDEBUG[mName,DEBUG>0,{exp},"input"];
tmp=exp/.c_ xPartialD[a_,b_]:>SwapIndexPartialD[{c,a,b}];
tmp=exp/.c_ xCovariantD[a_,b_]:>SwapIndexPartialD[{c,a,b}];
IfDEBUG[mName,DEBUG>0,{tmp},"tmp"];
tmp
];
(*Swaps indices in list {A^m,Subscript[A, m],mu}-> Subscript[A, m]xPartialD[A^m,mu].  Only one way->
 NEEDS two-way swap *)
SwapIndexPartialD[list_]:=Module[{indexdown,tmp1=list,DEBUG=0,mName="SwapIndexPartialD"},
indexdown=ParseTermIndices[tmp1[[2]]][[2,2]];
IfDEBUG[mName,DEBUG>0,{tmp1,indexdown},"tmp1,indexdown"];
If[indexdown=!={},
indexdown=First[indexdown];
tmp1[[1]]=tmp1[[1]]//LowerIndex[indexdown,indexdown];
tmp1[[2]]=tmp1[[2]]//RaiseIndex[indexdown,indexdown];
];
IfDEBUG[mName,DEBUG>0,{tmp1},"tmp1"];
tmp1[[1]]xPartialD[tmp1[[2]],tmp1[[3]]]
];

xPartialDuLower[exp_]:=Module[{},MetricContractG[exp/.xPartialDu[a_,b_]->xPartialD[a,dum[b]]g@uu[dum[b],b]]/.dum[a_]->a
];

(**)
tuMetricProperTime::usage:="tuMetricProperTime[exp_] produces a list of metric elements from an expression representing the proper time, d[s\!\(\*SuperscriptBox[\(]\), \(2\)]\)->f[x,x]d[x]d[x]+f[x,y]d[x]dy]. The list contains both up,up and down,down forms of the Tensor[g,_,_].  Only non-zero enters are output. Index labels are taken from the d[]'s in exp_.  The output also contains detg\[Rule]Det[T[g,dd,{_,_}]], gvars\[Rule]indices of Tensor[g,_,_],   gmatrixdd\[Rule]full Matrix of T[g,dd,{_,_}], gmatrixuu\[Rule]full Matrix of T[g,uu,{_,_}],  NOTE: Only produces symmetric Tensor[g].  The Det[g] that is often seen Det[-g] is the Det[] of the T[g,dd,{_,_}] metric tensor. *17Feb2017*2Feb2018*22Feb2018*"
tuMetricProperTime[exp_]:=Module[{$ds2=exp,$,$dvars,$vars,$gmatrix,$gmatrixI,$gdd,$guu,$detg},
$ds2=$ds2/. Rule[ds_,a_]->a;(*remove d[s]^2\[Rule] *)
$dvars=$ds2//tuExtractPattern[d[_]]//DeleteDuplicates;
$vars=#[[1]]&/@$dvars;
$gmatrix=CoefficientArrays[$ds2,$dvars]//Part[#,3]&//Symmetrize[#,Symmetric[All]]&//Normal;
$gdd=Table[T[g,"dd",{i,j}],{i,$vars},{j,$vars}];
$guu=Table[T[g,"uu",{i,j}],{i,$vars},{j,$vars}];
$gdd={$gdd,$gmatrix};
$gdd=MapThread[Rule,$gdd,2];xPrint[$gdd];
$guu={$guu,$gmatrixI=Inverse[$gmatrix]};
$guu=MapThread[Rule,$guu,2];xPrint[$guu];
$detg=Det[$gmatrix]//Simplify;
Flatten[{gvars->$vars,$gdd,$guu,detg->$detg,gmatrixdd->$gmatrix,gmatrixuu->$gmatrixI}]
];

(*
d[x]d[y]f[x,y]+d[x]^2f[xx]-d[y]^2f[yy]-d[y]d[z]f[y,z]
tuMetricProperTime[%]//ColumnForms
*)

(*Contracts metric tensor, g_, in exp_ where possible.  DOES NOT RECOGNIZE g_. *)
(*Does not handle g[i,j]fn[a[i]+b[i]] like expressions Replaced MatricContract[]*)
MetricContractGexp[g_][exp_]:=Module[{exp1=exp,tmp,tmp1,tmp2,pos,ipos,tmpp,tmpp1,posg,iposg,indexg,post,ipost,gUsed},
(*First do simple g contractions*)
exp1=Expand[exp1]//MetricContractG;
(*extract g_ products assuming g's are not embedded.*)
pos=exp1//tuExtractPositionPattern[Times[a___,Tensor[g,_,_],b___]];
For[ipos=1,ipos<=Length[pos],ipos++,
tmpp1=tmpp=pos[[ipos,2]];
posg=tmpp//tuExtractPositionPattern[Tensor[g,_,_]];
(* Go through and contract each g Tensor in product tmpp  *)
For[iposg=1,iposg<=Length[posg],iposg++,
(*eliminate one g and test for possible summing Tensors(may include other g's)*)
tmpp1=tmpp1/.Last[ posg[[iposg]] ]->1;
(*Examine remaining Tensors(possibly imbedded)*)
post=tmpp1//tuExtractPositionPattern[Tensor[_,_,_]];
List["post:",post];
gUsed=posg;
For[ipost=1,ipost<=Length[post],ipost++,
tmp=post[[ipost,2]]posg[[iposg,2]];
tmp1=tmp//MetricContractG;
If[tmp=!=tmp1,(*If contracted, store new and do not use g again*)
post[[ipost,2]]=tmp1;gUsed[[iposg,2]]=1;posg[[iposg,2]]=1;
];
];
tmpp1=ReplacePart[tmpp1,post];
];
tmp=Apply[Times,Map[Last,gUsed]];
pos[[ipos,2]]=tmp tmpp1;
];
exp1=ReplacePart[exp1,pos]
];

(**)

tuMetricContract::usage="tuMetricContract[g_][exp_Times] Contracts (alla Einstein) exp_Times (Times expression) over metric g_. Changed to T[g,uu,{_,_}] Tensor notation. * 12Jul2016*";
tuMetricContract[g_][exp_Times]:=Module[{gterm,$u0,$d,$u,$d0,$c,tmp=exp,tmp1,tmp2,gpos,gpos1,ipos,pos,gvar,Igvar,Itmp2,gpat=T[g,"uu",{a_,b_}]|T[g,"dd",{a_,b_}]|T[g,"ud",{a_,b_}]|T[g,"du",{a_,b_}]},
gpos1=gpos=tmp//tuExtractPositionPattern[gpat];xPrint[gpos1];
While[tmp=!=tmp1,tmp1=tmp;
gpos1=gpos=tmp//tuExtractPositionPattern[gpat];
For[ipos=1,ipos<=Length[gpos]&&tmp==tmp1,ipos++,
pos=gpos1[[ipos,1]];gvar=gpos1[[ipos,2]];
tmp2=ReplacePart[tmp,{pos}->1];
Igvar=tuIndexParser[gvar];
Itmp2=tuIndexParser[tmp2];
xPrint["tmp2:",{tmp2,Itmp2}];
tmp=Which[
($u0=Intersection[ Itmp2 [[2,1]],$d=Igvar[[2,2]]])=!={}&&Length[$d]==2,
tuIndicesLower[$u0[[1]],$c=Complement[$d,{$u0[[1]]} ]  [[1]]][tmp2] ,
($d0=Intersection[ Itmp2 [[2,2]],$u=Igvar[[2,1]]])=!={}&&Length[$u]==2,
tuIndicesLower[$d0[[1]],$c=Complement[$u,{$d0[[1]]} ]  [[1]]][tmp2] ,
($u0=Intersection[ Itmp2 [[2,1]],$d=Igvar[[2,2]]])=!={}&&Length[$d]==1,
ReplaceIndexTU[$u0[[1]],$c= Igvar[[2,1]] [[1]] ] [tmp2] ,
($d0=Intersection[ Itmp2 [[2,2]],$u=Igvar[[2,1]]])=!={}&&Length[$u]==1,
ReplaceIndexTU[$d0[[1]],$c=Igvar[[2,2]]  [[1]]][tmp2]  ,
True,
tmp
];(*xPrint[Imply,gvar[$u0[[1]],$c]\[Rule]{tmp}];*)
];
];
tmp
];
MetricContract[g_][exp_Times]:=tuMetricContract[g][exp];
(**)
tuMetricContractAll::usage="tuMetricContractAll[g_][exp_] applies tuMetricContract[g][term] over all Times[] terms in exp_. ";
tuMetricContractAll[g_][exp_]:=Module[{},
tmp=Expand[exp]/.term:HoldPattern[Times[a__]]:>tuMetricContract[g][term]
];
MetricContractAll[g_][exp_]:=tuMetricContractAll[g][exp];

(*Adds contraction: gud[a_,a_] | gdu[a_,a_]-> dimension **May want to separate this function** 27Mar2012 *)
MetricContract[g_,trace\[Eta]_][exp_]:=Module[{tmp=Expand[exp]},
tmp=tmp//tuMetricContract[g];
tmp=tmp//.{T[g,"ud",{a_,a_}]->trace\[Eta],T[g,"du",{a_,a_}]->trace\[Eta]}
];
(**)
MetricContractAll[g_,trace\[Eta]_][exp_]:=Module[{tmp},
tmp=Expand[exp]/.term:HoldPattern[Times[a__]]:>MetricContract[g,trace\[Eta]][term]
];
(*Wick rotation of Vector contractions *)
VectorContractWickSub={Tensor[a_,{\[Mu]_},{Void}]Tensor[b_,{Void},{\[Mu]_}]:>-Tensor[a,{space@\[Mu]},{Void}]Tensor[b,{Void},{space@\[Mu]}]/;FreeQ[\[Mu],space],
Tensor[a_,{\[Mu]_},{Void}][c_]Tensor[b_,{Void},{\[Mu]_}]:>-Tensor[a,{space@\[Mu]},{Void}][TUc]Tensor[b,{Void},{space@\[Mu]}]/;FreeQ[\[Mu],space],
Tensor[a_,{\[Mu]_},{Void}]Tensor[b_,{Void},{\[Mu]_}][c_]:>-Tensor[a,{space@\[Mu]},{Void}]Tensor[b,{Void},{space@\[Mu]}][c]/;FreeQ[\[Mu],space],
Tensor[a_,{\[Mu]_},{Void}][c_]Tensor[b_,{Void},{\[Mu]_}][d_]:>-Tensor[a,{space@\[Mu]},{Void}][c]Tensor[b,{Void},{space@\[Mu]}][d]/;FreeQ[\[Mu],space]
};
(*ExpandSpaceTimeIndex Einstein expands exp_ each index_List over timespace@index_List.  This routine is to facilitate time and spatial vector notation.  Note the index arguement does not need timespace flavor. Added \[Delta]-functionexpansion.  BUG: does not accept indices in functional form. NOTE: Use EinsteinSum[] instead!! DO NOT USE PROBLEMS *14Dec2012*)
ExpandSpaceTimeIndex[index_List][exp_]:=Module[{tmp=exp,indexST,DEBUG=0,mname="ExpandSpaceTimeIndex"},
indexST=timespace/@index;
IfDEBUG[mname,DEBUG>0,{indexST,exp},"{indexST,exp}"];
(*\[Delta]-function need special treatment.  Only for Length[index_List]==1. .*)
tmp=Map[tmp/. ddd:\[Delta][a_]:>If[!FreeQ[Flatten[ExpressionIndices[a]],#] ,
IndexSwap[{#,timespace@0}][\[Delta][a]]IndexSwap[{#,timespace@1}][\[Delta][a]]  ,
ddd]&,index]  [[1]];
IfDEBUG[mname,DEBUG>0,{tmp},"{tmp\[Delta]}"];

tmp=IndexSwap[{#,timespace@#}][tmp]&/@index//First;
tmp=tmp//.timespace@timespace@i_->timespace@i;(*Eliminate doubles*)
IfDEBUG[mname,DEBUG>0,{tmp},"{tmp}"];
If[Head[tmp]===Rule,
tmp=Apply[Rule,SumExpansion[indexST][Apply[List,tmp]]],
tmp=tmp//SumExpansion[indexST]
];
tmp=tmp/.IndexChange->IndexChangeTU;(*In case IndexChange fails*)
IfDEBUG[mname,DEBUG>0,{tmp},"{tmp1}"];
tmp=tmp/.g->\[Eta]
];

(*
timespaceindex[index_List][exp_] replaces all indices \[Element] index_List in exp_ to timespace@indices.  *11Jul2013*)
timespaceindex[index_List][exp_]:=Module[{tmp,tmp0=exp,pos,sub,UDrules,$i,$in},
sub=Map[#->timespace@#&,DeleteDuplicates[index]];
pos=tmp0//tuExtractPositionPattern[IndexVarPatterns];
For[$i=1,$i<=Length[pos],$i++,
xPrint[pos[[$i,2]],$in=Flatten[tuIndexParser[pos[[$i,2]]]]];
If[ListMemberQ[$in,index],pos[[$i,2]]= pos[[$i,2]]/.sub];
];
xPrint[pos];
ReplacePartTU[tmp0,pos]
];

(*
GroupTimeSpaceProducts[exp_] expands dummy indices into timespace@{0,1} grouping the paired result in xDot[] *12Oct2012*)
GroupTimeSpaceProducts[exp_]:=Module[{tmp,ExpandDummies,subgroup},
subgroup=(A:Tensor[a__])(B:Tensor[ b__]):>xDot[A,B]/;!FreeQ[tuIndexParser[A B][[1]],timespace]&&FreeQ[A B,xDot];
ExpandDummies[prod_]:=Module[{dummies,tmp1=prod},
dummies=tuIndexParser[prod][[1]];
tmp1=Fold[(ExpandSpaceTimeIndex[{#2}][#1]/.subgroup)&,tmp1,dummies];
tmp1
];
tmp=exp//Expand;
tmp=tmp/.HoldPattern[Times[a__]]:>ExpandDummies[Times[a]]
];
(*
UpDn2Cos is Rule for taking Einstein UpDn timespace indices of products and raising them to contravariant indices and applying Cos[] to timespace@1 components.   *30Nov2012*)
UpDn2Cos:={T[Subscript[k_, i_],"d"][timespace@1]T[Subscript[k_, j_],"u"][timespace@1]:>-T[ Subscript[k, i],"u"][timespace@1]T[ Subscript[k, j],"u"][timespace@1] Cos[Subscript[\[Theta], Sort[{i,j}]]],T[Subscript[k_, i_],"d"][timespace@0]T[Subscript[k_, j_],"u"][timespace@0]->T[Subscript[k, i],"u"][timespace@0]T[Subscript[k, j],"u"][timespace@0]}

(*Sums over indexRange, e.g., {i,1,3} in expression exp_.  Preprocesses with DotExpand and Expand.  Does not check proper reference to index. *)
SumIndex[indexRange_List][exp_]:=Module[{tmp,out=0,index=First[indexRange],DEBUG=0,mname="SumIndex"},
tmp=exp//.DotExpand//Expand;
IfDEBUG[mname,DEBUG>0,{index,tmp,Length[tmp]},"index,tmp,Length[tmp]"];
For[$i=1,$i<=Length[tmp],$i++,
$t=tmp[[$i]];
IfDEBUG[mname,DEBUG>0,{index,$t},"index,t"];
If[!FreeQ[$t,index],
$t=Sum[$t,indexRange];
IfDEBUG[mname,DEBUG>0,{$i,$t},"$i,$t"];
];
out+=$t;
];
out
];
(*
ExpandIndex[indexRange_List][exp_] sums exp_ for every term with Head in ops  containing index pair over range specified in indexRange_. *2Mar2013*)
ExpandIndex[indexRange_List][exp_]:=Module[{tmp=ExpandAll[exp],ops=Times|Dot|Wedge|xDot,$t,$ind,head,term},
$ind=Thread[indexRange[[1]]->Range[Apply[Sequence,Rest[indexRange]]]];
tmp=tmp//.(OP:ops)[a___,b_Plus,c___]:>Distribute[OP[a,b,c]]//ExpandAll;
tmp=tmp/.(OP:ops)[a__]:>If[MemberQ[PairedDummies[Times[a]],First[indexRange]],
Apply[Plus,Map[OP[a]/.#&,$ind]],OP[a]];
tmp
];

(*Rotates indices in index_List of exp_ n_ times. e.g., RotateIndex[{i,j,k},2][A[i,j,k]]->A[k,i,j].  n>0 Rotates left, n<0 Rotates right. *)
RotateIndex[index_List,n_Integer][exp_]:=Module[{tmp=exp,cycle,nindex=index,nn=Abs[n],sub},
cycle=Range[Length[index]];
If[n>0,cycle=Reverse[cycle]];
Do[  nindex=Permute[nindex,Cycles[{cycle}]],{nn}  ];
sub=MapThread[Rule,{index,nindex}];
tmp=tmp/.sub
];
(**)
tuIndexAdd::usage="tuIndexAdd[uploc_:Null,upvalue_:Null,dnloc_:Null,dnvalue_:Null][tensor_Tensor] adds indices to tensor_Tensor at uploc_ with upvalue_ and at dnloc_ with value dnvalue_.  Careful of the dnloc_ after specifying uploc_. *8Dec2015*";
tuIndexAdd[uploc_:Null,upvalue_:Null,dnloc_:Null,dnvalue_:Null][tensor_Tensor]:=Module[{uplist,dnlist},
uplist=tensor[[2]];
dnlist=tensor[[3]];
If[uploc=!=Null,
uplist=Insert[uplist,upvalue,uploc];
dnlist=Insert[dnlist,Void,uploc]
];
If[dnloc=!=Null,
uplist=Insert[uplist,Void,dnloc];
dnlist=Insert[dnlist,dnvalue,dnloc]
];
Tensor[tensor[[1]],uplist,dnlist]
];
PrependIndex[t_Tensor,du_,val_]:=If[du==="u",tuIndexAdd[1,val,Null,Null][t],tuIndexAdd[Null,Null,1,val][t]];(*Compatibility*)
AddUpIndex[uploc_,upvalue_][tensor_Tensor]:=tuIndexAdd[uploc,upvalue,Null,Null][tensor];(*Compatibility*)
AddDnIndex[dnloc_,dnvalue_][tensor_Tensor]:=tuIndexAdd[Null,Null,dnloc,dnvalue][tensor];(*Compatibility*)

(*Prepends index val_ in du_ position to Tensor t_.  3Apr2012 *)
(*PrependIndex[t_Tensor,du_,val_]:=Module[{},
tmp=Apply[List,t];
If[du==="d",tmp[[2]]=Prepend[tmp[[2]],Void];tmp[[3]]=Prepend[tmp[[3]],val]];
If[du==="u",tmp[[2]]=Prepend[tmp[[2]],val ];tmp[[3]]=Prepend[tmp[[3]],Void]];
Apply[Tensor,tmp]
];*)
(*AddUpIndex[uploc_,upvalue_][tensor_Tensor] add up index in tensor_ at location uploc_ with value upvalue_ .*)
(*AddUpIndex[uploc_,upvalue_][tensor_Tensor]:=Module[{uplist,dnlist},
uplist=tensor[[2]];
dnlist=tensor[[3]];
uplist=Insert[uplist,upvalue,uploc];
dnlist=Insert[dnlist,Void,uploc];
Tensor[tensor[[1]],uplist,dnlist]
];*)
(*AddDnIndex[dnloc_,dnvalue_][tensor_Tensor] add down index in tensor_ at location dnloc_ with value dnvalue_ .*)
(*AddDnIndex[dnloc_,dnvalue_][tensor_Tensor]:=Module[{uplist,dnlist},
uplist=tensor[[2]];
dnlist=tensor[[3]];
uplist=Insert[uplist,Void,dnloc];
dnlist=Insert[dnlist,dnvalue,dnloc];
Tensor[tensor[[1]],uplist,dnlist]
]*)
(*AddUpDnDum[tensor_Tensor] adds corresponding up,dn a_ index to dum[a_] indices*)
AddUpDnDum[tensor_Tensor]:=Module[{tmp=tensor,tmpc},
tmpc=Cases[tmp[[2]],dum[_]];
Do[tmp=AddDnIndex[-1,tmpc[[i]][[1]]][tmp],{i,Length[tmpc]}];
tmpc=Cases[tmp[[3]],dum[_]];
Do[tmp=AddUpIndex[-1,tmpc[[i]][[1]]][tmp],{i,Length[tmpc]}];
tmp
];
(**)
tuIndexDeleteAt::usage="tuIndexDeleteAt[loc_Integer][tensor_Tensor] remove index at location loc_Integer of tensor_Tensor. *23Jul2015*";
tuIndexDeleteAt[loc_Integer][tensor_Tensor]:=Module[{uplist,dnlist},
uplist=tensor[[2]];
dnlist=tensor[[3]];
uplist=Delete[uplist,loc];
dnlist=Delete[dnlist,loc];
Tensor[tensor[[1]],uplist,dnlist]
];
DeleteIndex[loc_Integer][tensor_Tensor]:=tuIndexDeleteAt[loc][tensor];(*Compatibility*)
(**)
tuIndexDelete::usage="tuIndexDelete[ind_][tensor_Tensor] removes index ind_ of tensor_Tensor. *23Jul2015*";
tuIndexDelete[ind_][tensor_Tensor]:=Module[{uplist,dnlist,uppos,dnpos,delete},
uplist=tensor[[2]];
dnlist=tensor[[3]];
uplist=Position[uplist,ind];
dnlist=Position[dnlist,ind];
delete={uplist,dnlist}//Flatten//DeleteDuplicates;
uplist=Delete[tensor[[2]],delete];
dnlist=Delete[tensor[[3]],delete];
Tensor[tensor[[1]],uplist,dnlist]
];
DeleteIndex[index_][tensor_Tensor]:=tuIndexDelete[index][tensor];(*Compatibility*)
(**)
tuIndexDeleteAll::usage="tuIndexDeleteAll[index_][exp_] applies tuIndexDelete on all Tensor[]s in exp_ over index_. index_ can be List[]. *17Nov2015*";
tuIndexDeleteAll[index_][exp_]:=Module[{$=exp,$index=Flatten[{index}],$s},
$s=Thread[tt:Tensor[_,_,_]:>tuIndexDelete[#][tt]&/@$index];xPrint[$s];
$=tuRepeat[$s][$]
];

(*DeleteIndexExcept[ind_][tensor_Tensor] deletes indices of tensor_ that match ind_ *)
DeleteIndexExcept[ind_][tensor_Tensor]:=Module[{uplist,dnlist,uppos,dnpos,delete},
uplist=tensor[[2]];
dnlist=tensor[[3]];
tmp=uplist=Map[If[!MemberQ[{#},ind]&&#=!=Void,delete[#],#]&,uplist];
uppos=Position[uplist,delete[_]];
uplist=Delete[uplist,uppos];
dnlist=Delete[dnlist,uppos];
dnlist=Map[If[!MemberQ[{#},ind]&&#=!=Void,delete[#],#]&,dnlist];
dnpos=Position[dnlist,delete[_]];
uplist=Delete[uplist,dnpos];
dnlist=Delete[dnlist,dnpos];
Tensor[tensor[[1]],uplist,dnlist]
];

(*TensorIndex\[Delta]{tensor_List}[exp_] changes Tensors, e.g., Auu[i,j,k], in tensor_List, e.g., {Auu[i,l_,m_]},  where the Patterns, {l_,m_}, indicates indices to act on, to form Auu[i,dum[j],dum[k]] . \[Delta]du[dum[j],j] . \[Delta]du[dum[k],k] where {dum[j],dum[k]} represent Einstein summed indices.  The purpose of this function is to transform exp_ to a form that allows EinsteinSum expressions to be functionally differentiated by Mathematica properly in Tensor expressions.  The action of \[Delta] will yield proper form.
*)
Tensor\[Delta]Index[tensor_List][exp_]:=Module[{tmp(*apply on each Times term*),
sub,sub1,sub0,f1,dd},
xPrint["tensor:",tensor];
(*change Tensor\[Rule] \[Delta].Tensor*)
tmp=Map[#/.Tensor[a_,b_,c_]:>Tensor[\[Delta],b,c].Tensor[a,b,c]&,tensor];
xPrint["tmp:",tmp];
tmp=tmp/.Pattern->xPattern/.xPattern[a_,Blank[]]->dum[a];
xPrint["tmp:",tmp];
tmp=tmp/.Tensor[\[Delta],a_,b_]:> SwapUpDownIndices[Flatten[{Cases[a,dum[_]],Cases[b,dum[_]]}]][Tensor[\[Delta],a,b]];
tmp=tmp/.Tensor[\[Delta],a_,b_]:>DeleteIndexExcept[dum[_]][Tensor[\[Delta],a,b]];
xPrint["tmp:",tmp];
tmp=tmp/.Tensor[\[Delta],a_,b_]:>AddUpDnDum[Tensor[\[Delta],a,b]];
sub=Thread[Rule[tensor,tmp]];
exp/.sub
];

(*Changes all indices of tensor_Tensor to Pattern.*)
TensorIndexPattern[tensor_Tensor]:=Module[{tmp,up,dn},
up=Map[If[Head[#]=!=Pattern&&#=!=Void,Pattern[#,Blank[]],#]&,tensor[[2]]];
dn=Map[If[Head[#]=!=Pattern&&#=!=Void,Pattern[#,Blank[]],#]&,tensor[[3]]];
Tensor[tensor[[1]],up,dn]
];

(**)
tuD2tuDOp::usage="tuD2tuDOp[tuDOp_,arg_List:{}][exp_] converts Derivative[] expressions into tuDOps_ expression.  Arguements to functions that are objects of Derivative[] can be added via arg_List in which case the Derivative is applied to each element in arg_List.  tuDOps_\[Rule]{xPartialD|xCovariantD|xD[_]|tuDPartial|tuDCovariant|tuDs[_]|tuDDown[_]|xPartialDu|xCovariantDu|xDu[_]|tuDPartialu|tuDCovariantu|tuDsu[_]|tuDUp[_]|tuDPartial|tuDCovariant|tuDs[_]|tuDDown[_]|tuDPartialu|tuDCovariantu|tuDsu[_]|tuDUp[_]|tuDLie}  *15Aug2015*";
tuD2tuDOp[tuDOp_,arg_List:{}][exp_]:=Module[{tmp=exp,makeVar},
makeVar[ndd_List,vars_List]:=Module[{out},
xPrint["<<",ndd,":",vars];
out=MapIndexed[ConstantArray[vars[[First[#2]]],#1]&,ndd]//Flatten;
out
];
tmp=tmp/.Derivative[nd__][fn_][ind__]:>Fold[tuDOp,
If[Length[arg]>0,fn[ind](*fn[Apply[Sequence,arg]]*),fn[ind]],makeVar[{nd},{ind}]]/;Length[{ind}]>0;
tmp=tmp/.Derivative[nd__][fn_]:>Fold[tuDOp,
If[Length[arg]>0,fn[Apply[Sequence,arg]],fn[Apply[Sequence,arg]]],makeVar[{nd},{arg}]];
tmp
];
(*TEST*)(*
$=tuDPartialu[\[Chi][T[u,"u",{\[Beta][1]}][\[Gamma]],T[u,"d",{\[Beta][2]}][\[Gamma]],tuDPartial[T[u,"u",{\[Beta][3]}][\[Gamma]],\[Gamma]],tuDPartial[T[u,"d",{\[Beta][4]}][\[Gamma]],\[Gamma]]],\[Gamma]]
$=$//tuDerivOps2D;$//ColumnSumExp
$=$//tuD2tuDOp[tuDPartialu]//(#/.\[Chi][__]\[Rule]\[Chi]&)//(#/.a_[\[Gamma]]\[Rule]a&);$//ColumnSumExp
*)
D2xPartialD[arg_List:{}][exp_]:=tuD2tuDOp[xPartialD,arg][exp];(*Compatibility*)

(**)
tuDupdn2tuPartial::usage="tuDupdn2tuPartial[exp_] Converts D[fn_[\[Mu][up],\[Nu][dn],...],\[Mu][up],\[Nu][dn],...] form to tuDPartial[tuDPartialu[fn,\[Mu]],\[Nu]] form.  *1Jan2014*"
tuDupdn2tuPartial[exp_]:=exp//.{HoldPattern[Derivative[n__][A_][i__]]:>tuDtuDPartialupdown[{n},A,{i}]}
tuDtuDPartialupdown[dslot_List,var_,updn_List]:=Module[{tmp,Ds,updnseq},
xPrint[Length[dslot],": ",var,":",Length[updn],":",updn];
updnseq=Apply[Sequence,updn];
If[Length[dslot]===Length[updn],
tmp=Thread[List[dslot,updn]];xPrint["dslot ",dslot,":",var,":",updn,":",tmp];
Ds=DeleteCases[tmp,List[0,_]];
Ds=Map[Table[#[[2]],#[[1]]]&,Ds]//Flatten;
(*no derivative*)xPrint["Ds ",var,", ",Ds];
tmp=Fold[If[FreeQ[#2,up],tuDPartial[#1,#2],tuDPartialu[#1,#2]]&,var,Ds];xPrint["Folded: ",tmp];
tmp,
Derivative[Apply[Sequence,dslot]][var][updnseq]](*Do nothing return*)
];

tuArgRemove::usage:="tuArgRemove[var_List][exp_]
eliminates arguements of Head[] patterns in var_List, e.g., A[a][b] B[d][e] ]->A[a]B[d] *12Apr2012*";
tuArgRemove[var_List][exp_]:=Module[{sub={},tmp=exp,XXX},
sub=MapIndexed[Append[sub,#1[arg__]->XXX[#2,RemovePatterns[#1]]]&,var]//Flatten;
tmp=exp//.sub;
tmp=tmp//.XXX[n_,A_]->A
];
EliminateArguments[var_List][exp_]:=tuArgRemove[var][exp];

(**)
tuEulerEquation::usage="tuEulerEquation[dependent_,independent_][lagrangian_] converts the lagrangian_ into an expression that is appropriate for EulerEquations[].  The input lagrangian_ expression has dependent variables without arguements which are added by specifying dependent_ and independent_.  The tuDerivOps are converted to Mathematica derivatives by tuDerivOps2D[]. EulerEquations[] is applied and the return value is: {xEulerEquations[]expression, EulerEquation output, EulerEquation output after application of tuD2tuDOp[tuDPartial]}. *13Sep2018*";
tuEulerEquation[dependent_,independent_][lagrangian_]:=Module[{$L=lagrangian,$dependent=Flatten[{dependent}],$independent=Flatten[{independent}],$dummy,i,$,$s,$s1,$xE,$1,$2},
(*make dependent[independent] Rule*)
$s1=Through[$dependent[Apply[Sequence,Flatten[{$independent}]]]];
$s=$dependent->$s1//Thread;
$=lagrangian//tuRuleApply[$s]//tuDerivOps2D;
$xE=xEulerEquations[$,$s1,$independent];
$1=$xE/.xEulerEquations->EulerEquations//tuRuleRHS0;
$2=$1//tuD2tuDOp[tuDPartial]//tuArgRemove[Apply[Alternatives,$dependent]]//Simplify//tuRuleRHS0;
{$xE,{$1}[CG["equations of motion","Mathematica D-form"]],{$2}[CG["equations of motion","tu D-form"]]}
];
(**)
tuLagrangianQuantities::usage="tuLagrangianQuantities[dependent_,independent_,constants_:{}][LAGRANGIAN_] computes various quantities from the LAGRANGIAN_: {momentum of dependent_ variables, the results of the tuEulerEquation[] calculations. *24Sep2018*";
tuLagrangianQuantities[dependent_,independent_,constants_:{}][LAGRANGIAN_]:=Module[{$dependent=Flatten[{dependent}],$independent=Flatten[{independent}],
$lagrangian=LAGRANGIAN,
$constants=Flatten[{constants}],
$,$1,XXX,$s,$d,$conserved={},$eulerequations,$momemtum={},$out={}
},

$eulerequations=tuEulerEquation[$dependent,$independent][LAGRANGIAN];
$eulerequations=$eulerequations[CG["eulerequations"]];

For[$i=1,$i<=Length[$dependent],$i++,
(*Print[$=$lagrangian," : ",$dependent,$independent];*)
$s=$lagrangian//tuExtractPattern[DerivOps[$dependent[[$i]],$independent[[1]]]]//First;
$d=Head[$s][$lagrangian,$s];
(*Print[$d];*)
$d=$d//tuDerivativeExpand[$constants]//(#/.Head[$s][a_,$s]:>0/;tuHasNoneQ[a,$s]&)//Expand;
(*Print[$d];*)
$=$lagrangian/.$s->XXX;
$1=($//tuHasAnyQ[#,$dependent[[$i]]]&);(*
Print[$,":",$s,":",$dependent[[$i]],":",$1];*)
$d={Subscript[p, $dependent[[$i]]]->$d};$d=If[$1,$d,$d[CG["conserved",tuDPartial[\[ScriptCapitalL],$dependent[[$i]]]->0]]];
AppendTo[$momemtum,$d]
];
$momemtum=$momemtum[CG["momentum"]];
$out={$momemtum,$eulerequations}
];
(*TEST
Get[$InitialDirectory<>"/Mathematica/Gravity/AZee.V.4.out"];
$=$0=e[6]//Last
$=$/.d[a_]\[Rule]tuDs[d][a,\[Tau]]//tuLagrangianQuantities[{\[CapitalOmega],t,r},\[Tau],{}];
(ColumnForms[#1,4]&)[$]
*)


tuHamiltonian::usage="tuHamiltonian[lagrangian_,partialD_List,constant_List:{}] returns the Hamiltonian associated with the lagrangian_ and partialD_s.  A list of constant_s may be specified for tuDerivativeExpand[]. Dot is added to allow for vector expressions *22Feb2017*";
tuHamiltonian[lagrangian_,partialD_List,constant_List:{}]:=Module[{tmp,tmpL=lagrangian,partial,partialDt,i,accum=0},
For[i=1,i<=Length[partialD],i++,
partialDt=partialD[[i]];
tmp=tuDPartial[lagrangian,partialDt]//tuDerivativeExpand[constant];
tmp=tmp/.tuDPartial[a_,dd:tuDPartial[b_,t]]:>0/;FreeQ[a,dd]//.tuOpSimplify[dotOps,constant];
accum+=tmp  .  partialDt;
];
accum-lagrangian//.tuOpSimplify[dotOps,constant]//Simplify(*add Dot for possible vector equation*)
];

tuEulerLagrangeTensor::usage:=
"tuEulerLagrangeTensor[Lagrangian_,field_List,indexDeriv_List] compute Euler-Lagrange(EL) equations for Lagrangian_ for each Tensor field in field_List where its participanting index variables are indicated by Patterns. Builds arguements for EulerEquations[], but participating field indices are lowered for the calculation. (WARNING: The same variable with different indices are treated as different variables.  Convert these variables to same indices by using metric tensor.  The result has participating field indices in the lower position and there are multiples EL equations, one for each active index variable.  Need to specify all field_List that are functions of indexDeriv_List.  WARNING: This routine is not recognized via Initialization.  This block must be executed manually.   TODO: Convert these variables to have same index by using metric tensor. *2Jan2014*";
tuEulerLagrangeTensor[Lagrangian_,
field_List,(*field to evaluate in EL calculation. Pattern for indices indicates indexDeriv_List variable. *)
indexDeriv_List(*index variables taking part in EL calculation, includes xPartialD and xPartialDu indices. *)
]:=Module[{tmp,vars={},fields={},sub,subvar,subLower,xfield=field,xfieldLower,lagrangianLower,fieldVar,fieldLag,indexPattern,fieldLow,$s,$sx0,$p,$pvar,$pvar1},(*
Needs["VariationalMethods`"];*)
(*modified inputs(indices) to be compatible. Field index_List indices all lower.*)
xfield=field/.Pattern->xPattern;xPrint[xfield];
indexPattern=ExtractPattern[xPattern[i_,_]][xfield]//DeleteDuplicates;
fieldLow=Fold[tuIndicesLower[#2,#2][#1]&,xfield,indexPattern];
subLower=DeleteCases[Flatten[{Thread[xfield==fieldLow]}],True]/.Equal->Rule;xPrint[xfield,fieldLow,subLower];
subLower=Map[MapAt[#/.xPattern[i_,_]->i&,#,2]&,subLower]/.xPattern->Pattern;
fieldLow=fieldLow/.xPattern->Pattern;
xPrint["NEW subLower:",subLower];xReturn[];
fieldLag=Map[ExtractPattern[#][Lagrangian]&,field]/.subLower//Flatten//DeleteDuplicates;xPrint["fieldLag:",fieldLag];xReturn[];
(*build variables for functional: f\[Rule]f[vars]. up,dn indices are treated as independent index variables.*)
Map[AppendTo[vars,{#[up],#[dn]}]&,indexDeriv];
vars=Flatten[vars];xPrint["vars:",vars];xReturn[];
(*add vars to field\[Rule]field[vars] Rule.*)
fieldVar=Map[Apply[RemovePatterns[#],vars]&,fieldLag];xPrint["fieldVar:",fieldVar];
subvar=Thread[Rule[fieldLag,fieldVar]];xPrint["subvar:",subvar];xReturn[];
lagrangianLower=Lagrangian/.subLower;xPrint["L: ",lagrangianLower];xReturn[];
tmp=lagrangianLower//xPartialD2Dupdn[indexDeriv,fieldLow];
(*
NEED to account for raw indexDeriv variables *)
$p=tmp//tuExtractPositionPattern[tuRuleIndependentVarPattern];
$pvar=#[[2]]&/@$p;
$pvar1=MapIndexed[#1->ToString[pvar[#2[[1]]]]&,$pvar];
$p=$p/.$pvar1;
tmp=tuReplacePart[tmp,$p];
(*
stringify already vars*)
$s=Map[cc:#[up|dn]:>$string[ToString[cc]]&,indexDeriv];
tmp=tmp/.$s;
$s=Map[cc:(a_:1 )  #^(n_:1):>a #[dn]^n /;FreeQ[cc,#[dn|up]]&,indexDeriv];
tmp=tmp/.$s;
tmp=tmp/.$string[cc_]:>ToExpression[cc];
$pvar1=Reverse[#]&/@($pvar1);
tmp=tmp/.$pvar1;
(*
Apply EulerEquations*)
xPrint[">>",tmp,";",indexDeriv,";",fieldLow];xReturn[];
fieldVar=DeleteDuplicates[fieldVar];
xPrint["EulerEquations[",tmp,",\n",fieldVar,",\n:",vars,"\n]"];xReturn[];
xEulerEquations[tmp,fieldVar,vars];
tmp=EulerEquations[tmp,fieldVar,vars];
xPrint[">>",tmp,"\n:",fieldVar,"\n:",vars];xReturn[];
(*Convert D to xPartialD*)
tmp=tmp//tuDupdn2tuPartial;
xfield=xfield/.xPattern->Pattern;(*Is this compatible?*)
xPrint["xfield",xfield,", ",tmp];
tmp=xEliminateArguments[xfield][tmp];
tmp=tmp/.xEliminateArguments->EliminateArguments;
tmp
];
(*
EulerLagrangeTensor[Lagrangian_,
field_List,
indexDeriv_List
]:=tuEulerLagrangeTensor[Lagrangian,field,indexDeriv];
*)
(*Test routine*)
testEulerLagrangeTensor:={
Module[{tmp,tmp0,var,$L,$tensorsymbol,$var,$dummy},
xPrint[
tmp0=tmp=Get[$HomeDirectory<>"/Mathematica/AZee/AZee.VI.1.out"]];
tmp=tmp[[2]]/.{\[Alpha]1->\[Lambda],\[Alpha]2->\[Nu],\[Alpha]3->\[Mu]};
{$L,$var,$dummy}=PrepareLagrangian[{a}][tmp];
AppendTo[$dummy,\[Lambda]];(*does not find \[Lambda]*)
Print["Arg:",tmp0,"\nvar: ",$var,"\ndummy: ",$dummy];
Print[{tmp\[LongRightArrow]((tmp0=(xxtmp=tuEulerLagrangeTensor[$L,$var,$dummy])//Flatten)//Column)}];
(*Rearrange indices*)
tmp0=MapAt[IndexSwap[{\[Mu],\[Nu]}][#]&,tmp0,{{1},{3}}]//Expand;
tmp0=Map[If[!FreeQ[#,T[a,"u"][_]],#/.tt:b_ f_[T[a,"u"][i_],d_]|b_ g_ [f_[T[a,"u"][i_],d_],e_]:>UpDownIndexSwap[i][tt]]&,tmp0]/.orderxPartialD[{\[Mu],\[Nu]}]//tuIndicesLower[\[Nu],\[Nu]];
Print["Added together: ",Framed[tmp0/.OrderAll\[Epsilon]//AddRules//Expand]];
];
(**********************)
Module[{tmp,tmp0,p0,var,$L,$tensorsymbol,$var,$dummy},tmp=xPartialD[T[x,"d"][k],t]xPartialDu[T[x,"u"][k],t]/2-g T[x,"d"][k];
{$L,$var,$dummy}=PrepareLagrangian[{x}][tmp];
Print["Arg:",tmp,"\nvar: ",$var,"\ndummy: ",$dummy={t}];
Print[{tmp\[LongRightArrow]((tmp0=tuEulerLagrangeTensor[$L,$var,{t}]//Flatten)//Column)}];
Print["Added together: ",Framed[tmp0//AddRules//Expand//tuIndicesRaise[k,k]]];
];
};

(*
PrepareLagrangian[tensorsymbol_List][lagrangian_] prepares lagrangian_ expression for use in EulerLagrangeTensor[]. tensorsymbol_List is a list of Tensor symbols to be evaluated in the EL equations.  Returns {modified Lagrangian, field_List, dummy_List} where field_List are the Tensors found in lagrangian_ and dummy_List is a list of indices that are extracted for EL variables.  One may need to modify dummy_List and field_List based upon particular needs. The lagrangian_ is modified by up/dn  symmetrizing the indices of tensorsymbol_List.  The result of EulerLagrangeTensor[] contains redundant solutions due to the symmetrization of the indices. *6Jan2014*)
PrepareLagrangian[tensorsymbol_List][lagrangian_]:=Module[{$L=lagrangian,$tensorsymbol=tensorsymbol,$var,$dummy,i},
$var=Map[{ExtractPattern[T[#,"u"][i_]][$L],ExtractPattern[T[#,"d"][i_]][$L]}&,$tensorsymbol]//Flatten//DeleteDuplicates//Sort;
$dummy=$var//tuIndexParser//First;
Do[$L=Expand[($L+(UpDownIndexSwap[$dummy[[i]]][$L]))/2];xPrint[$L],{i,Length[$dummy]}];
{$L,$var,$dummy}
]
(*testEulerLagrangeTensor*)
(*
LowerTensorIndexByG[tensor_List,G_][exp_] lower indices of Tensor variables in exp_ (by assuming the metric, G_, lowers indices) specified in tensor_List of only the indices specified as patterns. The result is the tensor_List variables Dotted with the metric, G_, and the specified indices lowered.  The summed indices are specified by dum[] indices.  The purpose of this routine is allow for the differential of expressions that have variables that differ by a metric index change.  eg., the TEST below generates
{Subsuperscript[A, a\[Mu]_, a\[Mu]_],Subsuperscript[B, fg_h_, fg_h_]}
Subscript[Underscript["\[PartialD]", _], e][(Underscript["\[PartialD]", _]^e)[Subsuperscript[A, ab, ab] Subsuperscript[A, cd, cd] Subsuperscript[B, fgh, fgh]]]
Subscript[Underscript["\[PartialD]", _], e][(Underscript["\[PartialD]", _]^e)[Subsuperscript[g, adum[\[Mu]], adum[\[Mu]]].Subsuperscript[A, adum[\[Mu]], adum[\[Mu]]] Subsuperscript[g, fdum[g]dum[h], fdum[g]dum[h]].Subsuperscript[B, fdum[g]dum[h], fdum[g]dum[h]] Subsuperscript[A, cd, cd]]]
*)
LowerTensorIndexByG[tensor_List,G_][exp_]:=Module[{tmp,
sub,sub1,sub0,f1,dd},
xPrint["tensor:",tensor];
(*change Tensor\[Rule] \[Delta].Tensor*)
tmp=Map[#/.Tensor[a_,b_,c_]:>Tensor[G,b,c].Tensor[a,b,c]&,tensor];
xPrint["tmp:",tmp];
tmp=tmp/.Pattern->xPattern/.xPattern[a_,Blank[]]->dum[a];
tmp=tmp/.Tensor[G,a_,b_]:>SwapUpDownIndices[Flatten[{Cases[a,dum[_]],Cases[b,dum[_]]}]][Tensor[G,a,b]];

xPrint["tmp:",tmp];
tmp=tmp/.Tensor[G,a_,b_]. Tensor[A_,c_,d_]:> SwapUpDownIndices[Flatten[{Cases[b,dum[_]]}]][Tensor[G,a,b].Tensor[A,c,d]];
xPrint["tmp:",tmp];
tmp=Thread[Rule[tensor,tmp]];
xPrint["tmp:",tmp];
exp/.tmp(*apply on each Times term*)
];
(* TEST
tmpf={A@ud[a,\[Mu]_],T[B,"uuu"][f, g_,h_]}
tmp=xPartialD[xPartialDu[ A@ud[a,b] Auu[c,d]T[B,"uuu"][f, g,h],e],e]
tmp//LowerTensorIndexByG[tmpf,g]
*)
(*
Counts the number of indices in exp_. Result is in ParseTermIndices format. *19July2012*)
ExpressionIndices[exp_]:=Module[{tmp=exp,indices={},tensors,xtmp},
tmp=tmp//.IndexParsingRules;
tensors=tuExtractPattern[Tensor[a_,u_List,d_List]][tmp];
tmp=Map[tuIndexParser[#]&,tensors];
tmp=Apply[Plus,tmp]/.Plus->List;
tmp=MapAt[Flatten[#]&,tmp,{{2,1},{2,2}}];
tmp
];
(*
returns list of paired dummy (up,down) indices in exp_. *19July2012*)
PairedDummies[exp_]:=Module[{tmp=exp,up,dn,xtmp},
tmp=ExpressionIndices[tmp];
tmp=Map[DeleteCases[#,Times[n_Integer,_]]&,tmp[[2]]];(*remove non singles*)
tmp=Intersection[tmp[[1]],tmp[[2]]];
tmp
];
(*
returns list of paired dummy (up,down) indices between term1_,term2_ . *19July2012*)
PairedDummies[term1_,term2_]:=Module[{tmp1=term1,tmp2=term2,up,dn,xtmp},
tmp1=ExpressionIndices[tmp1];
tmp1=Map[DeleteCases[#,Times[n_Integer,_]]&,tmp1[[2]]];(*remove non singles*)
tmp2=ExpressionIndices[tmp2];
tmp2=Map[DeleteCases[#,Times[n_Integer,_]]&,tmp2[[2]]];(*remove non singles*)
xtmp=Union[Intersection[tmp1[[1]],tmp2[[2]]],Intersection[tmp1[[2]],tmp2[[1]]]];
xtmp
];
(**)
tuIndexUniqueDummy::usage="tuIndexUniqueDummy[dummy_List][exp_] attempts to assign Unique labels to dummy indices (summed) designated by dummy_List to Tensor expressions.  *16Jan2016*";
tuIndexUniqueDummy[dummy_List][exp_]:=Module[{tmp=ExpandAll[exp],dum,head,isub,ops=Flatten[Times|Wedge|dotOps],oplist,distriOps={Rule,Equal,Plus},sub,xtmp  },
head=Head[tmp];
oplist=Apply[List,ops];
If[MemberQ[oplist,head]
&&Length[dum=Intersection[dummy,PairedDummies[tmp]]]>0,tmp=tmp//.(sub=Map[#->Unique[#]&,dum])];
If[MemberQ[Join[distriOps,oplist],head],
tmp=Apply[head,Map[tuIndexUniqueDummy[dummy][#]&,Apply[List,tmp]]]
];
tmp
];
UniqueDummyIndices[dummy_List][exp_]:=tuIndexUniqueDummy[dummy][exp];(*Compatibility*)

(*
removeUnique[symbol_List] returns Rules for removing tuIndexUniqueDummy extensions. *23Sep2014*)
removeUnique[dummy_List]:=Module[{sym},sym=ToString[#]<>"$*"->#&/@dummy//Flatten;
sym=MapAt[Names[#]&,#,1]&/@sym;
sym=Thread/@sym//Flatten;
Map[MapAt[Symbol[#]&,#,1]&,sym]
]
(**)
tuIndexParser::usage="tuIndexParser[term_] extends ParseTermIndices in Tensorial handle complex Tensor notation. Returns {dummy,{up,down},error} indices. Returns indices of only top level Tensors. *11Feb2017";
tuIndexParser[term_]:=Module[{tmp,pos,up={},dn={},updup,dndup,dummy={},bad={}},
If[Head[term]=!=Plus,
tmp=term//.IndexParsingRules;
pos=tuExtractPositionPattern[Tensor[$A_,$u_,$d_]][tmp];
pos=pos//tuPositionNestDelete;(*No nested Tensor expressions*)
pos=Map[#[[2]]&,pos];
xPrint["pos:",pos,"tmp",tmp,":"];
up=Map[#[[2]]&,pos]//Flatten//DeleteCases[#,Void]&;
dn=Map[#[[3]]&,pos]//Flatten//DeleteCases[#,Void]&;
updup=Tally[up];  dndup=Tally[dn];
xPrint[up];
bad=Map[#[[1]]&,
Join[Cases[updup,{_,n_/;n>1}],Cases[dndup,{_,n_/;n>1}]]];
dummy=Intersection[up,dn];
up=DeleteCases[up,Apply[Alternatives,Join[dummy,bad]]];
dn=DeleteCases[dn,Apply[Alternatives,Join[dummy,bad]]];
xPrint[{up,dn}];
];
{dummy,{up,dn},bad}
];
ParseTermIndicesTU[term_]:=tuIndexParser[term];
ParseTermIndices[term_]:=tuIndexParser[term];
(**)
Clear[tuIndexOrderPairs]
tuIndexOrderPairs::usage="tuIndexOrderPairs is Rule for canonically ordering two dotOps[]d  identical Tensor[]s which may have different indices. *17May2016*";
tuIndexOrderPairs:=(op:dotOps)[a___,t1:Tensor[B_,_,_] , t2:Tensor[B_,_,_],b___]:>op[a,t2,t1,b]/;OrderedQ[{t2,t1}];
(**)
tuIndexDummyOrdered::usage="tuIndexDummyOrdered[exp_] orders Dummy indices of term in Plus[] expression in exp_[]. Includes up/down ordering. *2Jan2016**2Jan2018*";
tuIndexDummyOrdered[exp_]:=Module[{tmp=exp,order},
(**)
order[term_]:=Module[{$t,$index,$pdum,$dums,$dum,$0,$i,$,$ind},
(*Order index labels*)
$dums=term//tuIndexParser//First;
$pdum=term//tuExtractPositionPattern[Apply[Alternatives,$dums]];
$index=Last[#]&/@$pdum//DeleteDuplicates;
$index=Thread[$index->$dums];
$t=term/.$index;
(*Order up/down indices*)
$0=$t/.Times|dotOps->xTimes;
While[Length[$dums]>0,
$dum=$dums[[1]];$dums=Rest[$dums];xPrint[$dum];
For[$i=1,$i<Length[$0],$i++,
$ind=tuIndexParser[$0[[$i]]];xPrint[$ind];
If[tuHasAnyQ[$ind[[2,2]],$dum],$t=tuIndexSwapUpDown[$dum][$t]];
]
];
$t
];
(**)
tmp=tmp//Expand;
tmp=tmp/.Plus->xPlus/.pp:xPlus[a__]:>Map[order[#]&,pp]/.xPlus->Plus;
Return[tmp];
];
OrderTensorDummyIndices[exp_]:=tuIndexDummyOrdered[exp];(*Compatibility*)

(**)
Clear[tuIndexOrderDummy]
tuIndexOrderDummy::usage="tuIndexOrderDummy[symTensor_List][exp_]
canonically orders terms in exp_ containing symmetric Tensor[]s whose symbols are specified in symTensor_List. Tensor[]s in symTensor_List are Ordered. *1Mr2018*";
tuIndexOrderDummy[symTensor_List][exp_]:=Module[{tmp=exp,xorder},
xorder[term_,symTensors_]:=Module[{$t,$index,$pdum,$dums,$dum,$0,$i,$,$ind,$symTensor=Apply[Alternatives,Flatten[{symTensors}]],$tensors},
(*dummy labels*)
$dums=term//tuIndexParser//First;xPrint[$dums];
$t=term//tuIndexSwap[$dums];
$t=$t//tuTensorSlotOrdered[$symTensor,$dums];
If[OrderedQ[{$t,term}],$t,term]
];
(**)
xPrint["0 ",tmp];
tmp=tmp//tuTermApplyEach[{Tensor},{},{},{xorder[#,symTensor]&},1];
tmp
];

(**)
tuIndexDummyUniform::usage="tuIndexDummyUniform[exp_] ExpandAll[exp_] and attempt to make dummy indices in each term uniform by substituting and permuting generic dummy indices, dm[].  The intent is to reduce the number of terms in exp_.  The uniform dummy indices are labeled dm[1], dm[2], \[CenterEllipsis]. *29Jun2017**2Jan2018*";
tuIndexDummyUniform[exp_]:=Module[{$,$0,$s,$n,$dm,$p,$de,$dep,$sn,$pn},
$0=ExpandAll[exp];
$s=List[DeleteCases[First[tuIndexParser[#]],_Integer],#]&/@tuTermSelect[{},{},True][ $0 ];(*Print["$s",$s];*)
(*substitute and permute generic dummy indices, dm[]*)
$p=Map[($dm=#[[1]];$de=#[[2]];$pn=#[[2,1]];$n=Length[$dm];
$sn=Thread[$dm->#]&/@Permutations[Array[dm[#]&,$n],{$n}];
$de=$de/.$sn;
$pn=$de[[1,1]];
$dep=$pn->(tuRuleAdd[$de]//Last)/$n!//Expand;
If[Length[$dep]==$n,$dep=$pn->$de[[1,2]]];
$dep
)&,$s];
$=tuReplacePart[$0,$p]

];
(*TEST*)
(*
Get[$HomeDirectory<>"/Mathematica/Gravity/1208.3353.Chern-SimonsFormsInGravitationTheroies.out"];
$0=$=e[114.1];$//ColumnSumExp;
tuIndexDummyUniform[$0]*)

(*
changeDummyIndices[to_List,from_List][exp_] changes dummy indices to ones specified by the to_List from the lists of lists specified by the from_List.  e.g. changeDummyIndices[{i1,k[il,iv]},{{j1,k[iv,j1]},{i1,k[i1,iv]}}][exp_] changes to {i1,k[il,iv]} terms with either {{j1,k[iv,j1]},{i1,k[i1,iv]}} indices. It chooses the from_indices based upon the greatest number of match indices.
*22Oct2014*)
changeDummyIndices[from_List,to_List][exp_]:=Module[{tmp,indices,rules,in,replace,dummy},
tmp=ExpandAll[exp];
replace[term_]:=Module[{lin,out},(*xPrint["term:",term];*)
indices=tuIndexParser[term];
dummy=indices[[1]];
in={Length[in=Select[dummy,MemberQ[from,#]&]],in};(*
xPrint["indices:",dummy,":",from,":",in];*)
If[in[[1]]>0, rules=Thread[from->to];
(*TODO change to index specific*)(*
xPrint["rules",rules];*)
Return[term/.rules];];
term
];
tmp=If[Head[tmp]===Plus,
tmp=replace/@Apply[List,tmp];Apply[Plus,tmp],
replace[tmp]];(*xPrint[tmp];*)
tmp
];

(**)
tuIndexSymmetricOrdered::usage="tuIndexSymmetricOrdered[index_List][exp_Tensor] canonically ordered index_List of symmetric exp_Tensor. Assumes exp_Tensor is symmetric in index_List. It does nothing with repeated indices. *12Jul2017*";
tuIndexSymmetricOrdered[index_List][exp_Tensor]:=Module[{$=exp,$pos,$pos1,$sort=Sort[index],$label},
$label=$[[1]];
$pos=Apply[List,$[[2;;3]]];xPrint[$pos];
$pos1=Plus[$pos[[1]],$pos[[2]]]//(#/.Void->0&);xPrint[$pos1];
$pos1=Select[$pos1,tuMemberQ[#,$sort]&];
$pos1=Thread[$pos1->$sort];
$pos=$pos//tuRuleApply[$pos1];
T[$label,Apply[Sequence,$pos]]
];
(*TEST*)(*
T[\[Delta],"duu",{j,k,i}]
%//tuIndexSymmetricOrdered[{k,i}]*)

Clear[tuTensorSlotOrdered]
tuTensorSlotOrdered::usage="tuTensorSlotOrdered[tensorLabel_,index_List][exp_]
canonically orders in slot position all index_List indices for Tensor[tensorLabel,_,_] in exp_.  All indices of index_List must be present in each Tensor[] and up/down position of each index is maintained. *28Feb2018*";
tuTensorSlotOrdered[tensorLabel_,index_List][exp_]:=Module[{$=exp,$pos,$tensor,$indList,$indPos,$sym,$up,$dn,$slots},
$tensor=Tensor[Apply[Alternatives,Flatten[{tensorLabel}]],_,_];
$tensor=exp//tuExtractPositionPattern[$tensor];
$pos=Map[(xPrint["1 ",#];
{$sym,$up,$dn}=Apply[List,#[[2]]];
$indList={$up,$dn};
If[tuHasAllQ[$indList,index],
$indPos=$indList//tuExtractPositionPattern[index];

$slots=#[[1,2]]&/@$indPos//Sort;xPrint["slots ",$slots];
$indPosV=Map[{{1,#}->Void,{2,#}->Void}&,$slots]//Flatten;
$indList=tuReplacePart[$indList,$indPosV];
$indPos=SortBy[$indPos,Last];
$indPos=MapIndexed[{#[[1,1]],Part[$slots,#2][[1]]}->#[[2]]&,$indPos];
$indList=tuReplacePart[$indList,$indPos];
#[[1]]->Tensor[$sym,$indList[[1]],$indList[[2]]]])&,$tensor];
$pos=DeleteCases[$pos,Null];
xPrint["pos ",$pos];
tuReplacePart[$,$pos]
];(*
TEST
a tuDPartial[ T[g,"du",{\[Nu],\[Mu]}],\[Nu]]+c T[d,"udd",{\[Mu],\[Nu],\[Mu]}]
%//tuTensorSlotOrdered[{g,d},{\[Mu],\[Nu]}]*)


(**)
Clear[tuIndexSumTerm]
tuIndexSumTerm::usage="tuIndexSumTerm[index_List,baseindices_List :{0,1,2,3}][exp_] Sum[]s dummy indices of exp_ which either in Plus[] expression or individual expression. Does not do expressions both Plus[] and non-Plus[] expressions.  index_List choose dummy indices or if index_={} all dummy indices are summed. Indices are Sum[]d over baselindices. *22Sep2015*5Aug2017*";
tuIndexSumTerm[index_List:{},baseindices_List :{0,1,2,3}][exp_]:=Module[{tmp=exp,$,$dum,$indices,$dummy,$terms},
If[FreeQ[tmp,Plus],$terms={{}->tmp}(*no Plus expression*),
$terms=tmp//tuTermSelect[{},{},True](*only Plus expression*)
];
$dummy=tuIndexParser/@$terms;
$dummy=#[[1]]&/@$dummy;xPrint[$terms,$dummy];
MapIndexed[If[#1=!={},
$=Extract[$terms,#2];
$indices={};
If[index==={},
$indices=#1,
$indices=Intersection[index,#1]
];
$indices={#,baseindices}&/@$indices;xPrint[$indices];
$[[2]]=xSum[$[[2]],Apply[Sequence,$indices]];xPrint[$];
$terms[[First[#2]]]=$
]&
,
$dummy];
$terms=$terms/.xSum->Sum;
tuReplacePart[tmp,$terms]
];
(**)
tuIndexSum::usage="tuIndexSum[index_List,baseindices_List :{0,1,2,3}][exp_] Expand[]s exp_ and for Times expressions Sum[]s dummy indices in index_List. Indices are Sum[]d over baselindices.  *22Sep2015*";
tuIndexSum[index_List,baseindices_List :{0,1,2,3}][exp_]:=Module[{$=exp},
$=$//Expand;
$=$//.Times->xTimes;
$=$//.xTimes[a__]:>Inactive[tuIndexSumTerm] [index,baseindices] [Inactive[Times][a]];
$=$//Activate;
$
];
(**)
tuSumIndexUnique::usage:="tuSumIndexUnique[exp_] replaces Sum|xSum|Inactive[Sum] indices in exp_ with Unique[] indices. *15Jan2016*";
tuSumIndexUnique[exp_]:=Module[{$=exp,indices={},sums},
sums=$//tuExtractPositionPattern[{(Sum|xSum|Inactive[Sum])[__]}];
indices=Map[#->Unique[i][#]&/@Apply[List,#[[2,2;;-1]]]&,sums];
sums=MapIndexed[First[#1/.indices[[#2]]]&,sums];
$=tuReplacePart[$,sums]
];
(**)
tuTensorSimplify::usage="tuTensorSimplify[exp_Plus] simplifies Plus[] Tensor expression, exp_, by reindexing Dummy indices.  Works with Tensor and tuDerivOps expressions. *11Sep2015*";
tuTensorSimplify[exp_Plus]:=Module[{$,$s,$s1,$1,$1c,$2,$2c,$2t,$2td,$2m,$match={},$matches={}},
$=List@@exp;
$s=tuIndexParser/@$;$s//Column;
$2t=Select[List@@#,tuTensorQ[#]&]&/@$;
$2t=Times@@#&/@$2t;(*Tensor portion*)
$2td=MapIndexed[tuIndicesLower[#1[[1]]] [$2t[[#2]]]&,$s]//Flatten;  (*Tensor portion Lowered indices*)
$2c=Select[List@@#,!tuTensorQ[#]&]&/@$;
$2c=Times@@#&/@$2c;(*non Tensor portion*)
Do[
$1=$[[$i]];
$1=List@@$1;
$1c=Select[$1,!tuTensorQ[#]&];
$1c=$2c[[$i]];
$1t=Select[$1,tuTensorQ[#]&];
$1t=Times@@$1t;
$s1=$1t//tuIndicesLower[$s[[$i,1]]];
$s1=$2td[[$i]];
$s1=tuAddPatternVariable[$s1->0,$s[[$i,1]]];xPrint["LL",$s1];
$2m=MatchQ[#,$s1[[1]]]&/@$2td;
If[Length[Cases[$2m,True]]>1,
$match=Flatten[Position[$2m,True]];
AppendTo[$matches,$match];
xPrint[Column[$2t[[$match]]]];
];
,{$i,Range[Length[$]]}
];
$matches=$matches//DeleteDuplicates;
Do[
$match=$matches[[ $i ]];  xPrint[$i,"::",$match];
($2t[[ # ]]=$2t[[ $match[[1]] ]])&/@$match,
{$i,Range[Length[$matches]]}
];
Inner[Times,$2c, $2t,Plus]
];

(*
*)

 (*
*)tuCoordSolidAngle::usage="tuCoordSolidAngle[n_] produces a List[] of spherical coordinate directional Cosines, \!\(\*SuperscriptBox[\(\[Omega]\), \(i\)]\), of \!\(\*SuperscriptBox[\(S\), \(n\)]\). Also, computes d[\!\(\*SubscriptBox[\(\[CapitalOmega]\), \(n\)]\)\!\(\*SuperscriptBox[\(]\), \(2\)]\). *11Nov2018*";
tuCoordSolidAngle[n_]:=Module[{$,$0,$n=n+1},
$0={"spherical coordinates for "[S^ToString[$n-1]],
T[\[Omega],"u",{1}]->Cos[T[\[Theta],"d",{1}]],
T[\[Omega],"u",{$n}]->xProduct[Sin[T[\[Theta],"d",{j}]],{j,1,$n-2}]Sin[T[\[Theta],"d",{$n-1}]]
,
Table[T[\[Omega],"u",{i}]->xProduct[Sin[T[\[Theta],"d",{j}]],{j,1,i-1}]Cos[T[\[Theta],"d",{i}]],
{i,1,$n-1}]
,
{If[$n-2>0,{0<=T[\[Theta],"d",{"1\[LessEqual]i\[LessEqual]"<>ToString[$n-2]}]<\[Pi]}],
0<=T[\[Theta],"d",{$n-1}]<2\[Pi]
}
}/.xProduct->Product//Flatten//DeleteDuplicates//DeleteCases[#,Null]&//Sort;
$=d[Subscript[\[CapitalOmega], $n-1]]^2/.($coordSolidAngle//tuRuleSelect[{d[Subscript[\[CapitalOmega], _]]^2}])/.xSum->Sum/.tuRule[$0];
$=d[Subscript[\[CapitalOmega], $n-1]]^2->tuOpIndependentVar[tudExpand,op$[d][$]]//Simplify;
{$0,$}
];
$=tuCoordSolidAngle[2];(ColumnForms[#1,2]&)[$]


(* ::Input::Initialization:: *)
(* Simplifies xPartialD in exp_ based upon list of constants_ .  Only extracts multiplicative constants.
NOT FINISHED -> use /.xPartialDExpand[]
*)
PartialDSimplify[exp_,constants_]:=Module[{tmp=exp,tmp0=Null,pos,xpart,arg,dx,i},
While[tmp=!=tmp0,
tmp0=tmp;
tmp=tmp//.xPartialDExpand[constants];
tmp=tmp/.(OP:xPartialD|xPartialDu)[a_,b_]:>0/;MemberQ[constants,a](*;
tmp=tmp/.xPartialD[a_,b_]:>0/;MemberQ[constants,a];  (*XXX*)
tmp=tmp/.xPartialDu[a_,b_]:>0/;MemberQ[constants,a]  (*XXX*)
*)
];
tmp
];

(*Rules for applying D[,] instead of xPartialD[,].  Usage: exp/.xPartialD2D[1,x]
*)
xPartialD2D[mu_,x_][exp_]:=Module[{$=Hold[exp]},
$=$//.xPartialD|xPartialDu->D;
$//ReleaseHold
];

(**)tuDerivOps2D::usage="tuDerivOps2D[exp_] simply converts DerivOps into D expressions. *9Sep2015*13Jul2017*";
tuDerivOps2D[exp_]:=Module[{$=exp},
$=exp//.DerivOps[a__]:>Inactive[D][a];
Activate[$,D]
];
(*TEST*)(*
$=tuDPartialu[\[Chi][T[u,"u",{\[Beta][1]}][\[Gamma]],T[u,"d",{\[Beta][2]}][\[Gamma]],tuDPartial[T[u,"u",{\[Beta][3]}][\[Gamma]],\[Gamma]],tuDPartial[T[u,"d",{\[Beta][4]}][\[Gamma]],\[Gamma]]],\[Gamma]]
$=$//tuDerivOps2D;$//ColumnSumExp
$=$//tuD2tuDOp[tuDPartialu]//(#/.\[Chi][__]\[Rule]\[Chi]&)//(#/.a_[\[Gamma]]\[Rule]a&);$//ColumnSumExp
*)

(* 
Rules that transform {xPartialD,xPartialDu} to Tensorial \[PartialD]:
{xPartialD[a_,b_]->T["\[PartialD]","d"][b][a],xPartialDu[a_,b_]->T["\[PartialD]","u"][b][a]}
 7Apr2012 *)
(*
xPartialD2Dupdn[var_List,field_List][exp_] converts Tensor exp_ indices into functional[var_[up|dn]] where {up,dn} indicates the position of the indices.  The field_List (Patterns OK) contains the Tensor fields that are functions of var_List[up|dn].  The fields can have Patterns as indices to encompass a more general set of fields.  This is useful when we want to use the D operation in exp_ where the notation is in xPartialD & xPartialDu, Tensor.  Used to compute EulerEquation in Tensor notation, 
e.g.,
tmp=xPartialD[xPartialDu[ A@ud[a,b] A@uu[c,d], e],e]
xPartialD2Dupdn[{e,\[Nu]},{A@ud[a,\[Mu]_],A@uu[\[Nu]_,a_]}][ tmp ]
=>
((Subsuperscript[A, ce, ce])^(0,1,0,0))[e[up],e[dn],c[up],c[dn]] ((Subsuperscript[A, ab, ab])^(1,0,0,0))[e[up],e[dn],\[Nu][up],\[Nu][dn]]+((Subsuperscript[A, ab, ab])^(0,1,0,0))[e[up],e[dn],\[Nu][up],\[Nu][dn]] ((Subsuperscript[A, ce, ce])^(1,0,0,0))[e[up],e[dn],c[up],c[dn]]+Subsuperscript[A, ce, ce][e[up],e[dn],c[up],c[dn]] ((Subsuperscript[A, ab, ab])^(1,1,0,0))[e[up],e[dn],\[Nu][up],\[Nu][dn]]+Subsuperscript[A, ab, ab][e[up],e[dn],\[Nu][up],\[Nu][dn]] ((Subsuperscript[A, ce, ce])^(1,1,0,0))[e[up],e[dn],c[up],c[dn]]
*2Jan2014*)
xPartialD2Dupdn[var_List,field_List][exp_]:=Module[{sub,tmp=exp,vars={}},
vars=Flatten[Map[Append[vars,{#[up],#[dn]}]&,var]];
sub=Map[{#->Apply[RemovePatterns[#],vars]}&,DeleteDuplicates[field]]//Flatten;
xPrint["sub:",sub];
tmp=tmp/.sub;
xPrint["tmp:",tmp];
sub={xPartialD[a_,b_]:>xD[a,b[dn]]/;!FreeQ[a,up|dn],xPartialDu[a_,b_]:>xD[a,b[up]]/;!FreeQ[a,up|dn]};
xPrint["sub:",sub];
tmp=tmp//.sub;
xPrint["tmp:",tmp];
tmp=tmp//.xD->D;
tmp
];

(*
CombineDeriv Rules for combining sum and differences of Deriv s*31August2012*)
CombineDeriv:={(op:DerivOps)[a_,b_]+(op:DerivOps)[c_,b_]->op[a+c,b],(op:DerivOps)[a_,b_]-(op:DerivOps)[c_,b_]->op[a-c,b],
(op:DerivOps)[a_,b_]c_+(op:DerivOps)[c_,b_]a_->op[a c,b](*inverse chain rule*)
}
(*
lagrangexPartialD Rules[]s simplify expressions that often occur in derivation using Lagrangians.  *22Apr2014*)
lagrangexPartialD={xPartialD[(xPartialDu|xPartialD)[a_,b_],(xPartialDu|xPartialD)[c_,d_]]:>0/;a=!=c,
xPartialD[xPartialDu[a_,b_],xPartialDu[a_,d_]]:>T[\[Delta],"ud"][b,d],
xPartialD[xPartialDu[a_,b_],xPartialD[a_,d_]]:>T[\[Delta],"uu"][b,d],
xPartialD[xPartialD[a_,b_],xPartialDu[a_,d_]]:>T[\[Delta],"dd"][b,d],
xPartialD[a_,(xPartialDu|xPartialD)[b_,d_]]:>0/;FreeQ[a,(xPartialDu|xPartialD)]
};


(* ::Input::Initialization:: *)
(*Function to generate IntegralOp variables for F[n_] in e1410.*)
xF[n_]:=Module[{out,i},For[out={{x[1],0,1}};i=2,i<=n,i++,AppendTo[out,{x[i],0,1}]];
out
];
Fn[n_]:=Module[{out,i,j},For[out={{x[1],0,1}};i=2,i<=n,i++,AppendTo[out,{x[i],0,1-Sum[x[j-1],{j,2,i}]}]];
out
];
DefPrint["e1410",IntegralOp[{{F[n_]}},a__]:>IntegralOp[xF[n],a (n-1)! DiracDelta[Sum[x[i],{i,1,n}]-1]]]
DefPrint["e1427",IntegralOp[{{q}},1/(2 \[Pi])^d (q^2)^a/(q^2+D)^b]->(Gamma[b-a-d/2]Gamma[a+d/2])/((4 \[Pi])^(d/2) Gamma[b]Gamma[d/2]) D^-(b-a-d/2)]
DefPrint["e1427s",IntegralOp[{{q}},(q^2)^a/(q^2+D)^b]->((2 \[Pi])^d Gamma[b-a-d/2]Gamma[a+d/2])/((4 \[Pi])^(d/2) Gamma[b]Gamma[d/2]) D^-(b-a-d/2)]
DefPrint["e1427hitoshi",IntegralOp[{{q}},(q^2)^a/(q^2-D-I \[CurlyEpsilon])^b]->(I (-1)^(b+a) (2 \[Pi])^d Gamma[b-a-d/2]Gamma[a+d/2])/((4 \[Pi])^(d/2) Gamma[b]Gamma[d/2]) D^-(b-a-d/2)]
DefPrint["e1426",Gamma[-n+\[CurlyEpsilon]]:>(-1)^n/(n)! (1/\[CurlyEpsilon]-\[Gamma]+Sum[k^-1,{k,1,n}])]

CompleteSquare1[denomlist_,var_]:=
(*Finds square of quadradic polynomial, a x x + b x + c -> f( x + d )^2 + e, with var_ as the x_variable.  Returns {Complete quadratic, Shifted quadratic term, Offset, variable shift factor}.  *BUG*)
Module[{factor,coef,denom,n,tmp,tmp1,tmp2,tmp3,sub1,a,b,c,f,d,e,x,sub,sube,subfD2,subfD2e,subshift},
"Generate substitution Rule[] for quadratic polynomial of form.";
Clear[fD2,fD2e,fD2off,varshift];
tmp=a x x + b x + c;(* General quadratic equation*)
tmp1=f*(x+d)^2+e; (* Solution form *)
tmp=tmp-tmp1//Expand//CoefficientList[#,x]&; (* Difference in form. *)
tmp1=Solve[tmp[[3]]==0,f]//First;
tmp=tmp/.tmp1;
tmp2=Solve[tmp[[2]]==0,d]//First;
tmp=tmp/.tmp2;
tmp3=Solve[tmp[[1]]==0,e]//First;
sub1={tmp1,tmp2,tmp3}//Flatten;(* Solutions for {f,d,e} *)
subfD2=fD2->f*(x+d)^2/.sub1; (* f(x + d)^2 part *)
sube=fD2offset->(e/.sub1); (* e part *)
subfD2e=fD2all->f*(x+d)^2+e/.sub1; (* f(x+d)^2+e *)
subshift=varshift->var->var-d/.sub1;(* var-d so that x-d->x  *)
{factor,denom,n}=denomlist[[1;;3]];
coef=CoefficientList[denom,var];
sub=MapThread[#1->#2&,{{c,b,a},coef}];
{subfD2e,subfD2,sube,subshift}/.sub/.x->var
]

(*Factors exp_ in form (1/A1).(1/A2).(1/A3)... into Feynman form, (x[1] A1+...+x[n] An)^n.  Returns {coef, denom, exponent of denom,sum of x[n]}.*)
FactorDotFeynman[exp_]:=Module[{i,n,square,tmp,xs,numer,denom,DEBUG=0},
tmp=Apply[List,exp];
n=Length[tmp];
numer=Thread[Numerator,tmp];
xs=Thread[x[Range[n]]];
numer=Thread[Numerator[tmp]];
tmp=MapThread[#3 #1/#2&,{xs,tmp,numer}];
IfDEBUG["FactorDotFeynman",DEBUG,tmp,"tmp"];
denom=Apply[Plus,tmp]/.Dot->Times;
denom=denom//Expand//SimplifyTensorSum//UpDownAdjust//Simplify;
denom=denom/.x[n]->1-Apply[Plus,Most[xs]]//Expand;
tmp=Apply[Times,numer]/denom^n;
{Apply[Times,numer],denom,n,Apply[Plus,xs]}
]; 
(*
simpleVertex[scalars_List][exp_Vertex] removes all scalars_List from Vertex[]. Only terms retained in Vertex[] are dotOps.  Usage: tmp/.v:Vertex[a__]:> simpleVertex[{e,q}][v] *11Sep2012*)
simpleVertex[scalars_List][exp_Vertex]:=Module[{tmp=exp},
tmp=tmp/.Vertex[a__]:>Vertex[simpleDot1a[scalars][a]];
tmp=tmp/.Vertex[a___ (op:dotOps)[b__]]->a Vertex[op[b]]
];
(*
CollectDotNumerator[exp_Dot|xDot] takes exp_Dot|xDot where each dotted term may be a fraction and converts into a dotted Numerator and Times Denominator.  Assumes that the Denominators of the terms are scalar. *10Nov2012*)
CollectDotNumerator[exp_Dot|xDot]:=Module[{tmp=exp,head,tmpn,tmpd},
head=Head[exp];
tmp=Apply[List,tmp];
tmpn=Map[Numerator[#]&,tmp];
tmpd=Map[Denominator[#]&,tmp];
Apply[head,tmpn]/Apply[Times,tmpd]
];
(*
Peskin-Schroeder 6.42 *10Nov2012*)
PS642[n_]:=1/Product[Subscript[A, i]^Subscript[m, i],{i,n}]->IntegralOp[Table[{Subscript[x, i],0,1},{i,n}],\[Delta][Sum[Subscript[x, i],{i,n}]-1] Product[Subscript[x, i]^(Subscript[m, i]-1),{i,n}]/Sum[Subscript[x, i] Subscript[A, i],{i,n}]^Sum[Subscript[m, i],{i,n}] \[CapitalGamma][Sum[Subscript[m, i],{i,n}]]/Product[\[CapitalGamma][Subscript[m, i]],{i,n}]
];
(*
egRule: Conjugate of bi-spinor product PS.5.2: conjugateUgU=Conjugate[Overscript[u_, _][pu_]].Conjugate[tt:Tensor[\[Gamma],a_,b_]].Conjugate[v_[pv_]]->Overscript[v, _] [pv]. tt.u[pu]
*1Dec2014*)
(*
groupUUpp[p_] Rule that connect Dot[] expressions that end and begin with p_. 1Dec2014*)
groupUUpp[p_]:=(aa:Dot[b__,a_[p]])(bb:Dot[a1_[p],b1__])->aa.bb
(*
FeynmannParameterization[exp_Dot|xDot] takes exp_Dot|xDot which is the result of evaluating vertices and propagators of a Feynmann diagram and converts into an expression using Feynmann parameterization.  *10Nov2012*)
FeynmannParameterization[exp_Dot|xDot]:=Module[{tmp=exp,head,tmpn,tmpd,tmpdconstant,tmpdpow,$n,pow,subA,subm,out},
head=Head[exp];
tmp=Apply[List,tmp];
tmpn=Apply[head,Map[Numerator[#]&,tmp]];
tmpd=Map[Denominator[#]&,tmp];
tmpd=Apply[List,Apply[Times,tmpd]];
tmpdconstant=Join[{1},DeleteCases[tmpd,Except[_NumberQ]]];
tmpd=DeleteCases[tmpd,_NumberQ];
$n=Length[tmpd];
tmpdpow=tmpd/.b_^(pow:c_):>pow;
tmpdpow=Map[If[NumberQ[#],#,1]&,tmpdpow];
subA=MapIndexed[Subscript[A, #2[[1]]]->#1&,tmpd];
subm=MapIndexed[Subscript[m, #2[[1]]]->#1&,tmpdpow];
out=PS642[$n]/.subA/.subm;
Map[tmpn #/tmpdconstant[[1]]&,out]/.\[CapitalGamma]->Gamma
];

(**)
tuCompleteSquareUpDn::usage="tuCompleteSquareUpDn[var_][exp_] converts exp_ of form \[IndentingNewLine]$generalForm=$a xu xd + bu xd + $c \[Rule] $targetForm=$d ((xu+yu)(xd+yd)+$e) . \[IndentingNewLine]It assumes that the $generalForm is a proper Tensor expression and assumes that var_ in a Lower indexed Tensor variable.  Returns {$targetForm, $d, yd, $e} *19Dec2014*";
tuCompleteSquareUpDn[var_][exp_]:=Module[{$generalForm,$targetForm,xu,xd,yu,yd,bu,bd,eyd,tmp,sub1,tmpeL,abc,$a,$b,$c,$d,$e,$x,$y},
(*Build template for converting quadratic to CompleteSquare.*)
xu=T[$x,"u"][\[Mu]]; xd=T[$x,"d"][\[Mu]];
yu=T[$y,"u"][\[Mu]]; yd=T[$y,"d"][\[Mu]];
bu=T[$b,"u"][\[Mu]]; bd=T[$b,"d"][\[Mu]];
$generalForm=$a xu xd + bu xd + $c;(* General quadratic equation*)
$targetForm=$d (xu+yu)(xd+yd)+$e; (* Target form. Find {y's,$d,$e}? *)
tmp=$generalForm-$targetForm/.sLowerAllIndices//CoefficientList[#,xd]&; (*Coefficients must be 0.*)
tmp=Map[#==0&,tmp];
tmp=Solve[tmp,{$e,yd,$d}]//Flatten;
eyd=Append[tmp,tmp[[2]]/.sRaiseAllIndices[{}]]/.bd^2->bd bu;
(*Note $b is a Tensor and figure out what the UpDn indices are assuming that their values is the same.*)
xPrint[tmpeL=exp/.sLowerAllIndices];
xPrint[abc=CoefficientList[tmpeL,var]/.sRaiseAllIndices[{}]];
If[Length[abc]!=3,Print[CR["CompleteSquareUpDn expects 3 coefficients from exp_:",exp]]];
xPrint[abc=Thread[{$c,bu,$a}->abc]];
xPrint[abc=Append[abc,abc[[2]]/.sLowerAllIndices]];
eyd=eyd/.abc;
{$targetForm,$d,yd,$e}/.eyd/.xd->var/.{xu:>var/.sRaiseAllIndices[{}]}
];
CompleteSquareUpDn[exp_,var_]:=tuCompleteSquareUpDn[var][exp];


(* ::Input::Initialization:: *)
(*define dotted/undotted indices for spinor/twistor representations*)
DefineDottedIndices:=Module[{},
DeclareIndexFlavor[{twistor,Orange}];
DeclareBaseIndices[{twistor,{0,1}}];
d0[a_]:=twistor@a;
d1[a_]:=twistor@\!\(\*OverscriptBox[\(a\), \(.\)]\);
(*OverBar Tensor definitions*)
OBu[a_,\[Mu]_]:=Tensor[OverBar[a],{\[Mu]},{Void}];
OBd[a_,\[Mu]_]:=Tensor[OverBar[a],{Void},{\[Mu]}];
OBuu[a_,\[Mu]_,\[Nu]_]:=Tensor[OverBar[a],{\[Mu],\[Nu]},{Void,Void}];
OBud[a_,\[Mu]_,\[Nu]_]:=Tensor[OverBar[a],{\[Mu],Void},{Void,\[Nu]}];
OBdd[a_,\[Mu]_,\[Nu]_]:=Tensor[OverBar[a],{Void,Void},{\[Mu],\[Nu]}];
OBuuu[a_,\[Mu]_,\[Nu]_,\[Alpha]_]:=Tensor[OverBar[a],{\[Mu],\[Nu],\[Alpha]},{Void,Void,Void}];
OBduu[a_,\[Mu]_,\[Nu]_,\[Alpha]_]:=Tensor[OverBar[a],{Void,\[Nu],\[Alpha]},{\[Mu],Void,Void}];
OBudd[a_,\[Mu]_,\[Nu]_,\[Alpha]_]:=Tensor[OverBar[a],{\[Mu],Void,Void},{Void,\[Nu],\[Alpha]}];
OBuud[a_,\[Mu]_,\[Nu]_,\[Alpha]_]:=Tensor[OverBar[a],{\[Mu],\[Nu],Void},{Void,Void,\[Alpha]}];
OBuuud[a_,\[Mu]_,\[Nu]_,\[Alpha]_,\[Beta]_]:=Tensor[OverBar[a],{\[Mu],\[Nu],\[Alpha],Void},{Void,Void,Void,\[Beta]}];
OBuudu[a_,\[Mu]_,\[Nu]_,\[Alpha]_,\[Beta]_]:=Tensor[OverBar[a],{\[Mu],\[Nu],Void,\[Beta]},{Void,Void,\[Alpha],Void}];
(*Default \[Sigma] index expansion*)
\[Sigma]@u[\[Mu]]->\[Sigma]@udd[\[Mu],d0@\[Alpha],d1@\[Beta]];
OBu[\[Sigma],\[Mu]]->OBuuu[\[Sigma],\[Mu],d1@\[Beta],d0@\[Alpha]];
subsigbar={OBu[\[Sigma],a_]:>If[a=!=0,-\[Sigma]@u[a],\[Sigma]@u[a]],OBd[\[Sigma],a_]:>If[a=!=0,-\[Sigma]@d[a],\[Sigma]@d[a]]};
(*Default dotted/undotted expansion function*)
AddDotIndex\[Sigma][a_,b_]:={OBu[\[Sigma],\[Mu]_]:>OBuuu[\[Sigma],\[Mu],d1@a,d0@b]/;\[Mu]=!=0,\[Sigma]@u[\[Mu]_]->\[Sigma]@udd[\[Mu],d0@b,d1@a]};
AddDotIndex\[Sigma]\[Sigma][a_,b_,c_]:={OBu[\[Sigma],\[Mu]_].\[Sigma]@u[\[Nu]_]:>OBuuu[\[Sigma],\[Mu],d1@a,d0@b].\[Sigma]@udd[\[Nu],d0@b,d1@c],
\[Sigma]@u[\[Mu]_].OBu[\[Sigma],\[Nu]_]:>\[Sigma]@udd[\[Mu],d0@a,d1@b].OBuuu[\[Sigma],\[Nu],d1@b,d0@c]};
(*additional OverBar and Dotted routines*)
OBCu[a_,\[Mu]_]:=Tensor[Conjugate[OverBar[a]],{\[Mu]},{Void}];
AddOB[a_Tensor]:=Module[{tmp=a},
tmp[[1]]=OverBar[tmp[[1]]];
tmp];
(* AddDotted adds proper dotted indices to \[Sigma]@u[] and \[Sigma]@uu[]. *)
AddDotted[a_Tensor]:=Module[{tmp=a,nindex=Length[a[[2]]]},
If[a[[1]]=!=\[Sigma]&&Head[a[[1]]]=!=OverBar,
tmp[[2]]=Join[tmp[[2]],{Void}];
tmp[[3]]=Join[tmp[[3]],{d0@$\[Alpha]}]
];
If[a[[1]]=!=\!\(\*OverscriptBox[\(\[Sigma]\), \(_\)]\)&&Head[a[[1]]]===OverBar,
tmp[[2]]=Join[tmp[[2]],{d1@$\[Alpha]}];
tmp[[3]]=Join[tmp[[3]],{Void}]
];
If[nindex===1&&a[[1]]===\[Sigma],(*for \[Sigma]@u[\[Mu]]*)
tmp[[2]]=Join[tmp[[2]],{Void,Void}];
tmp[[3]]=Join[tmp[[3]],{d0@$\[Alpha],d1@$\[Beta]}]
];
If[nindex===1&&a[[1]]===\!\(\*OverscriptBox[\(\[Sigma]\), \(_\)]\),
tmp[[3]]=Join[tmp[[3]],{Void,Void}];
tmp[[2]]=Join[tmp[[2]],{d1@$\[Beta],d0@$\[Alpha]}]
];
If[nindex===2&&a[[1]]===\[Sigma],(*for \[Sigma]@uu[\[Mu],\[Nu]]*)
tmp[[2]]=Join[tmp[[2]],{Void,d0@$\[Beta]}];
tmp[[3]]=Join[tmp[[3]],{d0@$\[Alpha],Void}]
];
If[nindex===2&&a[[1]]===\!\(\*OverscriptBox[\(\[Sigma]\), \(_\)]\),
tmp[[2]]=Join[tmp[[2]],{d1@$\[Alpha],Void}];
tmp[[3]]=Join[tmp[[3]],{Void,d1@$\[Beta]}]
];
tmp
];
AddDottedRule=Tensor[a_,b_,c_]:>AddDotted[Tensor[a,b,c]];
(*AddDotted1 adds dotted indices Tensors (via AddDotted) and nonTensor variables. Correct indices in following step.*)
AddDotted1[a_]:=Module[{tmp=a},
If[Head[tmp]===Tensor,
tmp=AddDotted[tmp],
If[!NumericQ[tmp],
If[Head[tmp]=!=OverBar,
tmp=Tensor[tmp,{Void},{d0@$a}],
tmp=Tensor[tmp,{d1@$b},{Void}]
]
]
];
tmp
];

(*RemoveDotted remove Dotted indices from Tensor.  Assumes Dotted indices are at the end.*)
RemoveDotted[a_Tensor]:=Module[{tmp=a,l2a,length0,l2,l3,remove,list2,list3},
length0=Length[tmp[[2]]];
list2=Position[tmp[[2]],d0@_|d1@_];
list3=Position[tmp[[3]],d0@_|d1@_];
remove= Join[list2,list3];
tmp[[2]]=Delete[tmp[[2]],remove];
tmp[[3]]=Delete[tmp[[3]],remove];
tmp
];
RemoveDottedAll[exp_]:=Module[{tmp=exp},
tmp=tmp/.Tensor[a_,b_,c_]:>RemoveDotted[Tensor[a,b,c]]
];
RemoveDottedRule=Tensor[a_,b_,c_]:>RemoveDotted[Tensor[a,b,c]];
(*Some SUSY identities with Weyl spinors*)
subWeyl={Transpose[\[Alpha]].A.\[Beta]->-Transpose[\[Beta]].Transpose[A].\[Alpha]
};
];



(* ::Input::Initialization:: *)
(*Pauli and Gamma matrix identities*)
tuGammaList::usage:="tuGammaList[indices_List,dot_:Dot] returns dot_'d \[Gamma](up)'s with indices_List.  *18Jan2013*";
tuGammaList[indices_List,dot_:Dot]:=Table[T[\[Gamma],"u",{i}],{i,indices}]//Apply[dot,#]&;
\[Gamma]dot:=tuGammaList;(*Compatibility*)
(**)
tuPauliMatrices::usage="tuPauliMatrices are Rule[]s for expanding Pauli \[Sigma]-matrices to common 2x2 representation. *22Mar2016*";
tuPauliMatrices:=
{
T[\[Sigma],"u",{1}]|T[\[Sigma],"d",{1}]->{{0,1},{1,0}},
T[\[Sigma],"u",{2}]|T[\[Sigma],"d",{2}]->{{0,-I},{I,0}},
T[\[Sigma],"u",{3}]|T[\[Sigma],"d",{3}]->{{1,0},{0,-1}},
T[\[Sigma],"u",{0}]|T[\[Sigma],"d",{0}]->{{1,0},{0,1}},
Subscript[1, 2]->{{1,0},{0,1}},
Subscript[0, 2]->{{0,0},{0,0}}
};
tuPauliExpand:=tuPauliMatrices;(*Compatibility*)
sPauli:=tuPauliMatrices;(*Compatibility*)
(*
Gamma matrix identities *12May2018*
*)
Clear[tuGammaIdentities]
tuGammaIdentities::usage="tuGammaIdentities returns a list of Rules that represent Dirac gamma matrices.  Dot[] is used to indicate matrix multiply. *5Sep2018*";
tuGammaIdentities:=Module[{$,$1},
$={
T[\[Gamma],"u"][\[Mu]_].T[\[Gamma],"u"][\[Mu]_]->T[g,"uu"][\[Mu],\[Mu]],
T[\[Gamma],"d"][\[Mu]_].T[\[Gamma],"d"][\[Mu]_]->T[g,"dd"][\[Mu],\[Mu]],
$=CommutatorP[T[\[Gamma],"u"][\[Mu]],T[\[Gamma],"u"][\[Nu]]]->2 T[g,"uu"][\[Mu],\[Nu]];
$//tuAddPatternVariable[{\[Mu],\[Nu]}],
$=$/.tuCommutatorExpand;
$//tuAddPatternVariable[{\[Mu],\[Nu]}],
$//tuRuleSolveF[T[\[Gamma],"u"][\[Mu]].T[\[Gamma],"u"][\[Nu]]]//First//tuAddPatternVariable[{\[Mu],\[Nu]}],

$=CommutatorP[T[\[Gamma],"d"][\[Mu]],T[\[Gamma],"d"][\[Nu]]]->2 T[g,"dd"][\[Mu],\[Nu]];
$//tuAddPatternVariable[{\[Mu],\[Nu]}],
$=$/.tuCommutatorExpand;
$//tuAddPatternVariable[{\[Mu],\[Nu]}],
$//tuRuleSolveF[T[\[Gamma],"d"][\[Mu]].T[\[Gamma],"d"][\[Nu]]]//First//tuAddPatternVariable[{\[Mu],\[Nu]}],

T[\[Gamma],"u",{5}]->I tuGammaList[{0,1,2,3}],
ConjugateTranspose[T[\[Gamma],"u",{5}]]->T[\[Gamma],"u",{5}],
T[\[Gamma],"u",{5}].T[\[Gamma],"u",{5}]->Subscript[1, 4],

tuGammaList[{0,5,0}]->T[\[Gamma],"u",{5}],
$=ConjugateTranspose[T[\[Gamma],"u",{\[Mu]_}]]->tuGammaList[{0,\[Mu],0}],
$//tuIndicesLower[{\[Mu],\[Mu]_}],

$=CommutatorP[T[\[Gamma],"u",{\[Mu]}],T[\[Gamma],"u",{5}]]->0;
$//tuAddPatternVariable[\[Mu]],
$=$/.tuCommutatorExpand;
tuRuleDelayAdd[$,\[Mu]!=5]//tuAddPatternVariable[\[Mu]],
$1=$[[1,1]]->$[[2]]-$[[1,2]];
tuRuleDelayAdd[$1,\[Mu]!=5]//tuAddPatternVariable[\[Mu]],
$1=$[[1,2]]->$[[2]]-$[[1,1]];
tuRuleDelayAdd[$1,\[Mu]!=5]//tuAddPatternVariable[\[Mu]],

T[\[Gamma],"u",{a_}].T[\[Gamma],"d",{a_}]->4 Subscript[1, 4],

T[\[Gamma],"u",{a_}].T[\[Gamma],"u",{b_}].T[\[Gamma],"d",{a_}]->-2 T[\[Gamma],"u",{b}],
T[\[Gamma],"u",{a_}].T[\[Gamma],"d",{b_}].T[\[Gamma],"d",{a_}]->-2 T[\[Gamma],"d",{b}],

T[\[Gamma],"u",{a_}].T[\[Gamma],"u",{b_}].T[\[Gamma],"u",{c_}].T[\[Gamma],"d",{a_}]->
4 T[\[Eta],"uu",{b,c}]Subscript[1, 4],
T[\[Gamma],"u",{a_}].T[\[Gamma],"d",{b_}].T[\[Gamma],"d",{c_}].T[\[Gamma],"d",{a_}]->4 T[\[Eta],"uu",{b,c}] Subscript[1, 4],

T[\[Gamma],"u",{a_}].T[\[Gamma],"u",{b_}].T[\[Gamma],"u",{c_}].T[\[Gamma],"u",{d_}].T[\[Gamma],"d",{a_}]->-2T[\[Gamma],"u",{d}].T[\[Gamma],"u",{c}].T[\[Gamma],"u",{b}],

T[\[Gamma],"u",{a_}].T[\[Gamma],"d",{b_}].T[\[Gamma],"d",{c_}].T[\[Gamma],"d",{d_}].T[\[Gamma],"d",{a_}]->-2T[\[Gamma],"d",{d}].T[\[Gamma],"d",{c}].T[\[Gamma],"d",{b}]
};
$
];
(*Gamma matrices in Pauli matrices*)
tuGammaPauli::usage="tuGammaPauli[basis_] gives List[]s of Rule for Gamma matrices in terms of Pauli \[Sigma] matrices for basis_: {Dirac,Weyl,Majorana}. *12May2018*";
tuGammaPauli[basis_]:=
Switch[basis,
"Dirac",
{
T[\[Gamma],"u"][0]->{{T[\[Sigma],"u"][0],Subscript[0, 2]},{Subscript[0, 2],-T[\[Sigma],"u"][0]}},
T[\[Gamma],"u"][i:(1|2|3)]->{{Subscript[0, 2],T[\[Sigma],"u"][i]},{-T[\[Sigma],"u"][i],Subscript[0, 2]}},
T[\[Gamma],"u"][5]->{{Subscript[0, 2],Subscript[1, 2]},{Subscript[1, 2],Subscript[0, 2]}}
},
"Weyl",
{
T[\[Gamma],"u"][0]->{{Subscript[0, 2],Subscript[1, 2]},{Subscript[1, 2],Subscript[0, 2]}},
T[\[Gamma],"u"][i:(1|2|3)]->{{Subscript[0, 2],T[\[Sigma],"u"][i]},{-T[\[Sigma],"u"][i],Subscript[0, 2]}},
T[\[Gamma],"u"][5]->{{-Subscript[1, 2],Subscript[0, 2]},{Subscript[0, 2],Subscript[1, 2]}}
},
"Majorana",
{
T[\[Gamma],"u"][0]->{{Subscript[0, 2],T[\[Sigma],"u"][2]},{T[\[Sigma],"u"][2],Subscript[0, 2]}},
T[\[Gamma],"u"][1]->{{I T[\[Sigma],"u"][3],Subscript[0, 2]},{Subscript[0, 2],I T[\[Sigma],"u"][3]}},
T[\[Gamma],"u"][2]->{{Subscript[0, 2],-T[\[Sigma],"u"][2]},{T[\[Sigma],"u"][2],Subscript[0, 2]}},
T[\[Gamma],"u"][3]->{{-I T[\[Sigma],"u"][1],Subscript[0, 2]},{Subscript[0, 2],-I T[\[Sigma],"u"][1]}},
T[\[Gamma],"u"][5]->{{ T[\[Sigma],"u"][2],Subscript[0, 2]},{Subscript[0, 2],- T[\[Sigma],"u"][2]}},
C[CG["charge conjugation"]]->{{Subscript[0, 2],-I T[\[Sigma],"u"][2]},{-I T[\[Sigma],"u"][2],Subscript[0, 2]}}
}
];

tuGammaExpanded::usage="tuGammaExpanded[basis_] are Rules for 4x4 \[Gamma]-matices in the basis_:{Dirac,Weyl,Majorana} *12May2018*";
tuGammaExpanded[basis_]:=Flatten[{
dum$=Map[#->ArrayFlatten[#//.tuGammaPauli[basis]//.tuPauliMatrices]&,Table[T[\[Gamma],"u",{\[Mu]}],{\[Mu],{0,1,2,3,5}}]],
dum$=dum$//tuIndicesLower[{0,1,2,3,5}];
dum$=Map[MapAt[-#&,#,2]&,dum$],
Subscript[1, 4]->DiagonalMatrix[{1,1,1,1}]
}
];
tuGammaExpand::usage="tuGammaExpand Rule[]s for \[Gamma] matrix standard 4x4 expansion.";
tuGammaExpand:=tuGammaExpanded["Dirac"]; (*Compatibility*)
sub\[Gamma]Matrices:=tuGammaExpanded["Dirac"];(*Compatibility*)

(******************************)   (******************************)
(*
Generate Tr[\[Gamma]^i] Rules for {i,{2,4,n}} *18Jan2013*)
generateTr\[Gamma][n_]:=Module[{sub,tmp,tmp0,indices,test,nlim,n0,collection={},char,char0,ii},
char=CharacterRange["a","z"]//ToExpression;
sub=\[Gamma]@u[a].\[Gamma]@u[b_]->-\[Gamma]@u[b].\[Gamma]@u[a]+2 g@uu[a,b];(*a is marker index*)
Do[char0=char[[1;;n0]];
indices=Table[ii,{ii,char0}];
tmp0=tmp=Tr[\[Gamma]dot[indices]];
nlim=1;
While[nlim<20&&test=!=tmp,
test=tmp;
tmp=tmp/.sub//.simpleTr2[{g@uu[_,_]}];
nlim++
];
tmp=tmp0->(tmp/.Dot[b_,\[Gamma]@u[a]]->Dot[\[Gamma]@u[a],b]);
tmp=(RuleX[tmp,tmp0]/.Tr[]->4)//First//RuleVarPattern[char0];
AppendTo[collection,tmp];
,{n0,2,n,2}];
tmp=Map[MapAt[#//.collection&,#,2]&,collection]//Simplify;
tmp0=tmp/.sLowerAllIndices;
Join[tmp,tmp0]
];
(*
PeskinSchroeder \[Gamma] Rules.*)
psa16={(ACommutator[T[\[Gamma],"u"][\[Mu]_],T[\[Gamma],"u"][\[Nu]_]]/.Dot->dotOps)->2 T[g,"uu"][\[Mu],\[Nu]],
(ACommutator[T[\[Gamma],"d"][\[Mu]_],T[\[Gamma],"d"][\[Nu]_]]/.Dot->dotOps)->2 T[g,"dd"][\[Mu],\[Nu]]
};
psa16a={\[Gamma]@u[\[Mu]_].\[Gamma]@u[\[Nu]_]->2 g@uu[\[Mu],\[Nu]]-\[Gamma]@u[\[Nu]].\[Gamma]@u[\[Mu]],
\[Gamma]@d[\[Mu]_].\[Gamma]@d[\[Nu]_]->2 g@dd[\[Mu],\[Nu]]-\[Gamma]@d[\[Nu]].\[Gamma]@d[\[Mu]]};
ps368=\[Gamma]@u[5]->I \[Gamma]@u[0].\[Gamma]@u[1].\[Gamma]@u[2].\[Gamma]@u[3];
ps369={
ConjugateTranspose[\[Gamma]@u[5]]->\[Gamma]@u[5] ,
\[Gamma]@u[0].\[Gamma]@u[5].\[Gamma]@u[0]->\[Gamma]@u[5]};
wiki1={ConjugateTranspose[\[Gamma]@u[\[Mu]_]]->\[Gamma]@u[0].\[Gamma]@u[\[Mu]].\[Gamma]@u[0],ConjugateTranspose[\[Gamma]@d[\[Mu]_]]->\[Gamma]@u[0].\[Gamma]@d[\[Mu]].\[Gamma]@u[0]};

ps370=\[Gamma]@u[5].\[Gamma]@u[5]->1;
ps371=ACommutator[\[Gamma]@u[\[Mu]],\[Gamma]@u[5]]->0;
ps55a=Tr[Id]->4;
ps55b={Tr[\[Gamma]@u[a_]]:>0/;MemberQ[{0,1,2,3},a],
Tr[\[Gamma]@u[a_].\[Gamma]@u[b_].\[Gamma]@u[c_]]:>0/;FreeQ[{a,b,c},5],
Tr[\[Gamma]@u[a_].\[Gamma]@u[b_].\[Gamma]@u[c_].\[Gamma]@u[d_].\[Gamma]@u[e_]]:>0/;FreeQ[{a,b,c,d,e},5]
};
ps55c={
Tr[\[Gamma]@u[\[Mu]_].\[Gamma]@u[\[Nu]_]]:>4 g@uu[\[Mu],\[Nu]]/;FreeQ[{\[Mu],\[Nu]},5],
Tr[\[Gamma]@d[\[Mu]_].\[Gamma]@d[\[Nu]_]]:>4 g@dd[\[Mu],\[Nu]]/;FreeQ[{\[Mu],\[Nu]},5],
Tr[\[Gamma]@u[\[Mu]_].\[Gamma]@u[\[Nu]_]]:>0/;(\[Mu]===5&&\[Nu]=!=5)||(\[Mu]=!=5&&\[Nu]===5)};
ps55d={Tr[\[Gamma]@u[a_].\[Gamma]@u[b_].\[Gamma]@u[c_].\[Gamma]@u[d_]]:>4(g@uu[a,b]g@uu[c,d]-g@uu[a,c]g@uu[b,d]+g@uu[a,d]g@uu[b,c])/;FreeQ[{a,b,c,d},5],
Tr[\[Gamma]@d[a_].\[Gamma]@d[b_].\[Gamma]@d[c_].\[Gamma]@d[d_]]:>4(g@dd[a,b]g@dd[c,d]-g@dd[a,c]g@dd[b,d]+g@dd[a,d]g@dd[b,c])/;FreeQ[{a,b,c,d},5],
Tr[\[Gamma]@u[a_].\[Gamma]@u[b_].\[Gamma]@u[c_].\[Gamma]@u[d_]]:>0/;Count[{a,b,c,d},5]===1
};
ps55e={
Tr[\[Gamma]@u[5]]->0,
Tr[\[Gamma]@u[a_].\[Gamma]@u[b_]]:>0/;Count[{a,b},5]===1,
Tr[\[Gamma]@u[a_].\[Gamma]@u[b_].\[Gamma]@u[c_]]:>0/;Count[{a,b,c},5]===1
};
psA27g={
Tr[\[Gamma]@u[a_].\[Gamma]@u[b_].\[Gamma]@u[c_].\[Gamma]@u[d_].\[Gamma]@u[5]]->-4 I \[Epsilon]@uuuu[a,b,c,d],
Tr[\[Gamma]@u[5].\[Gamma]@u[a_].\[Gamma]@u[b_].\[Gamma]@u[c_].\[Gamma]@u[d_]]->-4 I \[Epsilon]@uuuu[a,b,c,d]};
psA29={(*Einstein summed. sLowerAllIndices NEEDS to be handled seperately. TODO: generalize to make this independent of up-down indices of uncontracted \[Gamma]'s *)
\[Gamma]@u[a_].\[Gamma]@d[a_]->4,
\[Gamma]@u[a_].\[Gamma]@u[b_].\[Gamma]@d[a_]->-2 \[Gamma]@u[b],
\[Gamma]@u[a_].\[Gamma]@u[b_].\[Gamma]@u[c_].\[Gamma]@d[a_]->4 g@uu[b,c],
\[Gamma]@u[a_].\[Gamma]@u[b_].\[Gamma]@u[c_].\[Gamma]@u[d_].\[Gamma]@d[a_]->-2 \[Gamma]@u[d].\[Gamma]@u[c].\[Gamma]@u[b],
\[Gamma]@u[a_].\[Gamma]@d[b_].\[Gamma]@d[a_]->-2 \[Gamma]@d[b],
\[Gamma]@u[a_].\[Gamma]@d[b_].\[Gamma]@d[c_].\[Gamma]@d[a_]->4 g@dd[b,c],
\[Gamma]@u[a_].\[Gamma]@d[b_].\[Gamma]@d[c_].\[Gamma]@d[d_].\[Gamma]@d[a_]->-2 \[Gamma]@d[d].\[Gamma]@d[c].\[Gamma]@d[b],
\[Gamma]@d[a_].\[Gamma]@u[a_]->4,
\[Gamma]@d[a_].\[Gamma]@u[b_].\[Gamma]@u[a_]->-2 \[Gamma]@u[b],
\[Gamma]@d[a_].\[Gamma]@u[b_].\[Gamma]@u[c_].\[Gamma]@u[a_]->4 g@uu[b,c],
\[Gamma]@d[a_].\[Gamma]@u[b_].\[Gamma]@u[c_].\[Gamma]@u[d_].\[Gamma]@u[a_]->-2 \[Gamma]@u[d].\[Gamma]@u[c].\[Gamma]@u[b],
\[Gamma]@d[a_].\[Gamma]@d[b_].\[Gamma]@u[a_]->-2 \[Gamma]@d[b],
\[Gamma]@d[a_].\[Gamma]@d[b_].\[Gamma]@d[c_].\[Gamma]@u[a_]->4 g@dd[b,c],
\[Gamma]@d[a_].\[Gamma]@d[b_].\[Gamma]@d[c_].\[Gamma]@d[d_].\[Gamma]@u[a_]->-2 \[Gamma]@d[d].\[Gamma]@d[c].\[Gamma]@d[b]
};

(*Review for accuracy and consistency*)
simpleGammau={
ps370,ps369,wiki1,
\[Gamma]@u[i_].\[Gamma]@u[i_]->g@uu[i,i],
ps55a,ps55b,ps55b,ps55c,ps55e,ps55d,
psA27g,psA29
}//DeleteDuplicates;
simpleGamma=Append[simpleGammau,{(simpleGammau//.{sLowerAllIndices,T[g,"uu"][i_,j_]->T[g,"dd"][i,j]}),simpleDot}]//Flatten//DeleteDuplicates;

sPauliFlatten::usage:="sPauliFlatten[exp_] changes exp_ with Pauli matrices with standard representation. Applies ArrayFlatten to List's in exp_ to convert to matrix form. *24Apr2015*";
sPauliFlatten[exp_]:=Module[{$=exp},
$=$//.sPauli;
$=$/.ll:List[__]:>ArrayFlatten[ll]
];

(* SU[2] \[Sigma] commutation relationship *)
su2commutation[lab_,a_,b_,c_]:={MCommutator[Tensor[lab,{a},{Void}],Tensor[lab,{b},{Void}]]->I \[Epsilon]uuu[a,b,c]Tensor[lab,{c},{Void}]}
tuSU2commutation::usage="tuSU2commutation[lab_] Rule for converting commutation relation of SU2 vectors Tensor[] with symbol lab_.  On output c$ index is summed over. *8Apr2016*";
tuSU2commutation[lab_]:=({CommutatorM[Tensor[lab,{a},{Void}],Tensor[lab,{b},{Void}]]->2 I T[\[Epsilon],"uuu",{a,b,c$}]Tensor[lab,{Void},{c$}],CommutatorM[Tensor[lab,{Void},{a}],Tensor[lab,{Void},{b}]]->2 I T[\[Epsilon],"ddd",{a,b,c$}]Tensor[lab,{c$},{Void}]}//tuAddPatternVariable[{a,b}]);

(*
Rules that simplifies Dot[\[Sigma]@u[n]] expressions *22Jul2013*)
simplePauli={
(*0[\[Sigma]] rules*)
dotOps[b___,0[\[Sigma]] ,  a___]->0[\[Sigma]],(*dotOps[a_ ,  0[\[Sigma]]]->0[\[Sigma]],*)
0[\[Sigma]]^n_->0[\[Sigma]],
a__  0[\[Sigma]]->0[\[Sigma]],
dotOps[a___,0[\[Sigma]],b___]->0[\[Sigma]],
Plus[a___,0[\[Sigma]],b___]:>a+b,
(*Id[\[Sigma]] rules*)
\[Sigma]@u[0]|\[Sigma]@d[0]->Id[\[Sigma]],
\!\(\*OverscriptBox[\(Id[\[Sigma]]\), \(_\)]\)|Conjugate[Id[\[Sigma]]]|Transpose[Id[\[Sigma]]]->Id[\[Sigma]],
dotOps[Id[\[Sigma]],Id[\[Sigma]]]->Id[\[Sigma]],
(dd:dotOps)[a___,Id[\[Sigma]],b___]->dd[a,b],
Id[\[Sigma]]^n_->Id[\[Sigma]],

ConjugateTranspose[\[Sigma]@u[a_]]->\[Sigma]@u[a],
ConjugateTranspose[\[Sigma]@d[a_]]->\[Sigma]@d[a],
Transpose[\[Sigma]@d[a_]]:>\[Sigma]@d[a]/;MemberQ[Flatten[{0,1,3,space/@{1,3}}],a],
Transpose[\[Sigma]@u[a_]]:>\[Sigma]@u[a]/;MemberQ[Flatten[{0,1,3,space/@{1,3}}],a],
Transpose[\[Sigma]@d[a_]]:>-\[Sigma]@d[a]/;MemberQ[{2,space@2},a],
Transpose[\[Sigma]@u[a_]]:>-\[Sigma]@u[a]/;MemberQ[{2,space@2},a],

Conjugate[\[Sigma]@d[a_]]:>\[Sigma]@d[a]/;MemberQ[Flatten[{0,1,3,space/@{1,3}}],a],
Conjugate[\[Sigma]@u[a_]]:>\[Sigma]@u[a]/;MemberQ[Flatten[{0,1,3,space/@{1,3}}],a],
Conjugate[\[Sigma]@d[a_]]:>-\[Sigma]@d[a]/;MemberQ[Flatten[{2,space/@2}],a],
Conjugate[\[Sigma]@u[a_]]:>-\[Sigma]@u[a]/;MemberQ[Flatten[{2,space/@2}],a],

dotOps[\[Sigma]@d[a_],\[Sigma]@d[b_]]:>(KroneckerDelta[a,b] Id[\[Sigma]]+I  Sum[LeviCivitaTensor[3][[a,b,i$]].\[Sigma]@d[i$],{i$,3}]//.simpleDot)/;MemberQ[Flatten[{1,2,3,space/@{1,2,3}}],a]&&MemberQ[Flatten[{1,2,3,space/@{1,2,3}}],b],
dotOps[\[Sigma]@u[a_],\[Sigma]@u[b_]]:>(KroneckerDelta[a,b]Id[\[Sigma]]+I  Sum[LeviCivitaTensor[3][[a,b,i$]].\[Sigma]@u[i$],{i$,3}]//.simpleDot)/;(MemberQ[Flatten[{1,2,3,space/@{1,2,3}}],a]&&MemberQ[Flatten[{1,2,3,space/@{1,2,3}}],b]),
\!\(\*OverscriptBox[\(\[Sigma]@d[a_]\), \(_\)]\):>-\[Sigma]@d[a]/;MemberQ[{2,space@2},a],
\!\(\*OverscriptBox[\(\[Sigma]@u[a_]\), \(_\)]\):>-\[Sigma]@u[a]/;MemberQ[{2,space@2},a]
};

(* Applies simplePauli and simpleDot repeatedly *)
simplePauli1[exp_,scalar_List]:=Module[{tmp=exp,tmp1},
tmp=tmp/.xDot->Dot;
While[tmp=!=tmp1,
tmp1=tmp;
tmp=tmp//.simplePauli//.simpleDot2[scalar]
];
tmp
];
simplePauli1[scalar_List][exp_]:=simplePauli1[exp,scalar]
(*
subPauli[pattern_List:{}] putputs a list of common Rule[]s for Pauli spin matrices.  pattern_List are variables used to apply RuleVarPattern[pattern]. *27Oct2014*)
subPauli[pattern_List:{}]:=Module[{sub,$\[Sigma]},
$\[Sigma][i_]:=T[\[Sigma],"u"][i];
sub={
MCommutator[$\[Sigma][i],$\[Sigma][j]]:>2 I T[\[Epsilon],"uuu"][i,j,k]$\[Sigma][k]/;FreeQ[{i,j,k},0],
ACommutator[$\[Sigma][i],$\[Sigma][j]]:>2 T[\[Delta],"uu"][i,j]/;FreeQ[{i,j},0],
Dot[$\[Sigma][i],$\[Sigma][j]]:>I  T[\[Epsilon],"uuu"][i,j,k]$\[Sigma][k]+T[\[Delta],"uu"][i,j]/;FreeQ[{i,j,k},0],
$\[Sigma][i].$\[Sigma][0]->$\[Sigma][i],
$\[Sigma][0].$\[Sigma][i]->$\[Sigma][i]
};
RuleVarPattern[pattern]/@sub
]
(**)
Clear[sub\[Gamma]Matrices]

(**)
tuGammaPauliExpand::usage="tuGammaPauliExpand Rule[] for \[Gamma] matrix expansion into Dirac \[Sigma] matrices.";
tuGammaPauliExpand:=tuGammaPauli["Dirac"];(*Compatibility*)
sub\[Gamma]Pauli:=tuGammaPauli["Dirac"];(*Compatibility*)

(*Evaluates xDot expression using Dot for actual matrix multiply but maintaining order of xDot terms.  Used in EvalVia\[Sigma]Matrices*)
AxDot2Dot[xDotexp_]:=Module[{tmp,a,A$},
tmp=MapIndexed[Map[A$[#2],#1,{2}]&,xDotexp,1];(*Mark for order*)
tmp=tmp/.xDot->Dot;(*Do Dot[]*)
Off[Dot::dotsh];
tmp=tmp/.Times->Dot;(*fix ordering. This step cause error messages.*)
On[Dot::dotsh];
tmp=tmp/.A$[_][a_]->a;(*remove ordering parameter*)
tmp=tmp/.simpleDot;(*simplify*)
tmp=tmp//.sub\[Gamma]Pauli/.xDot->Dot;(*simplify \[Sigma]*)
tmp=tmp/.sPauli;(*expand \[Sigma] for each element in Dot[]*)
tmp=Map[ArrayFlatten[#]&,tmp](**)
];
(*Evaluates matrix exp_ with \[Gamma] matrices to pure matrix expression via \[Sigma] matrices *)
EvalVia\[Sigma]Matrices[exp_]:=Module[{tmp=exp,a},
tmp=tmp//.sub\[Gamma]Pauli;
tmp=tmp/.xDot[a___]:>AxDot2Dot[xDot[a]]
];

tuMatrixFactor::usage="tuMatrixFactor[EXP_?MatrixQ] separates common multiplicative factors from EXP_?Matrix into {common factor, stripped matrix}. *17May2018*";
tuMatrixFactor[EXP_?MatrixQ]:=Module[{$0=EXP//Simplify,c$=Unique[],$,$s},
$=$0;
$s=Table[{c$[i]},{i,1,Length[$]}];
$=Transpose[$] .$s//Simplify//Flatten//First//Simplify;
$=$->0//tuRuleRHS0factor//Flatten;
$=$//Select[#,tuHasNoneQ[#,c$[_]]&]&;
$s=#[[1]]&/@$//Apply[Times,#]&;
{$s,$0/$s}
];

Clear[tuMatrixOrderedMultiply];
tuMatrixOrderedMultiply::usage="tuMatrixOrderedMultiply[exp_] evaluates top Level matrix expressions (Head->dotOps) using Dot for actual matrix multiply but maintaining order of elements from each matrix.  The matrix inputs must have the same proper form and sizes. This routine is useful when matrix elements are noncommuting matrices. *18Feb2016*";
tuMatrixOrderedMultiply[exp_]:=Module[{tmp,A$,head,pos,$p,i,$n,$},
pos=tuExtractPositionPattern[dotOps][exp];xPrint[">>",pos];
pos=tuPositionNestDelete[pos];xPrint[">>",pos];
(*extract top level dotOps terms*)
Do[
$p=pos[[i,1]]; xPrint[$p,"<<"];
$p=If[$p[[-1]]==0,Delete[$p,-1]];(*delete Head index*)
$=Part[exp,Apply[Sequence,$p]];xPrint["===",$];
pos[[i,1]]=$p;
If[MatchQ[head=Head[$],dotOps],
(*Matrix multiply only first level*)
tmp=MapIndexed[Map[A$[#2],#1,{2}]&,$];
tmp=tmp/.head->Dot;(*rely on lexiconical ordering of Times NOTE: may not properly handle mixed dotOps in expression. *)
tmp=tmp/.Times->head;(*fix ordering within matrix elements.*)
tmp=tmp/.A$[_][a_]->a  (*remove ordering header*)
];
pos[[i,2]]=tmp
,
{i,Length[pos]}];
tuReplacePart [exp,pos]
];

OrderedxDotMultiply[exp_xDot]:=tuMatrixOrderedMultiply[exp];(*Compatibility*)
OrderedxDotMultiplySimpleDot[scalar_List][exp_xDot]:=Module[{tmp},
tmp=OrderedxDotMultiply[exp];
tmp//.tuOpSimplify[dotOps,scalar]
];
OrderedxDotMultiplyAll[scalar_List:{}][exp_]:=Module[{tmp=exp},
tmp=tmp//.xDot[a__]:>OrderedxDotMultiplySimpleDot[scalar][xDot[a]]
];

tuArrayFlatten::usage="tuArrayFlatten[exp_] applies ArrayFlatten to possible Matrix  terms in exp_. *24Jun2016*";
tuArrayFlatten[exp_]:=Module[{$=exp,$s},
$s=$//.List->xList;
(*find potential Matrices*)
$s=$s//tuExtractPositionPattern[ xList[xList[__],__] ];(*List does not work with tuExtractPositionPattern*)
$s=$s//.xList->List//tuPositionNestDelete;
$s=Map[#[[1]]->ArrayFlatten[#[[2]]]&,$s];
$s=Select[$s,MatrixQ[#[[2]]]&];
tuReplacePart[$,$s]
];

(*Defines SU3 representations, n->1: PS.20.38 *)
DefSU3rep[n_]:=Module[
{},
Switch[n,1,
DefineTensor[D,\[Tau],T,t];
SU3rep={
t@u[4]->{{0,0,1},{0,0,0},{1,0,0}}/2,
t@u[5]->{{0,0,-I},{0,0,0},{I,0,0}}/2,
t@u[6]->{{0,0,0},{0,0,1},{0,1,0}}/2,
t@u[7]->{{0,0,0},{0,0,-I},{0,I,0}}/2,
t@u[8]->{{1,0,0},{0,1,0},{0,0,-2}}/(2Sqrt[3])
};
For[i$=1,i$<=3,i$++,
tmp=\[Sigma]@u[i$]/2/.sPauli;
tmp=ArrayPad[tmp,{{0,1},{0,1}}];
AppendTo[SU3rep,t@u[i$]->tmp];
];
SU3rep=Sort[SU3rep];
Column[
SU3rep];
];
];
(**)
tuTrGamma::usage="tuTrGamma are Rule[]s to reduce Tr[\[Gamma]'s] expressions *11Mar2016*";
tuTrGamma:={Tr[]->1,
Tr[0]->0,
Tr[Subscript[1, n_]]->dim[n],(* new *)
Tr[Tensor[\[Gamma],{u_},{d_}]]->0,

Tr[(oo:dotOps)[Tensor[\[Gamma],u1_,d1_],Tensor[\[Gamma],u2_,d2_]] ]:>4 Tensor[g,Flatten[{u1,u2}],Flatten[{d1,d2}]]/;!MemberQ[Flatten[{u1,d1,u2,d2}],5],

(oo:dotOps)[Tr[Tensor[\[Gamma],{u1_},{d1_}],Tensor[\[Gamma],{u2_},{d2_}]] ]:>0/;Count[Flatten[{u1,d1,u2,d2}],5]==1,
Tr[dd:dotOps[a__]]:>0/;allGammaQ[dd]&&((EvenQ[Length[dd]]&&Count[dd,Tensor[\[Gamma],{Void|5},{Void|5}]]==1)||
OddQ[Length[dd]]&&Count[dd,Tensor[\[Gamma],{Void|5},{Void|5}]]==0
),
Tr[dd:dotOps[a__]]:>0/;allGammaQ[dd]&&((Length[dd]==3&&Count[dd,Tensor[\[Gamma],{Void|5},{Void|5}]]==1)
),

Tr[Tensor[\[Gamma],a1_,b1_].Tensor[\[Gamma],a2_,b2_].Tensor[\[Gamma],a3_,b3_].Tensor[\[Gamma],a4_,b4_]]:>4((Tensor[g,Flatten[{a1,a2}],Flatten[{b1,b2}]]Tensor[g,Flatten[{a3,a4}],Flatten[{b3,b4}]])
-(Tensor[g,Flatten[{a1,a3}],Flatten[{b1,b3}]]Tensor[g,Flatten[{a2,a4}],Flatten[{b2,b4}]])
+(Tensor[g,Flatten[{a1,a4}],Flatten[{b1,b4}]]Tensor[g,Flatten[{a2,a3}],Flatten[{b2,b3}]])
)/;!MemberQ[Flatten[{a1,a2,a3,a4,b1,b2,b3,b4}],5],

Tr[dotOps[Tensor[\[Gamma],a1_,b1_],Tensor[\[Gamma],a2_,b2_],Tensor[\[Gamma],a3_,b3_],Tensor[\[Gamma],a4_,b4_],Tensor[\[Gamma],a5_,b5_]]]:>-4I Tensor[\[Epsilon],
Flatten[{a1,a2,a3,a4}],Flatten[{b1,b2,b3,b4}]]/;MemberQ[Flatten[{a5,b5}],5],
(*In case \[Gamma]^5 is not at end.*)
Tr[(dd:dotOps)[a_,b__]]:>-4I \[Epsilon]@uuuu[ Apply[Sequence,Extract\[Gamma]Indices[DeleteCases[dd[a,b],\[Gamma]@u[5]]]]]/;(allGammaQ[dd[a,b]]&&Length[dd[a,b]]==5&&Count[dd[a,b],\[Gamma]@u[5]]==1)
};
subTraceGamma0:=tuTrGamma; (*Compatibility*)
(* 
Test if exp_ is Listable list of all \[Gamma]@u[]||\[Gamma]@d[] *12Oct2012*)
allGammaQ[exp_]:=Apply[And,Map[MemberQ[{#},T[\[Gamma],"u"][_]]||MemberQ[{#},T[\[Gamma],"d"][_]]&,Apply[List,exp]]];
(* Extracts list of indices from dot product of \[Gamma]@u[]s. *)
Extract\[Gamma]Indices[exp_]:=Flatten[Apply[List,exp]/.Tensor[\[Gamma],a_,b_]->a];

(* Test of subTraceGamma0.
tmp={Tr[Id],Tr[\[Gamma]@u[5]],Tr[\[Gamma]@u[a]],Tr[\[Gamma]@u[a].\[Gamma]@u[b]],Tr[\[Gamma]@u[a].\[Gamma]@u[5]],Tr[\[Gamma]@u[a].\[Gamma]@u[d].\[Gamma]@u[c]],Tr[\[Gamma]@u[a].\[Gamma]@u[d].\[Gamma]@u[5]],Tr[\[Gamma]@u[a].\[Gamma]@u[b].\[Gamma]@u[c].\[Gamma]@u[d]],Tr[\[Gamma]@u[a].\[Gamma]@u[b].\[Gamma]@u[c].\[Gamma]@u[5]],Tr[\[Gamma]@u[a].\[Gamma]@u[b].\[Gamma]@u[c].\[Gamma]@u[d].\[Gamma]@u[e]],Tr[\[Gamma]@u[a].\[Gamma]@u[b].\[Gamma]@u[c].\[Gamma]@u[d].\[Gamma]@u[5]]}
TableForm[
Map[{#,#/.subTraceGamma0}&,tmp]
];     *)
(*
simpleTrGamma1[scalar_List][exp_] simplifies Tr[\[Gamma]'s] terms in exp_. Assumes NDim. *7Dec2015*)
simpleTrGamma1[scalar_List:{}][exp_]:=Module[{$tmp=exp,test},
While[test=!=$tmp,
test=$tmp;
$tmp=$tmp//.simpleTr2[scalar]//simpleDot3[scalar];
$tmp=$tmp//GammaLeft[\[Gamma]@d[5]]//GammaLeft[\[Gamma]@u[5]];
$tmp=$tmp//.subTraceGamma0//.simpleGamma
];
$tmp
]
(*
simpleTrGamma[exp_] simplifies Tr[Dot[\[Gamma]'s] terms in exp_.  Implements all of the relations in PS.A.27. OBSOLETE: use simpleTrGamma1 *24Sep2012*)
simpleTrGamma[exp_]:=Module[{tmp,sub,subu,subd},
sub={Tr[]->1,Tr[0]->0,
Tr[Id|Id[__]]:>NDim,(*assume 4-dim.*)
Tr[\[Gamma]@d[_]]->0,
Tr[\[Gamma]@u[_]]->0,
Tr[-a_]->-Tr[a],
(*Even and Odd number of \[Gamma]'s. *)
Tr[(op:dotOps)[a__]]:>0/;(allGammaQ[{a}]&&EvenQ[Length[{a}]]&&OddQ[Count[{a},\[Gamma]@u[5]]+Count[{a},\[Gamma]@d[5]]]),
Tr[(op:dotOps)[a__]]:>0/;(allGammaQ[{a}]&&OddQ[Length[{a}]]&&EvenQ[Count[{a},\[Gamma]@u[5]]+Count[{a},\[Gamma]@d[5]]])
};
subd={
Tr[\[Gamma]@d[a_].\[Gamma]@d[b_]]:>If[MemberQ[{a},5],0,4 T[g,"dd"][a,b]],
Tr[\[Gamma]@d[a_].\[Gamma]@d[b_].\[Gamma]@d[c_]]:>0,
Tr[\[Gamma]@d[a_].\[Gamma]@d[b_].\[Gamma]@d[c_].\[Gamma]@d[d_]]:>4 (T[g,"dd"][a,b]T[g,"dd"][ c,d]-T[g,"dd"][a,c]T[g,"dd"][ b,d]+T[g,"dd"][a,d]T[g,"dd"][b,c])/;(!MemberQ[{a,b,c,d},5]),
Tr[\[Gamma]@d[a_].\[Gamma]@d[b_].\[Gamma]@d[c_].\[Gamma]@d[e_]]:>0/;MemberQ[{a},5],
Tr[\[Gamma]@d[a_].\[Gamma]@d[b_].\[Gamma]@d[c_].\[Gamma]@d[d_].\[Gamma]@d[e_]]:>-4 I T[\[Epsilon],"dddd"][b,c,d,e]/;MemberQ[{a},5]
};
subu={
Tr[\[Gamma]@u[a_].\[Gamma]@u[b_]]:>If[MemberQ[{a},5],0,4 T[g,"uu"][a,b]],
Tr[\[Gamma]@u[a_].\[Gamma]@u[b_].\[Gamma]@u[c_]]:>0,
Tr[\[Gamma]@u[a_].\[Gamma]@u[b_].\[Gamma]@u[c_].\[Gamma]@u[d_]]:>4 (T[g,"uu"][a,b]T[g,"uu"][ c,d]-T[g,"uu"][a,c]T[g,"uu"][ b,d]+T[g,"uu"][a,d]T[g,"uu"][b,c])/;(!MemberQ[{a,b,c,d},5]),
Tr[\[Gamma]@u[a_].\[Gamma]@u[b_].\[Gamma]@u[c_].\[Gamma]@u[e_]]:>0/;MemberQ[{a},5],
Tr[\[Gamma]@u[a_].\[Gamma]@u[b_].\[Gamma]@u[c_].\[Gamma]@u[d_].\[Gamma]@u[e_]]:>-4 I T[\[Epsilon],"uuuu"][b,c,d,e]/;MemberQ[{a},5]
};
tmp=exp//GammaLeft[\[Gamma]@d[5]]//GammaLeft[\[Gamma]@u[5]];
tmp//.Join[sub,subd,subu]
];
(*
RaiseTr\[Gamma]Indices[exp_Tr] raises the index of all \[Gamma]@d[] Tensors in exp_Tr using metric Tensor g@dd[].  The purpose of this Module is so we can apply simpleTrGamma. NOTE: Might want to incorporate into simpleTrGamma. *14Oct2012*)
RaiseTr\[Gamma]Indices[exp_Tr]:=Module[{tmp,glist,tmpi},
glist=Apply[List,exp];
glist=Cases[glist[[1]],T[\[Gamma],"d"][x_]];
tmp=exp//.T[\[Gamma],"d"][x_]:>T[\[Gamma],"u"][(tmpi=Unique[])]g@dd[x,tmpi];
tmp=tmp//.simpleDot2[{g@dd[_,_]}]//.simpleTr2[{g@dd[_,_]}]
];
(*Rule generator for expanding spinorBar, Overscript[u, _], expressions->u^\[Dagger].\[Gamma]0->\[Gamma]0.u .*)
spinorBarExpand[\[Psi]_]:=Module[{sub,tmpu=\[Psi]},
sub=\!\(\*OverscriptBox[\(\[Psi]\), \(_\)]\)->ConjugateTranspose[RemovePatterns[\[Psi]]].\[Gamma]@u[0];
{Map[ConjugateTranspose[#]&,sub]/.simpleHermitian[{\[Gamma]@u[_]}],sub}
];
(*
Example of how to form Rules*)
spinorBarExpandRule[spinor_List]:=Module[{tmp},
tmp=Map[spinorBarExpand[#]&,spinor]//Flatten;
Map[MapAt[(*Pattern confuses match.*)RemovePatterns[#]&,#,{2}]&,tmp]
];
(*
Templates Rules for evaluating scattering amplitutes. *14Jan2014*)
scatteringAmplitudeRules:=
{Abs[\[ScriptCapitalM][_]]^2:>SuperDagger[\[ScriptCapitalM]].\[ScriptCapitalM],
a___ \!\(\*OverscriptBox[\(u_\), \(_\)]\)[pu_].T[\[Gamma],"u"][\[Mu]_].v_[pv_]->a Conjugate[ \!\(\*OverscriptBox[\(v\), \(_\)]\)[pv].T[\[Gamma],"u"][\[Mu]].u[pu]],(*Use carefully-loops*)
ConjugateTranspose[(U:u_)[a_]].\[Gamma]@u[0]->\!\(\*OverscriptBox[\(U\), \(_\)]\)[a],(*PS.3.55*)\[Gamma]@u[0].ConjugateTranspose[\!\(\*OverscriptBox[\((U : u_)\), \(_\)]\)[a_]]->U[a],
ConjugateTranspose[\!\(\*OverscriptBox[\((U : u_)\), \(_\)]\)[a_]]. \!\(\*OverscriptBox[\(u_\), \(_\)]\)[a_]->\[Gamma]@u[0]. U[a].\!\(\*OverscriptBox[\(U\), \(_\)]\)[a],
(*Sum fermion spins *PS.5.3*)
(op:dotOps)[a___,(V:v_)[p_],\!\(\*OverscriptBox[\(v_\), \(_\)]\)[p_],b___]:>op[a,Slash[p]+Subscript[m, p[[2]]],b]/;!FreeQ[V,u],
(op:dotOps)[\!\(\*OverscriptBox[\(v_\), \(_\)]\)[p_],a___,(V:v_)[p_],b___]:>op[Slash[p]+Subscript[m, p[[2]]],a]/;!FreeQ[V,u],
(op:dotOps)[a___,(V:u_)[p_],\!\(\*OverscriptBox[\(u_\), \(_\)]\)[p_],b___]:>op[a,Slash[p]-Subscript[m, p[[2]]],b]/;!FreeQ[V,v],
(op:dotOps)[\!\(\*OverscriptBox[\(u_\), \(_\)]\)[p_],a___,(V:u_)[p_],b___]:>op[Slash[p]-Subscript[m, p[[2]]],a]/;!FreeQ[V,v],
(*Other forms of fermion spin sum*)
(op:dotOps)[a___,V:v_[p_],\!\(\*OverscriptBox[\(v_\), \(_\)]\)[p_],b___]->op[a,Slash[p]-Subscript[m, V],b],
xDot[V:\!\(\*OverscriptBox[\(u\), \(_\)]\)[p_],a__,u[p_]]->a.Slash[p]+Subscript[m, V],
HoldPattern[Dot[V:\!\(\*OverscriptBox[\(u\), \(_\)]\)[p_],a__,u[p_]]]->a.Slash[p]+Subscript[m, V],
(V:v[p_]).\!\(\*OverscriptBox[\(v\), \(_\)]\)[p_]->Slash[p]-Subscript[m, V],
(V:u[p_]).\!\(\*OverscriptBox[\(u\), \(_\)]\)[p_]->Slash[p]+Subscript[m, V],
v_[p_].\!\(\*OverscriptBox[\(v_\), \(_\)]\)[p_]->Slash[p]-Subscript[m, p],
HoldPattern[Dot[(\!\(\*OverscriptBox[\(u_\), \(_\)]\))[p_],a__,u_[p_]]]->a.(Slash[p]+Subscript[m, p]),
HoldPattern[\!\(\*OverscriptBox[\(u\), \(_\)]\)[p_].a__ .  (V:u[p_])]->a .  (Slash[p]+Subscript[m, V]),
HoldPattern[\!\(\*OverscriptBox[\(v\), \(_\)]\)[p_].a__ .  (V:v[p_])]->a .  (Slash[p]-Subscript[m, V]),
Slash[p_]:>\[Gamma]@u[i$=Unique[]]T[p,"d"][i$],
(Times|Dot)[Slash[a_],Slash[b_]]->T[a,"u"][i$=Unique[]]T[b,"d"][i$],
(*Must apply first if Slash already in expression.*)
(*Conjuation of vertex terms.*)
Conjugate[\!\(\*OverscriptBox[\(v_\), \(_\)]\)[pv_]. FN[\[Gamma]] . (u_[pu_])]->\!\(\*OverscriptBox[\(u\), \(_\)]\)[pu].FN[\[Gamma]].v[pv],
HoldPattern[Conjugate[\!\(\*OverscriptBox[\(v_\), \(_\)]\)[pv_]]. a___ . Conjugate[u_[pu_]]]:>\!\(\*OverscriptBox[\(u\), \(_\)]\)[pu].Conjugate[Dot[a]].v[pv],
HoldPattern[(op:dotOps)[Conjugate[\!\(\*OverscriptBox[\(v_\), \(_\)]\)[pv_]], a___ , Conjugate[u_[pu_]]]]:>op[\!\(\*OverscriptBox[\(u\), \(_\)]\)[pu],Conjugate[Dot[a]],v[pv]]
};


(* ::Input::Initialization:: *)
DotExpandMode[False];


(* ::Input::Initialization:: *)
tuKetCBDecompose::usage="tuKetCBDecompose[j1_,j2_,j_] return a List of Ket[j,m]\[Rule]ClebschGordan[{j1,m1},{j2,m2},{j2,m2}] Ket[j1,m1]\[CenterDot]Ket[j2,m2] over {jj,j,0,-1} where {m1,-j1,j1},{m2,-j2,j2},{m,-jj,jj}. *21Jul2018* ";
tuKetCBDecompose[j1_,j2_,j_]:=Table[Table[Ket[jj,m]->(Table[
ClebschGordan[{j1,m1},{j2,m2},{jj,m}]Ket[j1,m1]\[CenterDot]Ket[j2,m2], 
{m1,-j1,j1},{m2,-j2,j2}]//Flatten//Apply[Plus,#]&),{m,-jj,jj}],{jj,j,0,-1}]//Flatten//Expand//DeleteCases[#,_->0]&;
(*TEST
tuKetCBDecompose[1/2,1/2,1]//Column
*)
tuKetCBDecomposeInv::usage="tuKetCBDecomposeInv[j1_,j2_,j_] return an inverted List of results from tuKetCBDecompose[j1,j2,j]. *21Jul2018*";
tuKetCBDecomposeInv[j1_,j2_,j_]:=Module[{$,$s},
$=tuKetCBDecompose[j1,j2,j];
$s=$//tuExtractPattern[Ket[__]\[CenterDot]Ket[__]]//DeleteDuplicates;
$=Map[tuRuleSolve[tuRuleEliminate[DeleteCases[$s,#]][$],#]&,$s]//Flatten//Expand
];
(*TEST
tuKetCBDecomposeInv[1/2,1/2,1]//Column
*)


(* ::Input::Initialization:: *)
Clear[OPEContract]
OPEContract::usage="OPEContract[e1_,e2_] performs OPE contraction product of two NormalOrder[]d operators. BraKet indicates contraction. *30Oct2015*";
OPEContract[e1_,e2_]:=Module[{$,$1=List@@e1,$2=List@@e2},
$=Map[(BraKet@@# )NormalOrder[Complement[$1,#]]\[CenterDot]NormalOrder[Complement[$2,#]]&,Tuples[{$1,$2}]];
Apply[Plus,$]
];
tuOPEWick::usage="tuOPEWick[exp_] applies Wick's Theorem for OPE on exp_.  Only does 2 levels of nesting *30Oct2015*";
tuOPEWick[exp_]:=Module[{$=exp,$sNO},
$sNO=NormalOrder[a_List]\[CenterDot]NormalOrder[b_List]:>NormalOrder[Join[a,b]]+xOPEContract[a,b];
$=$/.$sNO;
$=$/.xOPEContract->OPEContract;xPrint[$];
$=$/.$sNO;
$=$/.xOPEContract[a__]->(1/2)OPEContract[a]/.NormalOrder[{}]->1//Expand//(#//.tuOpSimplify[CenterDot])&;
$
];
tuArXiv[num_String]:=URL["https://arxiv.org/abs/"<>num];



(* ::Input::Initialization:: *)
DateString[](*add current date to output*)



