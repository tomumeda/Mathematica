(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(*External packages*)
(*
Needs["TensorForms1V6`TensorialForms`"];
TensorialHelp;
*)
(*WARNING: Needs["TensorCalculus5`Tensorial`"]  called in TensorialForms  *)
Needs["VariationalMethods`"];
(***********************)
(*The display definitions of Tensor from TensorialForms.   *)
MakeBoxes[Tensor[A_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,Editable->False]&@@{MakeBoxes[A,form],Tensor[A]};
MakeBoxes[Tensor[A_,up_List,down_List],form:StandardForm|TraditionalForm]:=Module[{newdown=down,newup=up,makespace},makespace=If[#1===Void,Style[#2,ShowContents->False],#1]&;newup=Inner[makespace,newup,newdown,List];newdown=Inner[makespace,newdown,newup,List];(InterpretationBox[#1,#2,Editable->False,BaseStyle->{AutoMultiplicationSymbol->False}
]&)@@{SubsuperscriptBox[MakeBoxes[A,form],
RowBox[(MakeBoxes[#1,form]&)/@newdown],RowBox[(MakeBoxes[#1,form]&)/@newup]],Tensor[A,up,down]}];
(***********************)
(* This a a replacement routine that includes DerivOps, etc.  The .m version does not work for some reason.  Uses Tensorial routines. *5Sep2015*)
xArrayExpansion[indices_List,baseindices_ :Automatic][expr_]/;MatchQ[baseindices,Automatic|{(_Integer|_Symbol)..}|{{(_Integer|_Symbol)..}..}]:=Block[{idx,inindex,wbaseindices,indexstructure,wstructure,replace,uq,q,uqreplace},wbaseindices=If[VectorQ[baseindices],{baseindices},baseindices];
indexstructure=Block[{index,bases,subbases},Table[index=Part[indices,idx];
bases=GetBaseIndices[index];
subbases=If[Length[wbaseindices]>=idx,Part[wbaseindices,idx],bases];
If[\[Not](Intersection[subbases,bases]===Sort[subbases]),Message[SumArrayExpansion::subset,subbases,bases];Abort[],bases=subbases];
{index,bases},{idx,1,Length[indices]}]];
inindex[i_]:=(Count[{expr},Tensor[_,up_/;\[Not]FreeQ[up,i,1],down_]|Tensor[_,up_,down_/;\[Not]FreeQ[down,i,1]]|
Map[HoldPattern[#[_,i]]&,DerivOps],\[Infinity],Heads->True]>0\[And]\[Not]BaseIndexQ[i]);

replace[i_,newindex_]:=Switch[Head[i],_?IndexFlavorQ,Head[i][newindex],_,newindex];
uqreplace[i_]:=Switch[Head[i],_?IndexFlavorQ,Head[i][q],_,q];
wstructure=Select[indexstructure,inindex[First[#]]&];

Fold[List@@Table[(#1//tuIndexChange[{First[#2],uq=uqreplace[First[#2]]}])/.uq->replace[First[#2],Part[Last[#2],idx]],{idx,1,Length[Last[#2]]}]&,expr,Reverse[wstructure]]
];

tuArraySum::usage="tuArraySum[index_List][exp_] sums xArrayExpansion results.";
tuArraySum[index_List][exp_]:=Module[{tmp},
tmp=Fold[Apply[Plus,xArrayExpansion[{#2}][#1]]&,exp,index];
tmp
];
xArraySum[index_List][exp_]:=tuArraySum[index][exp];(*Compatibility*)

(**)
tuEinsteinSum::usage="tuEinsteinSum[baseindices_:Automatic][exp_] uses EinsteinSum[] but includes functions defined in DerivOps. baseindices_ can be Automatic[ly] defined by DeclareBaseIndices[] or explicitly, e.g. {1,2,3} or {i1,i2,i3}. *3Aug2012*";
tuEinsteinSum[baseindices_:Automatic][exp_]:=Block[{tmp=ExpandAll[exp],xtmp,sub,OPS=DerivOps},
tmp=tmp//EinsteinSum[baseindices];
tmp=tmp/.a__ (OP:DerivOps)[d_,$e_]:>xArraySum[{$e}][a OP[d,$e]]/; MemberQ[ExtractDummyIndices[a OP[d,$e]],$e];
tmp
];
xEinsteinSum[baseindices_:Automatic][exo_]:=tuEinsteinSum[baseindices][exp];

(*
SumTermsWithTU[index_List][exp_] applies Sum to Times terms in exp_  where index_List is form of the Sum[_,arg] arg.   Intended to extend EinsteinSum. Does not observe UpDown convention.  Returns xSum to allow checking of expression. *5Mar2014*)
SumTermsWithTU[index_List][exp_]:=Module[{tmp=exp,iterm,noiterm,$i,
(*associative operators that this can be applied on *)
ops=Times|Dot|xDot
},
Do[
tmp=tmp//Expand;
tmp=tmp/.op:ops->OP[op];
xPrint[$i,index[[$i]]];
xPrint[tmp];
tmp=tmp/.OP[op:_][a__]:>iterm[Apply[op,Select[{a},!FreeQ[#,index[[$i,1]]]&  ]]]noiterm[Apply[op,Select[{a},FreeQ[#,index[[$i,1]] ]&]]];
tmp=tmp/.iterm[a_]:>iterm[xSum[a,index[[$i]]]]/;!FreeQ[a,index[[$i,1]]];
tmp=tmp/.iterm[a_]->a/.noiterm[a_]->a/.OP[op_][a__]:>op[a];
xPrint[tmp],
{$i,Length[index]}
];
tmp
];

(******)
(*Past definitions*)
DeclareZeroTensor[zero];
TensorLabelFormat[zero,0];

<<Local`LocalFunctions`
<<Local`CommonPR2`
<<Local`Utilities2`
tuSaveFile;

DotFunctions(*
IntegralFunctions already included*)(*
IntegrateSumFunctions*)
(*Some mathematical relationships are different in Peskin-Schroeder, e.g., Civita Tensor index sums.  Setting this to 1 use the Peskin-Schroeder relationship. *)
PeskinSchroederMode=1;
(*Area for specific assignments of variables for all problems.*)
Indices4D={0,1,2,3};
DeclareIndexFlavor[{field,Green}]
DeclareIndexFlavor[{space,Red}]
DeclareIndexFlavor[{timespace,Magenta}]
DeclareIndexFlavor[{feyn,Orange}]
DeclareIndexFlavor[{groupR,Blue}]

SetAttributes[timespace,{Flat,OneIdentity,Listable}];(*eliminates double calls*)

DeclareBaseIndices[Indices4D,{field,{1,2,3,4}},{feyn,{1,2,3,4,5}},{space,{1,2,3}},{timespace,{0,1}},{groupR,{1,2,3}}];
CompleteBaseIndices
Clear[QCDBaseIndices]
QCDBaseIndices:=Module[{},
DeclareIndexFlavor[{color,Brown}];
DeclareIndexFlavor[{flavor,Orange}];
DeclareIndexFlavor[{family,Darker[Green]}];
AddBaseIndex[{gaugeG,{1,2,3,4,5,6,7,8}}];(*SU[3] gauge group index*)
AddBaseIndex[{color,{1,2,3}}];(*SU[3] singlet index*)
AddBaseIndex[{flavor,{1,2,3,4,5,6}}];
(*correspondence: {{u,c,t, with Q=2/3},{d,s,b, with Q=-1/3}}*)
AddBaseIndex[{family,{1,2,3}}];
CompleteBaseIndices
];

DefineTensor[
\[CurlyPhi],\[Psi],m,k,x,y,z,dx,\[Xi],b,c,r,\[Phi],\[Psi]c,J,K,P,a,k,l,e,p,q,dp,dq,j,A,B,\[Gamma],G,n,\[Sigma],h,\[Chi],\[Theta],\[Zeta],x,k,g,\[Delta] ,\[Sigma],\[Omega],\[Omega]1,\[Omega]2,\[Omega]s,\[Omega]a,\[Eta],\[CapitalLambda],A,B,M,\[Delta]\[Omega],\[Delta]\[Alpha],q,p,R,T,S,F,W,J,\[CapitalGamma],f,W,J,\[Epsilon]
];

labels = {x,\[Delta],g, \[CapitalGamma]};
SetTensorValues[\[Eta]@uu[i,j],DiagonalMatrix[{1,-1,-1,-1}]]
SetTensorValues[\[Eta]@dd[i,j],DiagonalMatrix[{1,-1,-1,-1}]]
Tr\[Eta]=Tr[DiagonalMatrix[{1,-1,-1,-1}]]
SetTensorValues[\[Eta]@dd[timespace@i,timespace@j],DiagonalMatrix[{1,-1}]]
SetTensorValues[\[Eta]@uu[timespace@i,timespace@j],DiagonalMatrix[{1,-1}]]
SetTensorValues[\[Delta]@ud[i,j],IdentityMatrix[4]]

(* Add index pattern for xPartialD. *)
indexspecs1={
{1,{2},xPartialD[_,index_/;Head[index]=!=List]},
{2,{2,_},xPartialD[_,index_List]},
{1,{2},xCovariantD[_,index_/;Head[index]=!=List]},
{2,{2,_},xCovariantD[_,index_List]},
{1,{2},xD[_][_,index_/;Head[index]=!=List]},
{2,{2,_},xD[_][_,index_List]}
};
indexspecs2={
{1,{2},xPartialDu[_,index_/;Head[index]=!=List]},
{2,{2,_},xPartialDu[_,index_List]},
{1,{2},xCovariantDu[_,index_/;Head[index]=!=List]},
{2,{2,_},xCovariantDu[_,index_List]},
{1,{2},xDu[_][_,index_/;Head[index]=!=List]},
{2,{2,_},xDu[_][_,index_List]}
};

NewIndexChangePatterns=Join[indexspecs1,indexspecs2];
NewIndexChangePatterns;

IndexParsingRules:={
\!\(\*OverscriptBox[\($$ten_Tensor\), \(_\)]\)->$$ten,
DerivOpsU[DerivOpsD[$$a_,$$m_],$$n_]->$$a Tensor[$$XXX,{$$n},{$$m}],
DerivOpsD[DerivOpsU[$$a_,$$m_],$$n_]->$$a Tensor[$$XXX,{$$m},{$$n}],

DerivOpsD[$$a_,$$m_]->$$a Tensor[$$XXX,{Void},{$$m}],
DerivOpsU[$$a_,$$m_]->$$a Tensor[$$XXX,{$$m},{Void}],
HoldPattern[Derivative][a__][Tensor[$$b_,$$c_,$$d_]]:>Tensor[$$b,$$c,$$d],
ExteriorD[$$a_]->$$a
};

(*Functional patterns that may use indices*)
IndexVarPatterns=Tensor[a_,u_List,d_List]|xPartialD[a_,d_]|xPartialDu[a_,u_]|xCovariantD[a_,d_]|xCovariantDu[a_,u_]|xD[b_][a_,d_]|xDu[b_][a_,u_];
(*Notation in QFT has too many requirements and often needs to be problem specific.
*)

(*Keep the Length of the _D _U variables the same! *)
tuDerivOpsD:=tuDPartial|tuDCovariant|tuDs[_]|tuDDown[_];
tuDerivOpsU:=tuDPartialu|tuDCovariantu|tuDsu[_]|tuDUp[_];
tuDerivOps:=tuDerivOpsD|tuDerivOpsU|tuDLie//Flatten;

DerivOpsD:=Join[xPartialD|xCovariantD|xD[_],tuDerivOpsD];
DerivOpsU:=Join[xPartialDu|xCovariantDu|xDu[_],tuDerivOpsU];
DerivOps:=DerivOpsD|DerivOpsU|tuDerivOps//Flatten;(*Compatibility*)

(*
Slashes symbol_*)
MakeBoxes[slash[symbol_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{RowBox[{ToBoxes["/"],AdjustmentBox[ToBoxes[symbol],BoxMargins->{{-.6,0},{.0,0}}]}],slash[symbol]};
Slash:=slash;
(*
PartialDSlash[symbol_] notation. *)
MakeBoxes[PartialDSlash[symbol_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{RowBox[{ToBoxes["/"],AdjustmentBox["\[PartialD]",BoxMargins->{{-0.8,0.0},{0.,0.}}],ToBoxes[symbol]}], PartialDSlash[symbol]};
(*
CovariantDSlash[symbol_] notation. *)
MakeBoxes[CovariantDSlash[symbol_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{RowBox[{ToBoxes["\[ScriptCapitalD]"],AdjustmentBox["/",BoxMargins->{{-0.6666666666666666,-0.6666},{0.,0.}}],"[",ToBoxes[symbol],"]"}], CovariantDSlash[symbol]};
(*
GammaSlash display definition.  May want to redefine it as g[a_]:=GammaSlash[a].  Perhaps the Bold is enough.*)
MakeBoxes[GammaSlash[a_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@
    {ToBoxes[Overscript[Style[a,Bold],"/"]], GammaSlash[a]};

(*
xIntegral and xCIntegral: 
Intermediate form of tuIntegral and tuCIntegral to have arguements consistent with standard Mathematica arguement lists. *)
xIntegral[a_,b__]:=Inactive[Integrate][a,Sequence[b]]

MakeBoxes[xCIntegral[a_,v__],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Subscript["\[ContourIntegral]",Column[{v}]][a]], xCIntegral[a,v]};

(*
tuIntegral display definition. *)
tuIntegral::usage="tuIntegral[vars_List,integrand_] Integral operator with list of variables vars_ \[Rule] {{v1},{v2}} and integrand_. ";
MakeBoxes[tuIntegral[v_,a_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Subscript["\[Integral]",Column[v]][a]], tuIntegral[v,a]};
IntegralOp:=tuIntegral;

(*
tuCIntegral display definition.  Syntax tuCIntegral[{{v1,a1,b1},{v2,a2,b3}},integrand]*)
MakeBoxes[tuCIntegral[v_,a_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Subscript["\[ContourIntegral]",Column[v]][a]], tuCIntegral[v,a]};
CIntegralOp[v_,a_]:=tuCIntegral[v,a];
(*
Transpose display definition.*)
MakeBoxes[Transpose[a_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Superscript[a,T]], Transpose[a]};
(*
ConjugateTranspose display definition.*)
MakeBoxes[ConjugateTranspose[a_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[SuperDagger[a]], ConjugateTranspose[a]};
(*
Conjugate display definition.*)
MakeBoxes[Conjugate[a_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[SuperStar[a]], Conjugate[a]};
(*
xPartialD display definition.*)
tuPartialD::usage="tuPartialD[field_,var_] displays the PartialD[field,var] \[Rule] \!\(\*SubscriptBox[\(\[PartialD]\), \(var\)]\)field. ";
MakeBoxes[tuPartialD[a_,b_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Subscript[
\!\(\*UnderscriptBox[\("\<\[PartialD]\>"\), \(_\)]\),b][a]], tuPartialD[a,b]};
xPartialD[field_,var_]:=tuPartialD[field,var];
tuPartialD:=tuDPartial; (*Transitional*)
tuPartialDu:=tuDPartialu; (*Transitional*)
(*
xPartialDu (contravariant derivative) display definition.*)
tuPartialDu::usage="tuPartialDu[field_,var_] displays the PartialDu[field,var] \[Rule] \!\(\*SuperscriptBox[\(\[PartialD]\), \(var\)]\)field. ";
MakeBoxes[tuPartialDu[a_,b_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Superscript[
\!\(\*UnderscriptBox[\("\<\[PartialD]\>"\), \(_\)]\),b][a]], tuPartialDu[a,b]};
xPartialDu[field_,var_]:=tuPartialDu[field,var];
(*
xCovariantD (contravariant covariant derivative) display definition.*)
MakeBoxes[xCovariantD[a_,b_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Subscript[
\!\(\*UnderscriptBox[\("\<\[GothicCapitalD]\>"\), \(_\)]\),b][a]], xCovariantD[a,b]};
(*
xCovariantDu (contravariant covariant derivative) display definition.*)
MakeBoxes[xCovariantDu[a_,b_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Superscript[
\!\(\*UnderscriptBox[\("\<\[GothicCapitalD]\>"\), \(_\)]\),b][a]], xCovariantDu[a,b]}
(*
xLieD (Lie derivative) display definition.*)
MakeBoxes[xLieD[a_,b_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Subscript[
\!\(\*UnderscriptBox[\("\<\[ScriptCapitalL]\>"\), \(_\)]\),b][a]], xLieD[a,b]};
(*
deltaD display definition.*)
MakeBoxes[deltaD[a_,b_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Subscript[
\!\(\*UnderscriptBox[\("\<\[Delta]\>"\), \(_\)]\),b][a]], deltaD[a,b]};
(*
xDeltaD display definition.*)
MakeBoxes[xDeltaD[a_,b_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Subscript[
\!\(\*UnderscriptBox[\("\<\[Del]\>"\), \(_\)]\),b][a]], xDeltaD[a,b]};
(*
xDeltaD display definition for specified symbol s_.*)
MakeBoxes[xDeltaD[s_,a_,b_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Subscript[
\!\(\*UnderscriptBox[\(s\), \(_\)]\),b][a]], xDeltaD[s,a,b]};
(*
xD display definition specified symbol s_.*)
MakeBoxes[xD[s_][a_,b_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Subscript[
\!\(\*UnderscriptBox[\(s\), \(_\)]\),b][a]], xD[s][a,b]};
(*
xDu display definition specified symbol s_.*)
MakeBoxes[xDu[s_][a_,b_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Superscript[
\!\(\*UnderscriptBox[\(s\), \(_\)]\),b][a]], xDu[s][a,b]};
(*
xDDeltaD display definition.*)
MakeBoxes[xDDeltaD[a_,b_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Subscript[
\!\(\*UnderscriptBox[\("\<D\>"\), \(_\)]\),b][a]], xDDeltaD[a,b]};
(*
xDiscreteDelta display definition.*)
MakeBoxes[xDiscreteDelta[a_,b_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[
\!\(\*UnderscriptBox[\("\<\[Delta]\>"\), \(_\)]\)[a,b]], xDiscreteDelta[a,b]}
(*
xSum display definition.*)
MakeBoxes[xSum[a_,b__],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Underscript[
\!\(\*UnderscriptBox[\(\(\ \)\("\<\[Sum]\>"\)\), \(_\)]\),Column[{b}]][a]], xSum[a,b]};
(*
xProduct display definition. *)
MakeBoxes[xProduct[a_,b__],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Underscript[
\!\(\*UnderscriptBox[\(\(\ \)\("\<\[Product]\>"\)\), \(_\)]\),Column[{b}]][a]], xProduct[a,b]};
(*
Bra display definition.*)
MakeBoxes[Bra[b__],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{RowBox[{StyleBox["\[LeftAngleBracket]",Bold],ToBoxes[b],StyleBox["\[RightBracketingBar]",Bold]}], Bra[b]};
(*
Ket display definition.*)
MakeBoxes[Ket[b__],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{RowBox[{StyleBox["\[LeftBracketingBar]",Bold],ToBoxes[b],StyleBox["\[RightAngleBracket]",Bold]}], Ket[b]};
(*
BraKet[b] display definition, <b>  *)
MakeBoxes[BraKet[b__],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{RowBox[{StyleBox["\[LeftAngleBracket]",Bold],ToBoxes[b],StyleBox["\[RightAngleBracket]",Bold]}], BraKet[b]};
(*
BraKet[b,c] display definition, <b|c> *)
MakeBoxes[BraKet[b__,c__],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{RowBox[{StyleBox["\[LeftAngleBracket]",Bold],ToBoxes[b],StyleBox["|",Bold],ToBoxes[c],StyleBox["\[RightAngleBracket]",Bold]}], BraKet[b,c]};

(*
BraKet[a,b,c] display definition, <a|b|c> *)
MakeBoxes[BraKet[a__,b__,c__],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{RowBox[{StyleBox["\[LeftAngleBracket]",Bold],ToBoxes[a],StyleBox["|",Bold],ToBoxes[b],StyleBox["|",Bold],ToBoxes[c],StyleBox["\[RightAngleBracket]",Bold]}], BraKet[a,b,c]};
(*
CommutatorM display definition. *)
MakeBoxes[CommutatorM[a_,b__],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{SubscriptBox[RowBox[{"[",ToBoxes[a],",",ToBoxes[b],"]"}],"-"], CommutatorM[a,b]};
(*
CommutatorP display definition.*)
MakeBoxes[CommutatorP[a_,b__],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{SubscriptBox[RowBox[{"{",ToBoxes[a],",",ToBoxes[b],"}"}],"+"], CommutatorP[a,b]};
(*
HodgeStar display definition*)
MakeBoxes[HodgeStar[a_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[
\!\(\*UnderscriptBox[\("\<*\>"\), \(_\)]\)[a]], HodgeStar[a]};
(*
DifForm display definition 11July2012*)
MakeBoxes[difForm[a_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[
\!\(\*UnderscriptBox[\(d\), \(_\)]\)[a]], difForm[a]};
DifForm:=difForm (*Compatibility*)
(*****************************************************
Indexed derivative Box definitions *migration TARGET *6Feb2015*)
MakeBoxes[tuDDown[s_][a_,b_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Subscript[
\!\(\*UnderscriptBox[\(s\), \(_\)]\),b][a]], tuDDown[s][a,b]};MakeBoxes[tuDUp[s_][a_,b_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Superscript[
\!\(\*UnderscriptBox[\(s\), \(_\)]\),b][a]], tuDUp[s][a,b]};
(******************************************************)
tuDPartial[a_,b_]:=tuDDown["\[PartialD]"][a,b];
tuDPartialu[a_,b_]:=tuDUp["\[PartialD]"][a,b];
tuDCovariant[a_,b_]:=tuDDown["\[Del]"][a,b];
tuDCovariantu[a_,b_]:=tuDUp["\[Del]"][a,b];
tuDs[s_][a_,b_]:=tuDDown[s][a,b];
tuDsu[s_][a_,b_]:=tuDUp[s][a,b];
tuDLie[a_,b_]:=tuDDown["\[ScriptCapitalL]"][a,b];
tuDOps:=tuDUp[_]|tuDDown[_];

tuDExpand::usage="tuDExpand[ops_,constants_List] Rules to Expand by name ops_ operator, e.g., tuDUp[_]|tuDDown[_], tuDPartial, tuDPartialu, tuDCovariant, tuDCovariantu. Terms that match any of list of constants are treated as constant. *2Mar2015*";
tuDExpand[ops_,constants_List:{}]:={
(name:ops)[(oo:Flatten[dotOps|Times])[a_  ,b__],c__]:>oo[name[a,c],b]+oo[a ,name[oo[b],c]]/;Length[{b}]>1,
(name:ops)[(oo:Flatten[dotOps|Times])[a_  ,b__],c__]:>oo[name[a,c],b]+oo[a ,name[b,c]]/;Length[{b}]==1,
(name:ops)[a_+ c_,b_]->name[a,b]+ name[ c,b],
(name:ops)[Exp[a_],b_]->Exp[a] name[a,b],
(name:ops)[Log[a_],b_]-> name[a,b]/a,
(name:ops)[Power[a_,n_],b_]:>n Power[a,n-1] name[a,b],
(name:ops)[a_,b_]:>0/;NumericQ[a] ,
(name:ops)[a_,a_]:>1,
(name:ops)[a_,b_]:>0/;ListMemberQ[a,constants],
(name:ops)[Conjugate[a_],b_]:>Conjugate[name[a,b]]/;!MemberQ[{"\[Del]"},name],
(name:ops)[ConjugateTranspose[a_],b_]:>ConjugateTranspose[name[a,b]]/;!MemberQ[{"\[Del]"},name],
(name:ops)[Transpose[a_],b_]:>Transpose[name[a,b]],
(name:ops)[a__,\[Mu]_]:>Thread[name[a,\[Mu]]]/;Head[a]==List,
(name:ops)[a_,\[Mu]_]:>Apply[Rule,Thread[name[Apply[List,a],\[Mu]]]]/;Head[a]===Rule,
(name:ops)[(ss:xSum|Sum)[a_,b__],\[Mu]_]:>ss[name[a,\[Mu]],b]
(*,
(name:ops)[a_,b_]\[RuleDelayed]name[a,tuScalarDelete[constants][b]]/Apply[Times,tuScalarSelect[constants][b]]/;({tuScalarDelete[constants][b]}=!={})||(!AtomQ[b])*)
(*Intended to do: \!\(
\*SubscriptBox[\(\[PartialD]\), \(2 x\)]A\)\[Rule](\!\(
\*SubscriptBox[\(\[PartialD]\), \(x\)]A\))/2 but CREATES Rule[] PROBLEMS with some expressions. Avoid cases where b is an integer index.*)
(*multiplicative simplification*)
};
DifExpand[ops_,constants_List]:=tuDExpand[ops,constants];
(**)
tuDExpandMultiVar::usage="tuDExpandMultiVar is Rule[] for separating multiple differential symbol into a nest of single differtials: tuDOps[a,{b,c}]->tuDOps[tuDOps[a,b],c] *15Aug2015*";
tuDExpandMultiVar:={(head:DerivOps)[a_,b_List]:>head[head[a,First[b]],If[Length[Rest[b]]>1,Rest[b],Rest[b][[1]]]]
};
(**)
tuDerivativeExpand::usage="tuDerivativeExpand[constants_List:{}][exp_] expands DerivOps in exp_ by applying tuDExpandMultiVar and tuDExpand.  *15Aug2015*";
tuDerivativeExpand[constants_List:{}][exp_]:=
Block[{tmp=exp,ops=DerivOps,test=NULL},
tmp=tmp//.tuDExpandMultiVar;(*Expansion for multiple tuOOps *)
While[test=!=tmp,
test=tmp;
tmp=Expand[tmp];
tmp=tmp//.tuDExpand[ops,constants];
Continue[](*May not need to iterate.*)
];
tmp
];

(*******************************************)
Clear[tuScalarSelect]
tuScalarSelect::usage="tuScalarSelect[scalars_List:{}][exp_] returns a List of NumericQ[] and scalars_ in exp_. *12Nov2015*";
tuScalarSelect[scalars_List:{}][exp_]:=Block[{$=exp,$pos},
$pos=$//tuExtractPositionPattern[{_?NumericQ,scalars}];
$=Map[#[[2]]&,$pos]
];
(**)
Clear[tuScalarDelete]
tuScalarDelete::usage="tuScalarDelete[scalars_List:{}][exp_] returns exp_ with NumericQ[] and scalars_ in removed. *12Nov2015*";
tuScalarDelete[scalars_List:{}][exp_]:=Block[{$=exp,$pos},
$pos=$//tuExtractPositionPattern[{_?NumericQ,scalars}];
$pos=Map[#[[1]]&,$pos];
$=Delete[$,$pos];
$
];

(* 
Commutation and Anti-commutation definitions.*)
tuCommutator::usage = "tuCommutator[op_:Dot,sign_:-1][A_,B_] expands the commutator of matrices A and B using op_ as multiplicative operator. *17Feb2016*";
tuCommutator[op_:Dot,sign_:-1][A_,B_]:=op[A,B]+sign op[B,A]
MCommutator[A_,B_]:=tuCommutator[Dot][A,B]; (*Compatibility*)
ACommutator[A_,B_]:=tuCommutator[Dot,1][A,B];(*Compatibility*)



(*Extract Sum's from Dot expressions and simplifies Sum LowerIndexTUexpression.*)DotSum2SumDot[exp_]:=Module[{tmp=exp,DEBUG=0,mname="DotSum2SumDot"},
tmp=tmp//.Sum->xSum;
IfDEBUG[mname,DEBUG>0,{tmp},"{tmp1}"];
tmp=tmp//.Dot[a___,xSum[b_,nb__],c___]->xSum[Dot[a,b,c],nb];
IfDEBUG[mname,DEBUG>0,{tmp},"{tmp2}"];
tmp=tmp//.subGatherSum;
tmp=tmp(*//.xSum->Sum*)
];

(*Rules to simplify Scalars in Transpose[] and ConjugateTranspose[] expressions.
Usage: expression//.simpleTranspose[scalar_List]  *)
simpleTranspose[scalar_List]:={Transpose[a_ b_]:>a Transpose[b]/;(ListMemberQ[a,scalar]||NumericQ[a]),
Transpose[Power[a_,n_] b_]:>Power[a,n] Transpose[b]/;(ListMemberQ[a,scalar]||NumericQ[a]),
Transpose[a_ ]:>a /;ListMemberQ[a,scalar]||NumericQ[a],
Transpose[Power[c_,x_]]:>Power[c,x]/;ListMemberQ[c,scalar],
ConjugateTranspose[Power[a_,b_] ]:>Conjugate[Power[a,b]] /;ListMemberQ[a,scalar],
ConjugateTranspose[a_ ]:>Conjugate[a] /;ListMemberQ[a,scalar],
Transpose[xPartialD[c_,x_]]:>xPartialD[c,x]/;ListMemberQ[c,scalar],
Transpose[xPartialDu[c_,x_]]:>xPartialDu[c,x]/;ListMemberQ[c,scalar],
ConjugateTranspose[xPartialD[c_,x_]]:>Conjugate[xPartialD[c,x]]/;ListMemberQ[c,scalar],
ConjugateTranspose[xPartialDu[c_,x_]]:>Conjugate[xPartialDu[c,x]]/;ListMemberQ[c,scalar]
};

(*TransposeMatrix applies Transpose to elements of matrix_ (level 2) where elements may be symbolic elements. *)
(*NOT USED?
TransposeMatrix[matrix_List]:=Module[{tmp=matrix,pos=Position[matrix,_,2]},
pos=Select[pos,Length[#]==2&&!MemberQ[#,0]& ];
MapAt[Transpose[#]&,matrix,pos]
];*)

(*
dotOps Attributes *)
SetAttributes[xDot,{Flat}];
Attributes[CenterDot]={Flat,OneIdentity};
Attributes[xDot]={Flat,OneIdentity};
(*Rule for expanding Dot of Sums*)(*
DotExpand={Dot[a___,b_+c_,d___]->Dot[a,b,d]+Dot[a,c,d],
xDot[a___,b_+c_,d___]->xDot[a,b,d]+xDot[a,c,d]};*)
DotExpandAll[exp_]:=Module[{tmp=exp},
tmp=tmp//ExpandAll;
tmp=tmp//.DotExpand
];
DotExpandAll2[scalar_List][exp_]:=Module[{tmp=exp,tmp1},
While[tmp=!=tmp1,
tmp1=tmp;
tmp=tmp//ExpandAll;
tmp=tmp//.DotExpand;
tmp=tmp//.simpleDot2[scalar]
];
tmp
];

(*
Rules to simplify Dot|xDot expressions. *10Sep2012*)
(*Possible Dot operators*)
dotOps:=Dot|xDot|CenterDot|Inactive[Dot]
(*
dotTimesTerms[with_List][exp_] replaces terms in Times expression in exp_ with with_ symbols in Dot'ed expression *2Oct2014*)
dotTimesTerms[with_List][exp_]:=Block[{tmp=exp,$with,$without},
tmp=exp/.Times->xTimes;
tmp=tmp/.xTimes[a__]:>xTimes[$with[Select[{a},!ListFreeQ[#,with]&]]$without[Select[{a},ListFreeQ[#,with]&]]];
tmp=tmp/.{$with[{}]->1,$without[{}]->1};
tmp=tmp/.$with[{a__}]->Inactive[Dot][a]/.$without[{a__}]->Times[a]/.xTimes->Times//Activate
];

(**)
tuOpSwitch::usage="tuOpSwitch[op1_,op2_] Rule[] to switch order of op1_ and op2. Primarily for operators: Sum, Integrate, i.e., operators with operand as first arguement. *1Nov2015*";
tuOpSwitch[op1_,op2_]:=op1[op2[a_,b___],c___]->op2[op1[a,c],b]

tuOpNestGather::usage="tuOpNestGather[op_,product_:Times][exp_] gathers nested operators op_ into an expression with one op_. Product operator product_ may be specified.,  e.g., xSum[aa[i]\[CenterDot]xSum[bb[k],{k,3},{m,4}],{i,2},{j,3}]//tuOpNestGather[xSum,CenterDot] \[LongRightArrow] xSum[aa[i]\[CenterDot]bb[k],{k,3},{m,4},{i,2},{j,3}]. WARNING: Does not work with Sum, Switch to Inactive[Sum]. *19Oct2015*";
(*tuOpNestGather[op_,product_:Times][exp_]:=Block[{$=exp,$0},
While[$0=!=$,
$0=$;
$=$//.op[ op[b_,c___],d___]\[Rule]op[b,c,d];
$=$//.op[a_,b___]+op[c_,b___]\[Rule]op[a+c,b];
$=$//.(pp:product)[op[a_,d___]  ,op[b_,c___]]\[Rule]op[pp[a, b],c,d];
$=$//.(pp:product)[a_,op[b_,c___]]\[Rule]op[pp[a,b],c];
$=$//.(pp:product)[op[b_,c___],a_]\[Rule]op[pp[b,a],c];
$=$//.op[(pp:product)[a_ , op[b_,c___]],d___]\[Rule]op[pp[a, b],c,d];
];
$
];*)
tuOpNestGather[op_,product_:Times][exp_]:=Block[{$=exp,$0,iproduct=Inactive[product]},
$=$/.product->iproduct;
While[$0=!=$,
$0=$;xPrint[{$0,iproduct}];
$=$/.op[(pp:iproduct)[a___, op[b__,c___],d___]]:>op[pp[a, b,c,d]];
$=$//.(pp:iproduct)[a___,op[b_,c___],d___]->op[pp[a,b,d],c];
$=$//.op[a_,b___]+op[c_,b___]->op[a+c,b];
$=$//.(pp:iproduct)[op[a_,d___]  ,op[b_,c___]]->op[pp[a, b],c,d];
];
Activate[$,product]
];

tuOpDistribute::usage="tuOpDistribute[op_,over_:Plus] Rule for distributing op_ over over_. EG.
a.(b-c).d/.tuOpDistribute[dotOps]->a.b.d+a.(-c).d. *21May2015*";(*
tuOpDistribute[op_,over_:Plus]:=(oo:op)[a___,over[b_,c_],d___]\[Rule]over[oo[a,b,d],oo[a,c,d]];
*)
tuOpDistribute[op_,over_:Plus]:=oo:(op/.Dot->dotOps)[over[a__]]:>Distribute[ExpandAll[oo],over];
DotExpand:=tuOpDistribute[dotOps];(*Compatibility*)
(**)
tuOpDistributeF::usage="tuOpDistributeF[op_,over_:Plus] Rule for distributing op_ over over_.  operator_ may be somewhat complex in that operators like CommutatorM[arg__\!\(\*SubscriptBox[\(]\), \(\[Rho]\)]\) may be specified.  arg__ is needed to specify position of the arguement. EG.
a.(b-c).d//tuOpDistributeF[dotOps]->a.b.d+a.(-c).d. *10Feb2016*"
tuOpDistributeF[operator_,over_:Plus][exp_]:=Block[{func,tmp,oper,$ss,arg},
If[Head[operator]===Symbol,
tmp=exp//.tuOpDistribute[operator,over],
(*attempt to handle generalize functions e.g. Subscript[[a,b], R]  *)
$ss=func[arg]->tuPatternRemove[operator]//tuAddPatternVariable[arg,BlankSequence];xPrint[$s];
tmp=exp/.operator->func[arg];xPrint[{4,operator,tmp}];
tmp=tmp//.tuOpDistribute[func,over];
tmp=tmp/.$ss
];
tmp
];
(****)
tuOpSimplify::usage="tuOpSimplify[operator_,scalars_List:{}] Rule for simplifying operator[] expressions by removing NumericQ and scalars_ from its arguements. NOTE: Some of these Rule[]s do not seem active for some expressions. BUG: Does not catch some scalars_. *26Sep2015*";
tuOpSimplify[operator_,scalars_List:{}]:=Flatten[{
(op:operator)[a___,(cc:c_^(n_:1))  d___,e___]:>cc op[a,d,e]/;NumericQ[c]||tuMemberQ[c,scalars],(op:operator)[a___,(cc:c_^(n_:1))  ,d___]:>cc op[a,d]/;NumericQ[c]||tuMemberQ[c,scalars],
Conjugate[(op:operator)[a__]]:>Apply[op,Thread[Conjugate[{a}]]],
(op:operator)[a_]->a,
(op:operator)[]->1
}];
(**)
tuOpSimplifyF::usage="tuOpSimplifyF[operator_,scalars_List:{}] [exp_] simplifies operator[] expressions by removing NumericQ and scalars_ from its arguements. operator_ may be somewhat complex in that operators like CommutatorM[arg__\!\(\*SubscriptBox[\(]\), \(\[Rho]\)]\) may be specified.  arg__ is needed to specify position of the arguement. NOTE: Applies tuOpSimplify Rule[]s above. *10Feb2016*";
tuOpSimplifyF[operator_,scalars_List:{}][exp_]:=Block[{func,tmp,oper,$ss,arg},
If[Head[operator]===Symbol,
tmp=exp//.tuOpSimplify[operator,scalars],
(*attempt to handle generalize functions e.g. Subscript[[a,b], R]  *)
$ss=func[arg]->tuPatternRemove[operator]//tuAddPatternVariable[arg,BlankSequence];xPrint[$s];
tmp=exp/.operator->func[arg];xPrint[{4,operator,tmp}];
tmp=tmp//.tuOpSimplify[func,scalars];
tmp=tmp/.$ss
];
tmp
];
(**)
Clear[tuOpSimplifyFirst]
tuOpSimplifyFirst::usage="tuOpSimplifyFirst[operator_,scalars_List:{}][exp_] applies tuOpSimplify[] to the First arguement of operator_s in exp_ accounting for scalars_ which are moved out of the arguement list. Only Times[] terms as first arguements are assumed. *23Oct2015*";
tuOpSimplifyFirst[operator_,scalars_List:{}][exp_]:=Block[{$=exp,xTimes,xUNIT},
$=$/.(op:operator)[a_ ,b___]:>op[(AppendTo[xTimes@@a,xUNIT]//.tuOpSimplify[xTimes,scalars]),b];xPrint["X: ",$];
$=$/.(op:operator)[(aa_:1)   xTimes[c1___],b___]->aa op[(Hold[Times][c1]),b]//ReleaseHold;
$=$/.xUNIT->1
];

(*
Rules for simplifying dotOps with NumericQ and Conjugates *10Sep2012*)
simpleDot:={
(op:dotOps)[a___,n_ d_,c___]:>n op[a,d,c]/;NumericQ[n],
(op:dotOps)[a___,b_,c___]:>b op[a,c]/;NumericQ[b]&&Length[{a,c}]>0,
(op:dotOps)[a___,b_,c___]:>b /;NumericQ[b]&&Length[{a,c}]===0,
(op:dotOps)[a___,-b_,c___]->- op[a,b,c],
Conjugate[(op:dotOps)[a__]]:>Apply[op,Thread[Conjugate[{a}]]]
};
(*
simpleDot1a[scalars_List][exp_] applies Rules for simplifying Dot|xDot expressions in exp_ accounting for scalars_List.  Conjugate and Transpose of scalars_List are considered scalars.  (Replaces simpleDot1, but has name conflict with it.)*10Sep2012*)
simpleDot1a[scalars_List][exp_]:=Module[{tmp=exp,sub,scal=Join[Conjugate[scalars],scalars]},
sub={
DotExpand,
simpleDot,
(op:dotOps)[a___,d___ c_,b___]:>c  op[a,d,b]/;ListMemberQ[c,scal],
(op:dotOps)[a___,c_,b___]:>c op[a,b]/;ListMemberQ[c,scal],
(op:dotOps)[a___,d___ c_^n_,b___]:>c^n op[a,d,b]/;(ListMemberQ[c,scalars]||ListMemberQ[c,scal]),
(op:dotOps)[a___,c_^n_,b___]:>c^n op[a,b]/;ListMemberQ[c,scal],
simpleTranspose[scalars]
}//Flatten;
tmp//.sub
];

(*
Rules to simplify Dot expressions with extention to simpleDot to account for scalars_.  Usage: expression//.simpleDot1[scalars_List] *)
simpleDot1[scalars_List]:={
(op:dotOps)[a___,d___ c_,b___]:>c op[a,d,b]/;ListMemberQ[c,scalars],
(op:dotOps)[a___,d___ c_^n_,b___]:>c^n op[a,d,b]/;ListMemberQ[c,scalars],
(op:dotOps)[a___,c_,b___]:>c op[a,b]/;ListMemberQ[c,scalars]&&(Length[{a}]>0||Length[{b}]>0),
(op:dotOps)[a___,c_^n_,b___]:>c^n op[a,b]/;ListMemberQ[c,scalars]&&(Length[{a}]>0||Length[{b}]>0),
simpleTranspose[scalars],
simpleDot}//Flatten;

(*Rules to simplify Dot expressions with extention to simpleDot to account for scalars_.  Include DotExpand.
Usage: expression//.simpleDot2[scalars_List].  NOTE: DotExpand works for only simple sums. *)
simpleDot2[scalars_List]:={
DotExpand,
simpleDot1[scalars]
}//Flatten;

(**)
tuDotSimplify::usage="tuDotSimplify[scalars_List][exp_] expands and simplifies Dot|xDot expressions in exp_ accounting for scalar_List. *20Feb2015*";
tuDotSimplify[scalars_List:{}][exp_]:=Block[{tmp=exp,tmp1},
While[tmp=!=tmp1,
tmp1=tmp;
tmp=tmp//DotExpandAll;(*CAREFUL of nested Dot[]s*)
tmp=tmp//.simpleDot2[scalars]
];
tmp
];
simpleDot3[scalars_List:{}][exp_]:=tuDotSimplify[scalars][exp];
(*
ruleSimpleDot[rule_List,scalar_List,constant_List][exp_] recurrent combinations of Functions. *27Oct2014*)ruleSimpleDot[rule_List,scalar_List,repeat_Integer:2][exp_]:=Block[{tmp=exp,tmp1,xrule=Flatten[rule],n=0},
While[tmp=!=tmp1&&n<repeat,tmp1=tmp;n++;
tmp=tmp/.xrule//simpleDot3[scalar];
];
tmp
];
ruleSimpleDot[rule_List,scalar_List,constant_List,repeat_Integer:2][exp_]:=Block[{tmp=exp,tmp1,xrule=Flatten[rule],n=0},
While[tmp=!=tmp1&&n<repeat,tmp1=tmp;n++;
tmp=tmp/.xrule//DerivativeExpand[constant]//simpleDot3[scalar];
];
tmp
]
(*
orderDot[exp_(Dot|xDot)] Orders terms in exp_(Dot|xDot) *10Oct2012*)
orderDot[exp_Dot|exp_xDot]:=Apply[Head[exp],Sort[Apply[List,exp]]](*Simple Sort will do.*)
(*
orderArg[term_] orders arguements of any term_.  Supercede orderDot. E.G.: exp/.dot:Dot[a_,b_]:>orderArg[dot]   *23Oct2012*)
orderArg[term_]:=Apply[Head[term],Sort[Apply[List,term]]]
(*
SeparateInto2After[term_][exp_] separates exp_ into 2 pieces with the same Head. The separation point right after term_ which may be a pattern.  Usage example:
exp /.dot:HoldPattern[Dot[a_,b__]]\[RuleDelayed]SeparateInto2After[Subscript[u, e][_]][dot]   *10Nov2012*)
SeparateInto2After[term_][exp_]:=Module[{head,tmp=exp,pos,front,back},
head=Head[tmp];
tmp=Apply[xDot,tmp];
pos=Position[tmp,term,1,1]//Flatten;
front=Apply[head,Take[tmp,Flatten[Append[{1},pos]]]];
back=Apply[head,Take[tmp,Flatten[Append[pos+1,{-1}]]]];
front back
];

(*
CollectDotRight[var_][exp_] collects var_ terms in exp_ if var_ is on the right of Dot[...,var_] or in a Times term.  *10Oct2013*)
CollectDotRight[var_][exp_]:=Module[{tmp=exp,test,tmp1,pos},
tmp=tmp/.Dot->xDot;
tmp=tmp/.{var  ii:___->xDot[ii].test[var],b___ var^n_->xDot[b var^(n-1)]. test[var],xDot[b__,var]->xDot[b] . test[var]};
pos=Position[tmp,Dot[a__,test[_]],2];(*???ERR\[LeftArrow]no Dot*)
tmp1=Extract[tmp,pos]/.test[_]->1//Apply[Plus,#]&;
tmp1=tmp1//.simpleDot2[{}]/.fxDot->Dot;
tmp1=Dot[tmp1,var];
tmp=Delete[tmp,pos];
tmp+tmp1/.xDot->Dot
];
(*
CollectDotLeft[var_][exp_] collects var_ terms in exp_ if var_ is on the left of Dot[var_,...,] or in a Times term.  *10Oct2013*)
CollectDotLeft[var_][exp_]:=Module[{tmp=exp,test,tmp1,pos},
tmp=tmp/.Dot->xDot;
tmp=tmp/.{var  ii:___->test[var].xDot[ii],b___ var^n_->test[var].xDot[b var^(n-1)],xDot[var, b__]-> test[var].xDot[b]};xPrint[tmp];
pos=Position[tmp,Dot[test[_],a__],2];xPrint[pos];(*???ERR\[LeftArrow]no Dot*)
tmp1=Extract[tmp,pos]/.test[_]->1//Apply[Plus,#]&;xPrint[tmp1];
tmp1=tmp1//.simpleDot2[{}]/.xDot->Dot;
tmp1=Dot[var,tmp1];
tmp=Delete[tmp,pos];
tmp+tmp1/.xDot->Dot
];

tuDotVarCollect::usage="tuDotVarCollect[side_String:'LR'][exp_] collects left/right end variables of dotOps terms in Plus[] expression to the left/right.  The side_String 'L','R','LR' determines the side to collect. *17Feb2016*";
tuDotVarCollect[side_String:"LR"][exp_]:=Block[{tmp=exp,SCL},
If[!StringFreeQ [side,"R"],
tmp=tmp/.(dd:dotOps)[a__](acc___:1):>dd[SCL[acc],a]/.dd[SCL[1],a__]->dd[a];
tmp=tmp//.(dd:dotOps)[a__,c_]+(dd:dotOps)[b__,c_]->dd[(dd[a]+dd[b]),c];
tmp=tmp/.(dd:dotOps)[SCL[a__],b__]->SCL[a]dd[b]/.SCL[a__]:>Times[a]
];
If[!StringFreeQ [side,"L"],
tmp=tmp/.(dd:dotOps)[a__](acc___:1):>dd[a,SCL[acc]]/.dd[a__,SCL[1]]->dd[a];
tmp=tmp//.(dd:dotOps)[c_,a__]+(dd:dotOps)[c_,b__]->dd[c,(dd[a]+dd[b])];
tmp=tmp/.(dd:dotOps)[b__,SCL[a__]]->SCL[a]dd[b]/.SCL[a__]:>Times[a]
];
tmp
];
collectDotTermsLeftRight[exp_Plus]:=tuDotVarCollect["LR"][exp];(*Compatibility*)
collectDotRight[exp_]:=tuDotVarCollect["R"][exp];(*Compatibility*)
collectDotLeft[exp_]:=tuDotVarCollect["L"][exp];(*Compatibility*)

(*
Rules to simplify NonCommuting expressions.  Usage: a\[CircleTimes](4 b)\[CircleTimes]c//.simpleNC[op]. NOTE: Does not work for Dot. 25 June 2012 *)
Clear[simpleNC];
simpleNC[op_,scalars_List]:={
op[a___,d___ c_,b___]:>c op[a,d,b]/;ListMemberQ[c,scalars],
op[a___,d___ c_^n_,b___]:>c^n op[a,d,b]/;ListMemberQ[c,scalars],
op[a___,c_,b___]:>c op[a,b]/;ListMemberQ[c,scalars]&&(Length[{a}]>0||Length[{b}]>0),
op[a___,c_^n_,b___]:>c^n op[a,b]/;ListMemberQ[c,scalars]&&(Length[a]>0||Length[b]>0),
simpleTranspose[scalars],(*CHECK if appropriate.*)
op[a___,n_ d_,c___]:>n op[a,d,c]/;NumericQ[n],
op[a___,b_,c___]:>b op[a,c]/;NumericQ[b],
op[a___,-b_,c___]->-op[a,b,c],
Conjugate[op[a__]]:>Map[Conjugate[#]&,op[a]]/;op=!=Dot
}//Flatten;
(**)
tuOpIfMultiArg::usage="tuOpIfMultiArg[op_,arg_List] forms op_[arg_] if Length of arg_List > 1 *4Mar2016*";
tuOpIfMultiArg[op_,arg_List]:=Block[{$},
If[Length[arg]>1,op[Apply[Sequence,arg]],arg[[1]] ]
];
(**)
Clear[tuOpCollect];
tuOpCollect::usage="tuOpCollect[op_:dotOps,dist_:Plus] is Rule[]s for collecting terms with common symbol on the left or right of a dist_ expressions.
 ie. c1(a.b)+d1(c.b)\[Rule](c1 a+d1 c).b. NOTE: has problems with complex expressions. *1Mar2016*";
tuOpCollect[op_:dotOps,dist_:Plus]:={
dist[ (c1_:1)(oo:op)[a1__ ,Longest[ b__]] ,(c2_:1)(oo:op)[a2__,  Longest[ b__]]]:>oo[dist[c1  tuOpIfMultiArg[oo,{a1}]
,c2 tuOpIfMultiArg[oo,{a2}]] , tuOpIfMultiArg[oo,{b}]],
dist[(c1_:1)(oo:op)[Longest[ b__],a1__ ] ,(c2_:1)(oo:op)[Longest[ b__],a2__ ]]:>oo[tuOpIfMultiArg[oo,{b}], dist[c1  tuOpIfMultiArg[oo,{a1}],c2 tuOpIfMultiArg[oo,{a2}]] ]
};
(**)
Clear[tuCircleTimesOp];
tuCircleTimesOp::usage="tuCircleTimesOp[OP_:Null][exp_] PROTOTYPE routine to expand \[CircleTimes] expression.  OP_ does nothing. EG: (a\[CircleTimes]b\[CircleTimes]c).(a1\[CircleTimes]b1\[CircleTimes]c1)//tuCircleTimesOp[]\[Rule]a.a1\[CircleTimes]b.b1\[CircleTimes]c.c1   *2Jul2015*";
tuCircleTimesOp[OP_:Null][exp_]:=Block[{$0=exp,$,ops=Flatten[Times|dotOps]},
$=$0;xPrint[" ",$];
(*Nested *)
$=$/.CircleTimes[f__][ CircleTimes[d__]]:>Inner[#1[#2]&,{f},{d},CircleTimes]/;Length[{f}]>1&&Length[{f}]==Length[{d}];
(*Distribute arguements over each element of \[CircleTimes].*)
$=$/.CircleTimes[f__][d__]:>Apply[CircleTimes,Map[#[d]&,{f}]]/;Length[{f}]>1;
(*Distribute op_ over \[CircleTimes]*)
xPrint[Flatten[ops|OP]];
$=$/.oo:op_[CircleTimes[a__] , CircleTimes[b__]]:>Thread[oo,CircleTimes]/;MemberQ[Flatten[ops|OP],op];
$
];

tuCircleTimesExpand::usage="tuCircleTimesExpand[exp_] distributes CircleTimes Head over arguements. e.g. (a\[CircleTimes]b)[ c\[CircleTimes]d ]\[Rule]a[ c ]\[CircleTimes]b[ d ] and (a\[CircleTimes]b)[ c ]\[Rule]a[ c ] \[CircleTimes] b[ c ] *1Oct2015*";
tuCircleTimesExpand[exp_]:=Block[{$},
$=exp;
$=$/.CircleTimes[f__][  CircleTimes[d__]  ]:>Inner[#1[#2]&,{f},{d},CircleTimes]/;Length[{f}]>1&&Length[{f}]==Length[{d}];
$=$//.CircleTimes[f__][d__]:>Apply[CircleTimes,Map[#[d]&,{f}]]/;Length[{f}]>1;
$
];

tuCircleTimesGather::usage="tuCircleTimesGather[OP_:Null][exp_] gathers \[CircleTimes] expressions, e.g., (a\[CircleTimes]b).(c\[CircleTimes]d)->(a.c)\[CircleTimes](b.d) *1Oct2015*";
tuCircleTimesGather[OP_:Null][exp_]:=Block[{$=exp,ops=Flatten[{dotOps,Plus}]},
$=$//.oo:op_[CircleTimes[a__] , CircleTimes[b__]]:>Thread[oo,CircleTimes]/;MemberQ[Flatten[{ops,OP}],op];
$
];

Clear[tuCircleTimesInnerTerm];
tuCircleTimesInnerTerm::usage="tuCircleTimesInnerTerm[difOp_][exp_] computes the inner terms produced when merging CircleTimes operator expressions, esp_, e.g., (a\[CircleTimes]b).(c\[CircleTimes]d)\[Rule](a.c)\[CircleTimes](b.d)+(a.tuCircleTimesInnerTerm[c[b],\[Del]])\[CircleTimes](d).  Assumes dotOps variable separators.  *2Mar2016*"  ;
tuCircleTimesInnerTerm[difOp_][exp_]:=Block[{$h,$h1,$dif,$=exp},
$h=Head[exp];xPrint[$h];
If[FreeQ[$h,difOp],$=0;,
If[!FreeQ[$h,dotOps],xPrint["$XX ",$h];
$dif=tuExtractPattern[difOp][$h][[1]];xPrint[exp];
$=$dif[exp[[1]]];xPrint[$h,Length[$h]];
$h1=Head[$h];
If[tuMemberQ[$h1,dotOps],
$h=Apply[$h1,DeleteCases[Apply[List,$h],difOp]];
$=Apply[$h1,{$h,$}]
];
];
];
$
];

(********
Trace (Tr) expansion Rules*)
tuTrExpand=tt:Tr[_]:>tuDistributeOp[Tr[_]][tt];
(**)
TrExpand:=tuTrExpand;
Clear[tuTrSimplify]
tuTrSimplify::usage="tuTrSimplify[scalars_List:{},product_:Times][exp_] simplifies Tr[] terms under product_ operation in exp_. Rules are applied to the terms Tr[product_[...]] accounting for Tr[] scalars_List. *16Jan2016*";
tuTrSimplify[scalars_List:{},product_:Times][exp_]:=Block[{$=exp,$s,iproduct=Inactive[product]},
$=$/.product->iproduct;
$s={Tr[(pp:iproduct)[aa___,Tr[a_],b___]]->Tr[pp[aa,a,b]],
Tr[(pp:iproduct)[a___, c_^(n_:1),b___]]:>pp[c^n ,Tr[pp[a,b]]]/;(tuMemberQ[c,scalars]||NumericQ[c]||Head[c]===Tr),
Tr[Tr[a_]]->Tr[a],
Tr[0]->0,
Tr[]->1,
tuTrExpand(* BUG: placement of this Rule matters.*)
}//Flatten;
Activate[$//.$s,product]
];
simpleTr2[scalars_List:{}]:=tuTrSimplify[scalars];(*No longer compatible*)
simpleTr:=tuTrSimplify[];(*No longer compatible*)
(**)
tuTrCanonicalOrder::usage="tuTrCanonicalOrder[exp_Tr] Canonically orders Dot expression in exp_Tr[Dot[]]. EG: exp/.tt:Tr[a_]:>tuTrCanonicalOrder[tt] . *17Jun2015*";
tuTrCanonicalOrder[exp_Tr]:=Block[{$,$low,$range},
$low=$=exp[[1]]/.Dot->List;
$range=Range[Length[$]];
Do[
$=Permute[$,Cycles[{$range}]];xPrint[$range,$,$low,OrderedQ[{$,$low}]];
If[OrderedQ[{$,$low}],$low=$];
,
{Length[$]}
];
Tr[Apply[Dot,$low]]
];

(*Rules for simplifying expressions with metric tensor.*)
simpleMetric[g_]:={Tensor[g,{Void,$a_},{$b_,Void}]->Tensor[g,{$b,Void},{Void,$a}],
Tensor[g,{0,0},{Void,Void}]|Tensor[g,{Void,Void},{0,0}]->1,
Tensor[g,{a_,a_},{Void,Void}]|Tensor[g,{Void,Void},{a_,a_}]:>-1/;MemberQ[{1,2,3},a],
Tensor[g,{a_,b_},{Void,Void}]|Tensor[g,{Void,Void},{a_,b_}]:>0/;IntegerQ[a]&&IntegerQ[b]&&a=!=b,
Tensor[g,{a_,Void},{Void,a_}]|Tensor[g,{Void,a_},{a_,Void}]:>-2/;!IntegerQ[a]
};
(* 
simple\[Epsilon][exp_] zeros any LeviCivitaTensor with duplicate indices.  *16Oct2012*)
(*Has the code been deleted? *)

(* Standard order of indices of LeviCivita tensor, i.e., Subscript[(\[Epsilon]^abc), def] , Up first, retains UpDown positions *2Mar2013*)
Order\[Epsilon][tensor_Tensor]:=Module[{tmp,tmps,u1,d1,u,d,xx,yy,cycle,order,tmpx,tmpy},
u1=tensor[[2]];
d1=tensor[[3]];
tmp=MapThread[DeleteCases[{xx[#1],yy[#2]},_[Void]]&,{u1,d1}]//Flatten;
tmps=Sort[tmp];
cycle=FindPermutation[tmp,tmps];
order=PermutationOrder[cycle];
tmpy=tmps/.xx[_]->Void/.yy[a_]->a;
tmpx=tmps/.yy[_]->Void/.xx[a_]->a;
(-1)^(order+1) Tensor[tensor[[1]],tmpx,tmpy]
];
(*Rule for standard ordering of all \[Epsilon] tensors.*)
OrderAll\[Epsilon]={Tensor[\[Epsilon],a_,b_]:>Order\[Epsilon][Tensor[\[Epsilon],a,b]]}

(*
simple2\[Epsilon][exp_,dimension_Integer] contracts pairs of \[Epsilon] Tensors (LeviCivita)in dimension_-space.
Limitations:,
Converts Tensor pairs into \[Delta]-form,
Does not handle more than 2 \[Epsilon]'s,
Does not handle different size \[Epsilon]'s, 
There is uncertainty over sign.  PS is negative of Wiki. Uses Wiki convention. *20Jun2013*)
simple2\[Epsilon][exp_,dimension_Integer]:=Module[{tmp=exp,pos,up,dn,bad,i,pair,tmp1,tmp2,tmpd,u1,u2,d1,d2,$u1,$u2,$d1,$d2,ups,dns,E\[Epsilon]E,E\[Epsilon]Epat,EEterm,dummies,tindices,indices,n,m,\[Mu],\[Nu]},
E\[Epsilon]Epat=(EEterm:Tensor[\[Epsilon],$u1_List,$d1_List]Tensor[\[Epsilon],$u2_List,$d2_List]);
tmp=tmp/.E\[Epsilon]Epat:>E\[Epsilon]E[EEterm];
pos=ExtractPositionPattern[tmp,E\[Epsilon]E[___]];
For[i=1,i<=Length[pos],i++,(*Go through all \[Epsilon] \[Epsilon] index contractions.*)
pair=pos[[i,2,1]];
{dummies,{up,dn},bad}=tuIndexParser[pair];
indices=pair/.E\[Epsilon]Epat->{$u1,$d1,$u2,$d2};
{u1,d1,u2,d2}=indices;
If[Length[d1]==Length[d2],(* \[Epsilon]'s must be of equal size.*)
(*Build template*)
n=Length[d1];m=Length[dummies]>0;
tmp1= Product[\[Delta]@du[\[Mu][i],\[Nu][i]],{i,n}];
tmp1=n! tmp1//AntiSymmetrizeIndices[Table[\[Mu][i],{i,n}]];
tmp1=tmp1/.IndexChange->IndexChangeTU//Expand;(*Tensorial does not handle these types of indices.*)
If[PeskinSchroederMode===1,tmp1=-tmp1];(*PeskinSchroeder sign differs from Wiki. *)
tmpd=DeleteCases[Flatten[indices],Void];
tmpd=Thread[Rule[Flatten[{Table[\[Mu][i],{i,n}],Table[\[Nu][i],{i,n}]}],tmpd]];
(*Tensorial does not handle index functions.*)
tmp1=tmp1/.tmpd;
tmp1=tmp1//Expand//MetricContractAll[\[Delta],dimension];
ups=DeleteCases[Join[u1,u2],Void];
dns=DeleteCases[Join[d1,d2],Void];
tmp1=tmp1//RaiseIndexTU1[ups,ups]//LowerIndexTU1[dns,dns];
];
pos[[i,2]]=tmp1;
];
tmp=ReplacePartTU[tmp,pos];
tmp=tmp/.E\[Epsilon]E[a_]->a
];
(*
simple2\[Epsilon][exp_] default for 4-dim space*)
simple2\[Epsilon][exp_]:=simple2\[Epsilon][exp,4]
 
(*Relabels \[Epsilon]-matrix indices contained in product terms to indices \[Epsilon][1],\[Epsilon][2],... *)
Relabel\[Epsilon][exp_]:=Module[{tmp=exp,pos,ipos,tmpp,pos\[Delta],ipos\[Delta],indices,post},
tmp=Expand[tmp];
pos=ExtractPositionPattern[tmp,Times[a___,Tensor[\[Epsilon],_,_],b___]];
For[ipos=1,ipos<=Length[pos],ipos++,
tmpp=pos[[ipos,2]];
pos\[Delta]=ExtractPositionPattern[tmpp,Tensor[\[Epsilon],_,_]];
post=ExtractPositionPattern[tmpp,Tensor[_,_,_]];
For[ipos\[Delta]=1,ipos\[Delta]<=Length[pos\[Delta]],ipos\[Delta]++,
indices=Apply[List,pos\[Delta][[ipos\[Delta],2]]][[2;;3]]//Flatten;
indices=DeleteCases[indices,Void];
;
indices=MapThread[{#1,#2}&,{indices,Array[\[Epsilon],Length[indices]]}];
post=post//IndexChangeTU[indices];
tmpp=ReplacePart[tmpp,post];
];
pos[[ipos,2]]=tmpp;
];
tmp=ReplacePart[tmp,pos]
];

(*Expands and changes each term in expression so that all \[Epsilon] indices are in down position.  May not handle summing over 2 \[Epsilon] tensors.*)
All\[Epsilon]Down[exp_]:=Module[{tmp=exp,pos,ipos,tmpp,pos\[Epsilon],ipos\[Epsilon],indices},
tmp=Expand[tmp];
(*Times terms with \[Epsilon]*)
pos=ExtractPositionPattern[tmp,Times[a___,Tensor[\[Epsilon],_,_],b___]];
For[ipos=1,ipos<=Length[pos],ipos++,
tmpp=pos[[ipos,2]];
pos\[Epsilon]=ExtractPositionPattern[tmpp,Tensor[\[Epsilon],_,_]];
For[ipos\[Epsilon]=1,ipos\[Epsilon]<=Length[pos\[Epsilon]],ipos\[Epsilon]++,
indices=pos\[Epsilon][[ipos\[Epsilon]]]  [[2,2]];
indices=DeleteCases[indices,Void];
tmpp=tmpp//SwapUpDownIndices[indices];
];
pos[[ipos,2]]=tmpp;
];
tmp=ReplacePart[tmp,pos]
];
(*
simplifyLeviCivita[dimension_Integer][exp_] simplifies exp_ with dimension_-space LeviCivita Tensor[]s by zeroing terms with duplicate indices, expanding \[Epsilon] Tensor pairs into \[Delta] which are simple2\[Epsilon]'d, tests for sum\[Rule]0 of the EinsteinSum[] of LeviCivita terms (terms are zeroed if so.). *24Jul2013*)
simplifyLeviCivita[dimension_Integer][exp_]:=Module[{tmp,up,dn,rest,pos,tensors,test},
(*Need these declarations for TensorSimplify *)
dclTensorSymmetry[\[Epsilon],2]=AntiSymmetric[1,2];
dclTensorSymmetry[\[Epsilon],3]=AntiSymmetric[1,2,3];
dclTensorSymmetry[\[Epsilon],4]=AntiSymmetric[1,2,3,4];
(*0 for duplicate indices(Not needed due to Symmetry.)*)
tmp=exp/.term:(Tensor[\[Epsilon],up_List,dn_List]):>0/;((test=DeleteCases[ Join[up,dn],Void])=!=DeleteDuplicates[test]);
(*Assign numeric indices. *)
tmp=tmp/.ee:Tensor[\[Epsilon],up_List,dn_List]:>numericLeviCivita[{-1,1,1,1,1,1,1}][ee];
(*Simplify \[Epsilon] Tensor pairs.*)
tmp=Expand[tmp]//simple2\[Epsilon][#,dimension]&//Expand;
(*raise all dummy indices in \[Epsilon]-Tensor.) *)
tmp=tmp/.term:HoldPattern[Times[a__]]:>raiseLeviCivitaDummyIndices[term];
(*
THIS PART IS UNIQUE to 4D.  Use Tensorial EinsteinSum[] LeviCivita Tensor terms to see if they sum to 0.*)
(*test=Apply[Plus,ExtractPattern[tmp,\[Epsilon]@uuuu[a_,b_,c_,d_]rest__]]//TensorSimplify;
test=test//EinsteinSum[]//TensorSimplify;
If[test\[Equal]0,pos=ExtractPositionPattern[tmp,\[Epsilon]@uuuu[a_,b_,c_,d_]rest__];
pos=Map[#[[1]]\[Rule]0&,pos];
tmp=ReplacePart[tmp,pos];
];*)
tmp
];
(*
numericLeviCivita[metric_List][exp_Tensor]computes the numerical value of Levi-Civita tensor with all numeric indices.  metric_List are the values of the diagonal for the metric tensor referenced by {up|dn}->{0,1,...}. 
exp_Tensor is the Levi-Civita Tensor. *24July2013*)
numericLeviCivita[metric_List][exp_Tensor]:=Module[{tmp=exp,sym,up,dn,indices,allnumeric},
{sym,up,dn}=Apply[List,tmp];
indices=(up+dn)/.Void->0;
allnumeric=!MemberQ[(NumericQ/@indices),False];
If[allnumeric&&Max[indices]<Length[metric],(*Test indicies to see if they are within range of dimension. There is confusion with meaning of \[Epsilon][0,3,2], apply same algorithm. But it is a PROBLEM since there are cases where \[Epsilon] is used with fewer indices then there are dimensions. Maybe we should pass the metric signature.*)
(*Apply metric factors for Raising index. The first index is always 0 for the time.*)
tmp=Map[metric[[#+1]]&,DeleteCases[dn,Void]];
tmp=Apply[Times,Append[tmp,1]];
tmp=tmp Signature[indices];
];
tmp
];(*TESTS
{\[Epsilon]@dd[3,2],\[Epsilon]@ddd[1,2,3],\[Epsilon]@uuu[1,2,3]}
simplifyLeviCivita[4]/@%*);

(*
raiseLeviCivitaDummyIndices[term_Times|Dot|xDot] raises all indices of LeviCivita Tensor in term_Times|Dot|xDot.  *15Oct2012*)
raiseLeviCivitaDummyIndices[term_Times|Dot|xDot]:=Module[{tmp=term,i,LCs,LCdn,dummies,dnup},
dummies=tuIndexParser[tmp][[1]];
LCs=ExtractPositionPattern[tmp,Tensor[\[Epsilon],up_List,dn_List]];
For[i=1,i<=1(*May want to extend to all \[Epsilon]-Tensors where the last one encountered is dominant.*),i++,
LCdn=tuIndexParser[LCs[[i,2]]][[2,2]];
dnup=Intersection[LCdn,dummies];
tmp=UpDownIndexSwap[dnup][tmp];
];
tmp
];
(*
antisymmetrizeLeviCivitaCoef[term_] antisymmetrizes over dummy indices the coefficient of the first LeviCivita tensor.  Symmetric coefficients are zero. UNTESTED *16Oct2012*)
antisymmetrizeLeviCivitaCoef[term_Times]:=Module[{dum,LCs,LCind,antiInd,tmp1,tmp2,i},
dum=tuIndexParser[term][[1]];
LCs=ExtractPositionPattern[term,Tensor[\[Epsilon],up_List,dn_List]];
tmp1=term;tmp2=1;
For[i=1,i<=1(*Length[LCs] complicated if there more than one such Tensor.*),i++,
LCind=tuIndexParser[LCs[[i,2]]][[2]]//Flatten;
antiInd=Intersection[LCind,dum];
tmp2*=LCs[[i,2]](Delete[tmp1,LCs[[i,1]]]//AntiSymmetrizeIndices[antiInd])
];
{dum,LCs,LCind,antiInd,tmp2};
tmp2
];
(*
symmetricCoefQ[term_] determines if the coefficients of LeviCivitaTensor are symmetric over dummy sum indices. UNTESTED *16Oct2012*)
symmetricCoefQ[term_Times]:=Module[{dum,LCs,LCind,antiInd,tmp1,tmp2,i},
dum=tuIndexParser[term][[1]];
LCs=ExtractPositionPattern[term,Tensor[\[Epsilon],up_List,dn_List]];
tmp1=term;tmp2=1;
For[i=1,i<=Length[LCs],i++,
LCind=tuIndexParser[LCs[[i,2]]][[2]]//Flatten;
antiInd=Intersection[LCind,dum];
tmp2*=(Delete[tmp1,LCs[[i,1]]]//AntiSymmetrizeIndices[antiInd])
];
{dum,LCs,LCind,antiInd,tmp2};
tmp2==0
];

(*Returns a {exp_, Down index version of exp_ of indices_List} *)
WithIndexDown[indices_List][exp_]:=Module[{tmp},
{exp,Fold[LowerIndex[#2,#2][#1]&,exp,indices]}//Flatten
];

tuIndexChange::usage="tuIndexChange[pairs_List][exp_] replaces indices in exp_ specified in pairs_List which is of form {{a,b},{c,d}}. In this case a\[Rule]b,c\[Rule]d. This routine can handle indices used in DerivOps. *5Sep2015*";
tuIndexChange[pairs_List][exp_]:=Block[{pos,rules,ipos,indices},
rules=Map[Apply[Rule,#]&,Partition[Flatten[{pairs}],2]];
pos=ExtractPositionPattern[exp,Tensor[_,_,_]|Map[#[_,_]&,DerivOps]];
For[ipos=1,ipos<=Length[pos],ipos++,
indices=tuIndexParser[pos[[ipos]]]//Flatten;
pos[[ipos]]=pos[[ipos]]//.tuRuleSelect[rules][indices];
];
tuReplacePart[exp,pos]
];
IndexChangeTU[pairs_List][exp_]:=tuIndexChange[pairs][exp];(*Compatibility*)

(*
UpDownSymmetrize[index_][exp_] symmetrizes UpDn index_ in exp_ *11Apr2014*)
UpDownSymmetrize[index_][exp_]:=Module[{tmp1,tmp2,symSub},
symSub[term_]:=Module[{},(term+UpDownIndexSwap[index][term])/2];
tmp1=exp//Expand;
tmp1=Map[symSub[#]&,tmp1]
];

(* Simplifies \[Delta]uu,\[Delta]ud,\[Delta]du,\[Delta]dd and contractions into standard form.  Does not care about Einstein notation. Usage: exp_//.simple\[Delta][dim_]  *)
simple\[Delta][\[Delta]_][exp_]:=Module[{tmp=exp},
tmp=tmp//KroneckerAbsorb[\[Delta]];(* This only works with UpDown \[Delta]'s *)
tmp=tmp//.{
\[Delta]@uu[a_,b_]:>\[Delta]@uu[b,a]/;OrderedQ[b,a],
\[Delta]@dd[a_,b_]:>\[Delta]@dd[b,a]/;OrderedQ[b,a],
\[Delta]@du[a_,b_]:>\[Delta]@ud[b,a]/;OrderedQ[b,a],
(*Following not recognized by KroneckerAbsorb[\[Delta]] *)
\[Delta]@uu[a_,b_]\[Delta]@dd[a_,c_]:>\[Delta]@ud[b,c],(* Einstein sums *)
\[Delta]@uu[a_,b_]\[Delta]@dd[c_,a_]:>\[Delta]@ud[b,c],
\[Delta]@uu[b_,a_]\[Delta]@dd[a_,c_]:>\[Delta]@ud[b,c],
\[Delta]@uu[b_,a_]\[Delta]@dd[c_,a_]:>\[Delta]@ud[b,c],
Tensor[\[Delta],a_List,b_List]:>Length[GetBaseIndices[First[DeleteCases[Join[a,b],Void]]]]/;Apply[Equal,DeleteCases[Join[a,b],Void]]
};
tmp
];

(*Contracts \[Delta] (KroneckerDelta) indices with other expression indices. Does not respect Einstein up/down notation. KroneckerContract works better although needs up-down convention. *)
Contract\[Delta][exp_]:=Module[{tmp=exp,pos,ipos,tmpp,pos\[Delta],ipos\[Delta],indices,post,testindices},
tmp=Expand[tmp];
pos=ExtractPositionPattern[tmp,Times[a___,Tensor[\[Delta],_,_],b___]];
List[pos];
For[ipos=1,ipos<=Length[pos],ipos++,
tmpp=pos[[ipos,2]];
pos\[Delta]=ExtractPositionPattern[tmpp,Tensor[\[Delta],_,_]];
List[pos\[Delta]];
tmpp=tmpp/.Tensor[\[Delta],_,_]->1;
post=ExtractPositionPattern[tmpp,Tensor[_,_,_]];
For[ipos\[Delta]=1,ipos\[Delta]<=Length[pos\[Delta]],ipos\[Delta]++,
indices=Apply[List,pos\[Delta][[ipos\[Delta],2]]][[2;;3]]//Flatten;
indices=DeleteCases[indices,Void];
(*Check if indices match to see if \[Delta] is consumed.*)
testindices=ParseTermIndices[tmpp][[2]]//Flatten;
If[MemberQ[testindices,First[indices]],
post=post//IndexChangeTU[{indices}];
tmpp=ReplacePart[tmpp,post],
tmpp=tmpp pos\[Delta][[ipos\[Delta],2]]
];
];
pos[[ipos,2]]=tmpp;
];
tmp=ReplacePart[tmp,pos]
];

(*Rules for expanding Einstein indices in Dot'd expression.  Handles xPartialD[]'s and Uses \[Eta]dd[] as coefficients in sum and preference for results with lower indices.*)
DotSumExpand[range_List]:={Tensor[a_,b_,c_].xPartialD[d_,e_]:>Sum[Tensor[a,b,c].xPartialD[d,e]/.e->j,{j,range}]/;MemberQ[b,e],

xPartialD[d_,e_].Tensor[a_,b_,c_]:>Sum[xPartialD[d,e].Tensor[a,b,c]/.e->j,{j,range}]/;MemberQ[b,e],

xPartialD[a_,b_].xPartialDu[d_,b_]:>Sum[xPartialD[a,b].xPartialDu[d,b]/.b->j,{j,range}],

xPartialDu[a_,b_].xPartialD[d_,b_]:>Sum[xPartialDu[a,b].xPartialD[d,b]/.b->j,{j,range}]
(* NOT FINISHED
Tensor[a_,b_,c_].Tensor[d_,e_,f_]\[RuleDelayed]Sum[\[Eta]uu[e,e]Tensor[a,b,c].Tensor[d,e,f]/.e\[Rule]j,{j,range}//Flatten]/;MemberQ[b,e](*FIND mutual index*)
*)
};

(*Rules for expanding Einstein indices in Dot'd expression.  Handles xPartialDu[]'s and uses \[Eta]dd[] to convert from xPartialDu->xPartialD *)
DotSumExpand\[Eta][range_List]:={
Tensor[a_,b_,c_].xPartialD[d_,e_]:>Sum[Tensor[a,b,c].xPartialD[d,e]/.e->j,{j,range}]/;MemberQ[b,e],

Tensor[a_,b_,c_].xPartialDu[d_,e_]:>Sum[Tensor[a,b,c].xPartialD[d,e]\[Eta]uu[e,e]/.e->j,{j,range}]/;MemberQ[c,e],

xPartialD[d_,e_].Tensor[a_,b_,c_]:>Sum[xPartialD[d,e].Tensor[a,b,c]/.e->j,{j,range}]/;MemberQ[b,e],

xPartialDu[d_,e_].Tensor[a_,b_,c_]:>Sum[xPartialD[d,e].Tensor[a,b,c]\[Eta]uu[e,e]/.e->j,{j,range}]/;MemberQ[b,e],

xPartialD[a_,b_].xPartialDu[d_,b_]:>Sum[xPartialD[a,b].xPartialD[d,b]\[Eta]uu[b,b]/.b->j,{j,range}],

xPartialDu[a_,b_].xPartialD[d_,b_]:>Sum[xPartialD[a,b].xPartialD[d,b]\[Eta]uu[b,b]/.b->j,{j,range}]
(* NOT FINISHED
Tensor[a_,b_,c_].Tensor[d_,e_,f_]\[RuleDelayed]Sum[\[Eta]uu[e,e]Tensor[a,b,c].Tensor[d,e,f]/.e\[Rule]j,{j,range}//Flatten]/;MemberQ[b,e](*FIND mutual index*)
*)
};

(*DotIndexSum[exp_,range_List] sums indices over range_list in Dot[] expressions in exp_.  This routine removes difficiences in NewIndexChangePatterns and EinsteinSum[].  Replaces DotSumExpand[] *)
DotIndexSum[exp_,range_List]:=Module[{exp0=exp,tmp,onetime,list,dlist,ilist,i,DEBUG=0,mname="DotIndexSum"},
exp0=exp/.Dot->xDot;(* Next line does not work with Dot[], needs xDot[] *)
list=ExtractPositionPattern[exp0,xDot[__]];
IfDEBUG[mname,DEBUG>0,{list,Length[list],onetime},"list"];
For[i=1,i<=Length[list],i++,
dlist=list[[i,2]]/.xDot->Dot;
IfDEBUG[mname,DEBUG>0,{dlist},"dlist"];
ilist=ParseTermIndices[dlist]//First;
dlist=dlist//EinsteinSum[range];
IfDEBUG[mname,DEBUG>0,{ilist,dlist},"ilist,dlist"];
dlist=dlist/.xPartialD[a_,b_].s___.xPartialDu[d_,b_]:>Sum[xPartialD[a,b].s.xPartialDu[d,b]/.b->j,{j,range}]/;MemberQ[ilist,b];
dlist=dlist/.xPartialDu[a_,b_].s___.xPartialD[d_,b_]:>Sum[xPartialD[a,b].s.xPartialDu[d,b]/.b->j,{j,range}//Flatten]/;MemberQ[ilist,b];
list[[i,2]]=dlist;
IfDEBUG[mname,DEBUG>0,{list},"list"];
];
If[Head[exp0]===xDot,list[[1,2]],
ReplacePart[exp0,list]]
];

DotIndexSum[range_List][exp_]:=DotIndexSum[exp,range]

(*Computes Euler-Lagrange equation for single field (field_)given Lagrangian_ and indices,  t_ {0,1,2,3}.  Uses \[Eta]uu[] for summing over indices t_.  Returns Euler-Lagrange equation \[Rule] 0 *)EulerLagrange[Lagrangian_,field_,t_List]:=Module[{tmp,tL,tEL,tEL0,tEL1,\[Mu],i,j,out,dfield,DEBUG=0,mname="EulerLagrange"},
tL=Lagrangian/.DotSumExpand\[Eta][t];
IfDEBUG[mname,DEBUG>0,{tL},"{tL}"];
dfield=xPartialD[field,\[Mu]];
tEL=xPartialD[xPartialD[tL,xPartialD[field,\[Mu]]],\[Mu]]-xPartialD[tL,field];
tEL0=xPartialD[tL,field];
tEL0=tEL0/.xPartialD[a_,b_]:>D[a,b];
tEL1=xPartialD[tL,dfield];
tEL1=xPartialD[tEL1,\[Mu]];
IfDEBUG[mname,DEBUG>0,{j,t,tEL1},"{j,t,tEL1}"];
tEL1=Sum[tEL1/.\[Mu]->j,{j,t}  ];
IfDEBUG[mname,DEBUG>0,{tEL1},"{tEL1}"];
For[i=1,i<=Length[t],i++,tEL1=tEL1/.xPartialD[a_,dfield/.\[Mu]->t[[i]]]:>D[a,dfield/.\[Mu]->t[[i]]]
];
out=tEL1-tEL0/.Derivative[__][_][__]->0//.xPartialDExpand[{\[Gamma]@u[_],\[Gamma][_]}]//.simpleDot;
out->0
];
(**)
tuBraKetSimplify::usage="tuBraKetSimplify[scalars_List] are Rules that simplify BraKet[] expressions.  Extracts scalars_ and NumericQ[] *20Feb2015*";
tuBraKetSimplify[ scalars_List:{}]:={
BraKet[a_+b_]->BraKet[a]+BraKet[b],BraKet[q1_,a_ b_,q2_]:>a BraKet[q1,b,q2]/;NumericQ[a]||ListMemberQ[a,Flatten[{scalars,scalars^_}]],
BraKet[a_ b_]:>a BraKet[b]/;NumericQ[a]||ListMemberQ[a,Flatten[{scalars,scalars^_}]],
BraKet[a_ ]:>a /;NumericQ[a]||ListMemberQ[a,Flatten[{scalars,scalars^_}]],(**)
BraKet[q1_,a_  q2_]:>a BraKet[q1,q2]/;NumericQ[a]||ListMemberQ[a,Flatten[{scalars,scalars^_}]],
BraKet[a_ q1_,  q2_]:>a BraKet[q1,q2]/;NumericQ[a]||ListMemberQ[a,Flatten[{scalars,scalars^_}]],

BraKet[q1_,a_+b_,q2_]->BraKet[q1,a,q2]+BraKet[q1,b,q2],
BraKet[q1_,a_ b_,q2_]:>a BraKet[q1,b,q2]/;NumericQ[a]||ListMemberQ[a,Flatten[{scalars,scalars^_}]],
BraKet[q1_, b_/a_,q2_]:>BraKet[q1,b,q2]/a/;NumericQ[a]||ListMemberQ[a,Flatten[{scalars,scalars^_}]],
BraKet[q1_,a_,q2_ ]:>a BraKet[q1,q2] /;NumericQ[a]||ListMemberQ[a,Flatten[{scalars,scalars^_}]],

Bra[a_]. (b_+c_) . Ket[d_]->Bra[a].b.Ket[d]+Bra[a].c.Ket[d],
Bra[a_] . (b_  c_) . Ket[d_]:>b Bra[a] . c . Ket[d]/;NumericQ[b]||ListMemberQ[b,Flatten[{scalars,scalars^_}]],
Bra[a_] . ( c_/b_) . Ket[d_]:> Bra[a] . c . Ket[d]/b/;NumericQ[b]||ListMemberQ[b,Flatten[{scalars,scalars^_}]],
Bra[a_]. (b_) . Ket[d_]:>b Bra[a].Ket[d]/;NumericQ[b]||ListMemberQ[b,Flatten[{scalars,scalars^_}]],
Bra[a_]. (1/b_) . Ket[d_]:>Bra[a].Ket[d]/b/;NumericQ[b]||ListMemberQ[b,Flatten[{scalars,scalars^_}]]
}
simpleBraKet[ scalars_List:{}]:=tuBraKetSimplify[scalars];
(*
Generates a list of Clifford algebra basis in Wedge form
assuming basis ed[i] for vector space V of dimension d.*)
WedgeClifBasis[d_]:=Module[{tmp},
tmp=Subsets[Map[ed[#]&,Table[i,{i,1,d}]]];
tmp=\[ScriptCapitalC]\[ScriptL][V[d],Q]->Map[If[Length[#]>1,Apply[Wedge,Sequence[#]],
If[Length[#]==1,#//First,Id[d]]
]&,tmp]
];
(*
Wedge Attributes *)
(*SetAttributes[Wedge,{Flat,OneIdentity,Listable,Protected}];*)
SetAttributes[Wedge,{Flat,OneIdentity,Listable}];
(**)
tuPositionNestDelete::usage="tuPositionNestDelete[position_List] reduces the result of Position\[Rule] position_List so that there is only top level positions. E.G. {{1,2}\[Rule]a,{1}\[Rule]r}\[Rule]{{1}->r} *18Jan2016*";
tuPositionNestDelete[position_List]:=Block[{$=position,$p=dup,$n,$t,i},
$p=$=Map[#&,Sort[$]];xPrint[$p];
(*Remove head position indices for test.*)
Do[
$t=$p[[i,1]];
$n=FirstPosition[$t ,0][[1]];(*Head index*)
$p[[i,1]]=$t[[1;;(If[NumericQ[$n ],$n-1,-1])]],
{i,Length[$p]}
];
(*delete subindices*)
Do[
If[MatchQ[SequencePosition[$p[[$j,1]],$p[[$i,1]]],{{1,___}}],
$[[$j]]=dup[$i,$[[$j]]]],
{$i,Length[$]-1},
{$j,$i+1,Length[$]}];
DeleteCases[$,dup[__]]
];
(**)
Clear[tuWedgeSimplify];
tuWedgeSimplify::usage="tuWedgeSimplify[scalar_List:{},product_:Times|dotOps][exp_] removes term in scalar_List from Wedge expressions in exp_. The scalar terms are product_ed together with the simplified Wedge expression. In the event that there is an isolated scalar in a Wedge expression it will be brought out of the expression. NOTE: The routine does not assume asymmetry of Wedge arguements. Inverse of scalars must be specified explicitly. *3Feb2016*";
tuWedgeSimplify[scalar_List:{},productOp_:Flatten[Times|dotOps]][exp_]:=Block[{$,$0=exp,$pos,$p,$s,$ps},
$pos=$0//tuExtractPositionPattern[Wedge[_,__]];xPrint["0: ",productOp];
Do[$=$pos[[i$,2]];xPrint[{i$,$}];
$=$//.{Wedge[ a___,((op:productOp)[b1___,c1_^(n_:1),b___]),f___]:>op[c1^n, Wedge[a,b1,b,f]]/;tuMemberQ[c1,scalar]||NumericQ[c1],
Wedge[ a___,c1_^(n_:1),f___]:>c1^n Wedge[a,f]/;tuMemberQ[c1,scalar]||NumericQ[c1]};
$pos[[i$,2]]=$;xPrint[$];
,{i$,Length[$pos]}];
tuReplacePart[$0,$pos]
];

(*
Simplifies Wedge expressions leaving Wedge arguement in canonical order *16July2012*)
SimpleWedge[exp_]:=Module[{tmp=exp,tmp0},
While[tmp0=!=tmp,
tmp0=tmp;
tmp=tmp/.Wedge[a___,Wedge[b__],c___]->Wedge[a,b,c];(*remove Wedge[Wedge[]]. Redundant with Attribute[OneIdentity].*)
tmp=tmp/.Wedge[a__]:>Signature[{a}]Wedge[Apply[Sequence,Sort[{a}]]]/;Length[Wedge[a]]>1;(*canonical ordering*)
(*remove Wedge of single variable*)
tmp=tmp/.Wedge[a_]:>a/;MemberQ[{Symbol,Tensor},Head[a]];
];
tmp
];
(*
ExpandWedge[scalar_List][exp_] expands Wedge product exp_ accounting for scalar_List.  *16July2012*)
WedgeSimplify[scalar_List][exp_]:=Module[{tmp=exp,sub,tmp0,xtmp},
While[tmp0=!=tmp,
tmp0=tmp;
tmp=tmp/.Wedge[a__]:>ExpandWedge[Wedge[a]];
tmp=tmp/.Wedge[c1___,a_,c2___,a_,c3___]:>0/;MemberQ[scalar,a];
(*move scalars out of Wedge[]*)
tmp=tmp//.Wedge[ a___,c1_  b_,f___]:>c1 Wedge[a,b,f]/;ListMemberQ[c1,scalar]||NumberQ[c1];
tmp=tmp//.Wedge[a___,c1_  ,b___]:>c1 Wedge[a  ,b]/;ListMemberQ[c1,scalar]||NumberQ[c1];
tmp=tmp//SimpleWedge;
];
tmp//ExpandAll
];
(*
ExpandWedge from ExpandNCM example. Not needed with SetAttributes above. *16July2012*)
ExpandWedge[(h:Wedge)[a___,b_Plus,c___]]:=Distribute[h[a,b,c],Plus,h,Plus,ExpandWedge[h[##]]&];
ExpandWedge[a_]:=ExpandAll[a];
(*
ExteriorDContract[scalars_List,constants_List][exp_] contracts ExteriorD[a_]PartialD[l_][b_,a_] \[Rule] ExteriorD[b] *16July2012*)
Clear[ExteriorDContract];
ExteriorDContract[exp_]:=exp//.HoldPattern [ExteriorD[a_]PartialD[l_][b_,a_]]->ExteriorD[b];
ExteriorDContract[scalars_List,constants_List][exp_]:=Module[{tmp=exp,tmp0,xtmp},
While[tmp0=!=tmp,
tmp0=tmp;
tmp=WedgeSimplify[Join[scalars,constants]][tmp];(*Expand Wedge ExteriorD[exp_]*)
tmp=tmp//ExteriorDContract;(*Contracts PartialD ExteriorD expressions *)
tmp=tmp//.ExteriorD[c1_ a__]:>Wedge[ExteriorD[c1],a]+c1 Wedge[a]/;ListMemberQ[c1,scalars];
tmp=tmp/.ExteriorD[a_]:>0/;ListMemberQ[a,constants];
];
tmp
];
(*
ExpandExteriorD0[scalars_List,constants_List][exp_] expands ExteriorD[] in exp_ based upon scalars_List,constants_List.  Overlaps with ExpandExteriorD. *17July2012*)
ExpandExteriorD0[scalars_List,constants_List][exp_]:=Module[{tmp=exp,tmp0,d=ExteriorD,xtmp},
While[tmp0=!=tmp,
tmp0=tmp;
tmp=tmp//WedgeSimplify[Join[scalars,constants]];
tmp=tmp/.d[a_  b__]:>Wedge[d[a],b]+Wedge[a, d[Times[b]]];
tmp=tmp/.d[d[a__ ]]->0;
tmp=tmp/.d[a_]:>0/;ListMemberQ[a,constants];
tmp=tmp/.d[Wedge[a_,b__]]:>Wedge[d[a],b]-Wedge[a,d[Wedge[b]]];
];
tmp
];
(*******)
(*
dDifForm[scalars_List,constants_List][exp_] computes the exterior derivative of exp_ accounting for scalars_List and constants_List.  *27Mar2013*)
dDifForm[scalars_List,constants_List][exp_]:=Module[{tmp=DifForm[exp],tmp0},
While[tmp0=!=tmp,
tmp0=tmp;
tmp=WedgeSimplify[Join[scalars,constants]][tmp];
tmp=tmp//.DifForm[a_ b__]:>Wedge[DifForm[a],b]/;ListMemberQ[a,scalars];
tmp=tmp//.DifForm[DifForm[a__ ]]->0;
tmp=tmp//\[Delta]Expand[DifForm,constants];
tmp=tmp//.DifForm[a_]:>0/;ListMemberQ[a,constants];
tmp=tmp//.DifForm[Wedge[a_,b__]]:>Wedge[DifForm[a],b]+(-1)^Length[{a}]Wedge[a,DifForm[Wedge[b]]];(*INCORRECT*)
tmp=tmp/.DifForm[Wedge[a_]]->Wedge[DifForm[a]];
];
tmp
];

(* stdDifForm may replace the need for this routine.
dDifFormX[constants_List,scalars_List,forms_List
][exp_] expands DifForm[] where constants_List,scalars_List,forms_List are specified.  
forms_List are as {{a,na},{b,nb}}} where na,nb are n-form values for a,b.  
Restrictions: a_ must not have Times[] operations only have ProductOp=Dot|xDot|Wedge.
Usage: exp_//.DifForm[a_]:>dDifFormX[constants_List,scalars_List,forms_List][a]
*31July2014*)
dDifFormX[constants_List,scalars_List,forms_List
][exp_]:=Module[{tmp,tmp0,pos,xdForm,dForms,ProductOp=Dot|xDot|CenterDot|Times,xtmp},
tmp=stdDifForm[constants,scalars,forms][exp];
xPrint["exp_:",tmp];
tmp=tmp//.(op:ProductOp)->Wedge;(**)
tmp=tmp/.Map[#[[1]]->dForm[#[[1]],#[[2]]]&,forms];
tmp=tmp/.dd:DifForm[a_]:>dForm[a,1]/;ListMemberQ[a,scalars];xPrint["B:",tmp];
tmp=SimplexWedge[constants,scalars,forms][tmp];
xPrint["C:",tmp];
(*Apply DifForm*)
tmp=DifForm[tmp];
tmp=tmp//\[Delta]Expand[DifForm];
tmp=tmp/.(op:ProductOp)->Wedge;
tmp=SimplexWedge[constants,scalars,forms][tmp];
xPrint["E:",tmp];
While[tmp0=!=tmp,tmp0=tmp;
tmp=tmp/.df:DifForm[a_]:>Distribute[df];
tmp=tmp/.Wedge->xWedge//.DifForm[xWedge[a_,b__]]:>xWedge[DifForm[a],b]+(-1)^nForm[a]xWedge[a,DifForm[xWedge[b]]]/.xWedge->Wedge;
xPrint["F:",tmp];
tmp=SimplexWedge[constants,scalars,forms][tmp];
xReturn[tmp];
];
xPrint["G:",tmp];(*
tmp=tmp//stdDifForm[constants,scalars,forms];*)
tmp=SimplexWedge[constants,scalars,forms][tmp];
xPrint["H:",tmp];
tmp
];
(*
SimplexWedge[constants_List,scalars_List,forms_List][exp_] simplifies Wedge, dForm, DifForm expressions in exp_.  Converts ProductOp[] into Wedge[]. The scalars/forms differences be sorted out from scalar_List. Return an expression that is { not Distributable in Wedge[], constants_List and scalars_List to the left of each term,
no Times[] terms
}.  exp_ can have a mix of DF's. All forms are specified by DF's. Used in dDifFormX[]. *31Jul2014*)
SimplexWedge[constants_List,scalars_List,forms_List][exp_]:=Block[{tmp=exp ,tmp0,DF={dForm,DifForm},formLabels=Map[#[[1]]&,forms],loop=0,ProductOp=Flatten[dotOps|Times|xWedge],a},
tmp=tmp//simpleDot3[{}];
(*Remove Times[],etc. *)
tmp=tmp/.ProductOp->Wedge;
tmp=tmp/.Wedge->xWedge;
(*move non-Form to the left==default position*)
xPrint["FF:",formLabels];
While[tmp0=!=tmp,
If[loop++>20,Print["loop limit:",tmp];Return[tmp]];
tmp0=tmp;
xPrint["Is:",tmp];
tmp=tmp//.xWedge[c0___,a_ , b_,c1___ ]:>xWedge[c0,b,a,c1]/;(ListFreeQ[b,DF]&&ListFreeQ[b,formLabels])&&!(ListFreeQ[a,DF]&&ListFreeQ[a,formLabels])&&ListFreeQ[a,constants];
xPrint["Hs:",tmp];
tmp=tmp//.xWedge[a_]:>a/;Length[{a}]==1;(*avoid Wedge Pattern match problem*)
tmp=tmp/.xWedge[c1___,df:DifForm[a_]|dForm[a_,1],c2___,df:DifForm[a_]|dForm[a_,1],c3___]:>0/;df===dForm[a,1];
xPrint["Js:",tmp];
(*Simplification of DifForm[] expressions*)
tmp=tmp/.df:DifForm[a_]:>Distribute[df];
tmp=tmp//\[Delta]Expand[DifForm];(*Err: DifForm[xWedge[]]*)
(*CHECK*)
tmp=tmp//.(op:DerivOps )[xWedge[a_, c__],b_]->xWedge[op[a,b],c]+ xWedge[a,op[ xWedge[c],b]];
tmp=tmp//.dd:DerivOps [a_,b_]:>DerivativeExpand[constants][dd]/;ListFreeQ[a,DF]&&ListFreeQ[a,formLabels];
(*CHECK*)
tmp=tmp/.DifForm[a_]|dForm[a_,1]:>0/;MemberQ[constants,a];tmp=tmp/.DifForm[DifForm[a_ ]|dForm[a_,_]]:>0/;ListMemberQ[a,scalars];
tmp=tmp/.DifForm [a_^n_]:>xWedge[n , Apply[Sequence,Table[a^(Sign[n]1),{Abs[n-1]}]],dForm[a,1]]/;ListMemberQ[a,scalars];
tmp=tmp//.xWedge[a_]:>a/;Length[{a}]==1;
tmp=tmp//.DifForm[xWedge[a_,b__]]:>xWedge[DifForm[a],b]+(-1)^nForm[a]xWedge[a,DifForm[xWedge[b]]];
tmp=tmp/.ProductOp->Wedge/.Wedge->xWedge;
xPrint["Es:",tmp];
];
tmp//.xWedge->Wedge
];
(**)
Clear[tuDifFormSimplify]
tuDifFormSimplify::usage="tuDifFormSimplify[constants_List,scalars_List,forms_List,flags_List][exp_] puts DifForm[] expressions into standard form where 0-Forms are to the left of the other terms. ProductOp's between n-Forms are considered Wedge[] products.  constants_List,scalars_List,forms_List are inputs that determine how terms are manipulated.  forms_List are in a form {f1->n1,f2->n2} where f1,f2 are labels to n1,n2-Forms in expressions, respectively. Functions specified by form fn[arg] in flags_List are expanded. Other flags: {NoSymmetric->zeros symmetric Wedge[]s, }. xPartialD[DifForm[a_],a_]\[Rule]0 Rule[] is considered. In Development. *22Jan2016";tuDifFormSimplify[constants_List:{},scalars_List:{},forms_List:{},flags_List:{}][exp_]:=Module[{tmp=exp,tmp0,pos,xdForm,dForms,ProductOp=Flatten[Times|dotOps|xWedge],DF={dForm,DifForm},formLabels=Map[#[[1]]&,forms]},
(*Standard 0-form on left*)
(* Label forms_List *)
xPrint["exp_:",tmp];
While[tmp=!=tmp0,tmp0=tmp;
tmp=tmp//.tuOpSimplify[ProductOp];
tmp=tmp//.ProductOp->Wedge;
tmp=tmp/.DifForm[ff:fn_[aa_]]:>tuDPartial[ff,aa]\[CenterDot]DifForm[aa]/;MemberQ[flags,fn[]]&&AtomQ[aa];
(*single arguement function expand*)
tmp=tmp/.tuDPartial[DifForm[a_],a_]->0;(*TEST*)
tmp=tmp/.df:DifForm[a_]:>Distribute[df];
tmp=tmp/.Map[ff:#[[1]]->dForm[ff,#[[2]]]&,forms];
tmp=tmp/.dd:DifForm[a_]:>dForm[a,1]/;tuMemberQ[a,scalars];xPrint["Bs:",tmp];
tmp=SimplexWedge[constants,scalars,forms][tmp];
xPrint["Cs:",tmp];
(*put scalars in Dot expression*)tmp=tmp//.Wedge[a_,b__]:>CenterDot[a ,  Wedge[b]]/;ListFreeQ[a,DF]&&ListFreeQ[a,formLabels];
xPrint["Dstd:",tmp];
tmp=tmp//.CenterDot[a__ ,ww:Wedge[_]]:>CenterDot[Times[a],ww]/.Times->CenterDot;
xPrint["Estd:",tmp];
tmp=tmp/.Wedge->xWedge//.xWedge[a_]:>a/;Length[{a}]==1/.xWedge->Wedge;
tmp=tmp/.ww:Wedge[_]:>OrderdFormWedge[ww];
(*return to input notation*)
tmp=tmp/.dForm[a_,1]:>DifForm[a]/;ListMemberQ[a,scalars];
tmp=tmp/.dForm[a_,_]:>a/;tuMemberQ[a,formLabels];
tmp=tmp//.tuOpSimplify[ProductOp]
];
tmp=If[MemberQ[flags,KeepSymmetric],tmp,WedgeSimplify[{}][tmp]];
tmp=tmp//.tuOpSimplify[ProductOp,scalars]
];
(*Work out later*)
(**)
Clear[tuStdDifForm]
tuStdDifForm::usage="tuStdDifForm[constants_List,scalars_List,forms_List,flags_List][exp_] puts DifForm[] expressions into standard form where 0-Forms are to the left of the other terms. ProductOp's between n-Forms are considered Wedge[] products.  constants_List,scalars_List,forms_List are inputs that determine how terms are manipulated.  forms_List are in a form {{f1,n1},{f2,n2}} where f1,f2 represent n1,n2-Form form expressions, respectively. Functions specified by form fn[arg] in flags_List are expanded. Other flags: {NoSymmetric->zeros symmetric Wedge[]s, }. xPartialD[DifForm[a_],a_]\[Rule]0 Rule[] is considered. *01Aug2014";
tuStdDifForm[constants_List,scalars_List,forms_List,flags_List:{}][exp_]:=Module[{tmp=exp,tmp0,pos,xdForm,dForms,ProductOp=Times|Dot|xDot|xWedge|CenterDot,DF={dForm,DifForm},formLabels=Map[#[[1]]&,forms]},
(*Standard 0-form on left*)
(* Label forms_List *)
xPrint["exp_:",tmp];
While[tmp=!=tmp0,tmp0=tmp;
tmp=tmp//simpleDot3[{}];
tmp=tmp//.ProductOp->Wedge;
tmp=tmp/.DifForm[ff:fn_[aa_]]:>tuDPartial[ff,aa].DifForm[aa]/;MemberQ[flags,fn[]]&&AtomQ[aa];
(*function expand*)
tmp=tmp/.tuDPartial[DifForm[a_],a_]->0;(*TEST*)
tmp=tmp/.df:DifForm[a_]:>Distribute[df];
tmp=tmp/.Map[ff:#[[1]]->dForm[ff,#[[2]]]&,forms];
tmp=tmp/.dd:DifForm[a_]:>dForm[a,1]/;ListMemberQ[a,scalars];xPrint["Bs:",tmp];
tmp=SimplexWedge[constants,scalars,forms][tmp];
xPrint["Cs:",tmp];
(*put scalars in Dot expression*)tmp=tmp//.Wedge[a_,b__]:>Dot[a ,  Wedge[b]]/;ListFreeQ[a,DF]&&ListFreeQ[a,formLabels];
xPrint["Dstd:",tmp];
tmp=tmp//.Dot[a__ ,ww:Wedge[_]]:>Dot[Times[a],ww]/.Times->Dot;
xPrint["Estd:",tmp];
tmp=tmp/.Wedge->xWedge//.xWedge[a_]:>a/;Length[{a}]==1/.xWedge->Wedge;
tmp=tmp/.ww:Wedge[_]:>OrderdFormWedge[ww];
(*return to input notation*)
tmp=tmp/.dForm[a_,1]:>DifForm[a]/;ListMemberQ[a,scalars];
tmp=tmp/.dForm[a_,_]:>a/;ListMemberQ[a,formLabels];
tmp=tmp//simpleDot3[{}]
];
tmp=If[MemberQ[flags,KeepSymmetric],tmp,WedgeSimplify[{}][tmp]];
tmp=tmp//simpleDot3[scalars]
]
stdDifForm[constants_List,scalars_List,forms_List][exp_]:=tuStdDifForm[constants,scalars,forms,{}][exp];

(**)
tuDifFormCnt::usage="tuDifFormCnt[forms_List:{}][wedgeform_List] determines the DifForm n-form value in wedgeform_List, which is a List of arguements of a Wedge expression. forms_List specifies non-default n-form values of terms in wedgeform_List as {A\[Rule]n,B\[Rule]m}. Explicit DifForms are accepted.  Default n-Form value is 1. *18Jan2016*";
tuDifFormCnt[forms_List:{}][wedgeform_List]:=Block[{$=wedgeform,$s,ret,tmp},xPrint["tuDifFormCnt:",{forms,wedgeform}];
$=$/.forms;
$=$//.DifForm[n_]->n+1;xPrint[$];
$=#/.a_:>1/;!NumberQ[a]&/@$;xPrint[$];
$=Apply[Plus,$]
];
(**)
Clear[tuDifFormExpand]
tuDifFormExpand::usage="tuDifFormExpand[scalars_List:{},constants_List:{},forms_List:{},product_:Times][exp_] expands DifForm's in exp_.forms_List specifies non-(default\[Rule]1) n-form values of terms in exp_ as {A\[Rule]n,B\[Rule]m}.*18Jan2016*";
tuDifFormExpand[scalars_List:{},constants_List:{},forms_List:{},product_:Times][exp_]:=Block[{tmp=exp,tmp0},
While[tmp0=!=tmp,
tmp0=tmp;
tmp=tmp/.tuOpDistribute[DifForm];
tmp=tmp//.DifForm[a_]:>0/;(tuMemberQ[a,constants]||NumericQ[a]);

tmp=tmp//.DifForm[(pp:product)[a_,b__] ]:>pp[a,DifForm[b]]/;(tuMemberQ[a,constants]||NumericQ[a]);
tmp=tmp//.DifForm[(pp:product)[a__,b_]]:>pp[DifForm[a],b]/;(tuMemberQ[b,constants]||NumericQ[b]);

tmp=tmp//.DifForm[(pp:product)[a_,b_]]:>Wedge[DifForm[a],b]+Wedge[a,DifForm[b]]/;tuMemberQ[a,scalars]||tuMemberQ[b,scalars];(*Is this too simplistic*)

tmp=tmp//.DifForm[Wedge[a_,b__]]:>Wedge[DifForm[a],b]+(-1)^tuDifFormCnt[forms][{a}]Wedge[a,DifForm[Wedge[b]]];

tmp=tmp//.DifForm[DifForm[a__ ]]->0;
tmp=tmp/.Wedge->xWedge/.xWedge[a_]->a/.xWedge->Wedge(*Attribute[Wedge] don't work.*)
];
tmp
];
(**)
tuDifFormFunctionExpand::usage="tuDifFormFunctionExpand[function_List][exp_] expands DifForm[]s in exp_ if DifForm[]s contain functions in function_List. The functions are expanded via tuDPartial through their argument list.  EG: DifForm[A[r]] \[Rule]tuDPartial[A[r],r] \[CenterDot]DifForm[r]. *21Jan2016*";
tuDifFormFunctionExpand[function_List][exp_]:=Block[{$=exp,$p},
$p=$//tuExtractPositionPattern[DifForm[_]];
$p=Select[$p,tuHasAnyQ[#,function]&];Print[$p];
$p=$p/.DifForm[(fn:Apply[Alternatives,function])[arg__]]:>Plus@@Map[tuDPartial[fn[arg],#]DifForm[#]&,{arg}];
tuReplacePart[$,$p]
];

(*
OrderdFormWedge[exp_Wedge] canonically orders Wedge expression accounting for n-Forms permutations *4Aug2014*)
OrderdFormWedge[exp_Wedge]:=Module[{tmp=exp,tmp0},
tmp=tmp/.Wedge->xWedge;
While[tmp=!=tmp0,tmp0=tmp;
xPrint["OO:",tmp];
tmp=tmp/.xWedge[c0___,a_,b_,c1___]:> xWedge[c0,(-1)^nForm[a] b,a,c1]/;!OrderedQ[{a,b}];
tmp=tmp/.xWedge->Wedge/.Wedge->xWedge(*use Wedge simplification*)
;xReturn[tmp];
];
tmp/.xWedge->Wedge
];
(*
nForm[a_] sums n_ of dForm[_,n]'s in a_. Used in dDifFormX[]. *31July2014*)
nForm[a_]:=Module[{ret,tmp},xPrint["nForm:",a];
tmp=a/.DifForm[b_]:>dForm[b,1];
ret=ExtractPattern[dForm[__]][tmp]/.dForm[_,n_]->n//Apply[Plus,#]&;
ret=If[Head[ret]===List,ret[[1]],ret];
xPrint["nForm:ret:",ret];
ret
];
(*TESTs*)
(* 
DifForm[\[Omega]];
%//stdDifForm[{},{\[CapitalLambda]},{{\[Omega],1}}]*)
(*
$=DifForm[a.c.x+Wedge[\[Omega],a]+DifForm[a].x]
$//stdDifForm[{},{c,x,\[Xi]},{{\[Omega],3},{a,1}}]
DifForm[(1/r).DifForm[r]]
%//stdDifFormX[{},{r},{}]*)

(**************************)
(*Inserts right arguement into operator style xPartialD into xPartialD.
xPartialD[_,mu].RightArguement -> xPartialD[RightArugement,mu]
*)
OperateDotRight=Dot[a___,c___ xPartialD[HoldPattern[_],mu_],b_]->Dot[a,c xPartialD[b,mu]];

(*Forms dot product of Tensor ku_ over index m_*)
dot2[ku_,m_]:=ku.LowerIndex[m,m][ku];

(**)
tuDIndexOrder::usage="tuDIndexOrder[index_List] Rule[]s for canonically ordering indices in index_List of double derivatives *12Jan2016*";
tuDIndexOrder[index_List]:={
(pp1:tuDDown[s_]|tuDUp[s_])[(pp2:tuDDown[s_]|tuDUp[s_])[a_,i_],j_]:>pp2[pp1[a,j],i]/;allMemberQ[{i,j},index]&&OrderedQ[{i,j}] 
};
orderxPartialD:=tuDIndexOrder;(*Compatibility*)

(* permutes xPartialD variables *)
xPartialDPermute[a_,b_]:=xPartialD[xPartialD[v_,b],a]->xPartialD[xPartialD[v,a],b];

(* Permutes IntegralOp's *)
IntegralOpPermute:=IntegralOp[a_,IntegralOp[b_,c_]]->IntegralOp[b,IntegralOp[a,c]];
(**)
tuSeparateIntegralOpVar::usage="tuIntegralOpInnerVar[var_List][int_IntegralOp] separates int_IntegralOp into two IntegralOp with variables not FreeQ of var_List in inner IntegralOp  *6Dec2012*";
tuSeparateIntegralOpVar[var_List][int_IntegralOp]:=Block[{ivars,integrand,tmp},
{ivars,integrand}=Apply[List,int];
xPrint[var,ivars];
tmp=int/.IntegralOp[a_,b_]:>IntegralOp[Select[a,ListFreeQ[#,var]&],IntegralOp[Select[a,!ListFreeQ[#,{var}]&],b]];
tmp
];
IntegralOpInnerVar[var_List][int_IntegralOp]:=tuSeparateIntegralOpVar[var][int];
(*
separateIntegralOp Rule for separating multiple IntegralOp's.*)
separateIntegralOp:=IntegralOp[a_List,b_]:>If[Length[a]>1,IntegralOp[Most[a],IntegralOp[{Last[a]},b]]]
(*
IntegralOpInnerVar[var_List][int_IntegralOp] separates int_IntegralOp into two IntegralOp with variables not FreeQ of var_List in inner IntegralOp  *6Dec2012*)
IntegralOpInnerVar[var_List][int_IntegralOp]:=Module[{ivars,integrand,tmp},
{ivars,integrand}=Apply[List,int];
xPrint[var,ivars];
tmp=int/.IntegralOp[a_,b_]:>IntegralOp[Select[a,ListFreeQ[#,var]&],IntegralOp[Select[a,!ListFreeQ[#,{var}]&],b]];
tmp
];
(*
timespaceIntegralOpVar[var_,index_][int_IntegralOp] takes all var_ in the int_IntegralOp variables and separates their index_ variable into time and space components.  *7Dec2012*)
timespaceIntegralOpVar[var_,index_][int_IntegralOp]:=Module[{ivars,integrand,ivar0,ivar1,ivar10,ivar11},
{ivars,integrand}=Apply[List,int];
xPrint[var,ivars];
ivar0=Select[ivars,ListFreeQ[#,{var}]&];
ivar1=Select[ivars,!ListFreeQ[#,{var}]&];
xPrint[var,ivar1];
ivar10=ivar1/.var:>IndexChangeTU[{index,timespace@0}][var];
ivar11=ivar1/.var:>IndexChangeTU[{index,timespace@1}][var];
IntegralOp[Flatten[{ivar0,ivar10,ivar11},1],integrand]
];
(*
subtimespaceSum[index_] Rule that separates UpDn index_ of Tensor product into sum of products of timespace@0 and timespace@1 Tensors. *7Dec2012*)
subtimespaceSum[index_]:=
Tensor[a_,au_List,ad_List]Tensor[b_,bu_List,bd_List]:>Tensor[a,(au/.index->timespace@0),ad]Tensor[b,bu,(bd/.index->timespace@0)]+
Tensor[a,(au/.index->timespace@1),ad]Tensor[b,bu,(bd/.index->timespace@1)]/;MemberQ[au,index]&&MemberQ[bd,index]
(*
sub\[Delta]func[var_] converts \[Delta][func_[var_] ] to \[Delta][ var_- fn[] ]/Abs[D,var].  NOTE: There is a difference if UpDn contractions are used in func_ of a factor of 2 and Sqrt[].  Only uses last Solve[] result. Also, only for scalar var_.  *8Dec2012*)
sub\[Delta]func[var_]:=\[Delta][func_]:>\[Delta][$$t=Solve[func==0,var][[-1,1]];$$t[[1]]-$$t[[2]]]/Abs[D[func,var]]/;!FreeQ[func,var];
(*
integrate\[Delta]func[var_] applies the relation  DiracDelta[f[x]]\[Equal]Sum[DiracDelta[x-Subscript[x,j]]/Abs[Derivative[1][f][Subscript[x,j]]],{j,1,n}]/;f[Subscript[x,j]]\[Equal]0&&Derivative[1][f][Subscript[x,j]]\[NotEqual]0 
to IntegralOp[var_, \[Delta][func_[var_]] other_ ] -> x\[Delta][var_->fn] other_ / Abs[D[func_,var_].  The x\[Delta][var_->fn] indicates that the integration has been appled and var_->fn is a relationship that must be maintained.
NOTE: There is a difference if UpDn contractions are used in func_ of a factor of 2 and Sqrt[].  Only uses last Solve[] result.  Also, only for scalar var_.    *5May2014*)
integrate\[Delta]funcRule[var_]:=IntegralOp[{{var}},(other_:1)  \[Delta][func_]]:>(other x\[Delta][$$t=Solve[func==0,var][[-1,1]]]/Abs[D[func,var]]/.$$t/.x\[Delta][_]->1)/;!FreeQ[func,var];
(*
integrate\[Delta]funcRule1[var_List][exp_] perform integration where the integrand contains \[Delta][func_].  Mathematica Integrate is used.
var_List is integration variable with limits to distinquish the integral, e.g. {x,-\[Infinity],\[Infinity]}, in multi-integral situation. The result may need further manipulation.  Replaces integrate\[Delta]funcRule. *23Jul2014*)
integrate\[Delta]funcRule1[var_List][exp_]:=Module[{tmp,terms},
tmp=ExtractPositionPattern[exp,IntegralOp[{var},_]];
tmp=
tmp/.\[Delta][a_]:>DiracDelta[a]/;!FreeQ[a,var[[1]]]/.subxIntegrate/.subIntegrate;
ReplacePartTU[exp,tmp]
];

(*TU*)
tuIntegrate\[Delta]func::usage="tuIntegrate\[Delta]func[var_][exp_IntegralOp] 'integrates' exp_IntegralOp over var_ if var_ is contained in \[Delta][] by Solve[]ing the integrand at Arguement[\[Delta][]]->0. NOTE: does not check for valid range of var_. EG: exp/.ii:IntegralOp[_,_]:>integrate\[Delta]func[\!\(\*SubscriptBox[\(x\), \(3\)]\)][ii] *2Jan2015*";
tuIntegrate\[Delta]func[var_][exp_IntegralOp]:=Module[{tmp=exp,vars,intvar,integrand,dfuncs,dfunc,df,$$t,x\[Delta]},
{vars,integrand}=Apply[List,tmp];
dfuncs=ExtractPattern[\[Delta][_]][integrand];
If[FreeQ[vars,var]||FreeQ[dfuncs,var],Return[exp]];(*no OP var*)
intvar=Cases[vars,{var,___}]//First;
vars=DeleteCases[vars,intvar];
(*use first \[Delta][] with var*)
df=Select[dfuncs,!FreeQ[#,var]&][[1,1]];
integrand=integrand/.(other_:1)  \[Delta][df]:>(other  x\[Delta][$$t=Solve[df==0,var][[-1,1]]]/Abs[D[df,var]]/.$$t/.x\[Delta][_]->1);
If[Length[vars]>0,IntegralOp[vars,integrand],integrand]
];
integrate\[Delta]func[var_][exp_IntegralOp]=tuIntegrate\[Delta]func[var][exp];

(*
integrate\[Delta]funcUpDn[var_] does the same as integrate\[Delta]func[var_] except that convert any UpDn var_ pairs to var_ pairs.   *4May2014*)
integrate\[Delta]funcUpDn[var_,index_][exp_IntegralOp]:=Module[{tmp=exp,subupdn},
subupdn=var UpDownIndexSwap[index][var]->var var;
tmp=tmp//.subupdn;
xPrint[subupdn,tmp];
tmp/.IntegralOp[{{var}},other_ \[Delta][func_]]:>(other x\[Delta][$$t=Solve[func==0,var][[-1,1]]]/Abs[D[func,var]]/.$$t/.x\[Delta][_]->1)/;!FreeQ[func,var]
];

(* Print routine for DEBUGing Modules.  *)
IfDEBUG[name_,DEBUG_,list_,comment_]:=Module[{},
If[DEBUG==True,
Print[name,":",comment,":",list];
];
];

(*Factors exp_ in form 1/(A_ B) into 1/A-1/B form. *)
FactorABinv[exp_,A_]:=Module[{Binv,B,tmp,numer=Numerator[exp]},
B=1/(A exp/numer//Simplify);
tmp=(1/A-1/B)/(B-A);
tmp=numer tmp(B-A)
];

(*Factors exp_ in form (1/A).(1/B) into 1/A-1/B form. *)
FactorDotABinv[exp_]:=Module[{A,Binv,B,tmp,numer=Numerator[exp]},
A=1/First[exp];
B=1/Last[exp];
tmp=B-A/.Dot->Times//Expand//SimplifyTensorSum//UpDownAdjust;
tmp=(1/A-1/B)/tmp
];

(*ReplaceVariableNames{} replaces exp_ with standard set of variables of form S$nnnn for manipulation. *)
StandardVariableNames[exp_]:=Module[{tmp=exp,list},
list=tmp/.Dot|Times|Plus|Power->List//Flatten;
list=Select[list,!NumericQ[#]&]//Union;
Map[{#->Unique[S]}&,list]//Flatten
];

(**)
tuExtractPattern::usage="tuExtractPattern[pattern_,maxlevel_:Infinity][exp_] extracts a List of items in exp_ that match pattern_ to maxlevel_. *3Feb2014* ";
tuExtractPattern[pattern_,maxlevel_:Infinity][exp_]:=Module[{pos},
pos=Position[exp,pattern,{0,maxlevel}];
Extract[exp,pos]
];
ExtractPattern:=tuExtractPattern

(*
ExtractPatternXpat[pattern_][exp_] extracts pattern_ or pattern_List from exp_ and outputs lists of matches to {Xpat[pattern_]} and {exp_} where Xpat[pattern_] was found.  Avoids the Times[] difficulty with Position[].  *26Jul2013*)
ExtractPatternXpat[pattern_][exp_]:=Module[{tmp=exp,$i,test,$pat={},list,sub,$npat,$ii,xpat,ipat,patterns,testpat},
patterns=Flatten[{pattern}];
For[$i=1,test=!=tmp,$i++,
Do[(*for every pattern*)
test=tmp;
tmp=tmp/.(pp:patterns[[ipat]]):>xpat[Last[AppendTo[$pat,Xpat[pp]]]];
tmp=tmp/.xpat[_]:>$npat[Length[$pat]],
{ipat,Length[patterns]}
]
];
For[$ii=1,$ii<=Length[$pat],$ii++,
tmp=tmp/.$npat[$ii]:>$pat[[$ii]]
];
{$pat,tmp}
];
(*
keepPlusTerms[ext_][exp_] keeps terms in Plus[] that are not FreeQ of ext_ *25Oct2014*)
keepPlusTerms[ext_][exp_]:=Block[{},exp/.Plus->xPlus/.xx:xPlus[a__]:>Select[xx,!FreeQ[#,ext]&]/.xPlus->Plus
];
(*Applies function_ to Tensor products in Times expression exp_.*)
ApplyToTensorProductOnly[function_,exp_Times]:=Module[{tmp,tmpt,tmpa},
tmp=Apply[List,exp];
tmpt=Map[If[Head[#]===Tensor,#,1]&,tmp];
tmpa=Map[If[Head[#]===Tensor,1,#]&,tmp];
tmpt=function[Apply[Times,tmpt]];
tmpa=Apply[Times,tmpa];
tmpa tmpt
];
(*returns Tensor product terms in Times expression exp_.*)
TensorProductOnly[exp_Times]:=Module[{tmp},
tmp=Apply[List,exp];
tmp=Map[If[Head[#]===Tensor,#,1]&,tmp];
tmp=Apply[Times,tmp]
];
(*returns Position->Patterns of Tensor products *)
ExtractTensorProducts[exp_]:=Module[{tmp},
tmp=ExtractPositionPattern[exp,Times[a___,Tensor[___],b___]];
Map[MapAt[TensorProductOnly[#]&,#,2]&,tmp]
];
(*apply function_ to Tensor products in exp_.*)
ApplyToTensorProducts[function_,exp_]:=Module[{tmp},
tmp=ExtractPositionPattern[exp,Times[a___,Tensor[___],b___]];
tmp=Map[MapAt[ApplyToTensorProductOnly[function,#]&,#,2]&,tmp];
ReplacePart[exp,tmp]
];

(**)
tuExtractPositionPattern::usage="tuExtractPositionPattern[pattern_,maxlevel_:Infinity][exp_] extracts a List of {Positions,items} that match pattern_ in exp_ up to Level maxlevel_.  Returns a List[ pos1->match1,pos2->match2,... ]  *3Feb2014*)";
tuExtractPositionPattern[pattern_,maxlevel_:Infinity][exp_]:=Module[{pos,list,tmp},
If[Head[pattern]=!=List,(*not List of patterns*)
pos=Position[exp,pattern,{0,maxlevel}];
list=Extract[exp,pos];
tmp=Thread[Rule[pos,list]],(*List of patterns*)
tmp=Map[ExtractPositionPattern[exp,#,maxlevel]&,pattern]//Flatten;
xPrint[exp,pattern,tmp];
];
tmp
];
ExtractPositionPattern[exp_,pattern_,maxlevel_:Infinity]:=tuExtractPositionPattern[pattern,maxlevel][exp];

(*ReplaceExtract returns extract_List second items with repl_List*)
ReplaceExtract[extract_List,repl_List]:=Module[{},
MapThread[Rule[First[#1],#2]&,{extract,repl}]
];

(*Tests exp_ to be FreeQ of any patterns_.*)
FreePattern[exp_,patterns_List]:=And@@Map[FreeQ[exp,#]&,patterns];

(*Runs Collect after substituting for matched patterns.  The pattern may be of form P1|P2.  Patterns involving Times do not work, e.g. pattern_-> Tensor[a_,b_,c_]Tensor[d_,e_,f_]
One way around it is to use substitution first:
sub=Tensor[a_,b_,c_]Tensor[d_,e_,f_]\[Rule]Tensor2[a,b,c,d,e,f];
subr=RuleX1[sub, Tensor2[___],{a,b,c,d,e,f}]; \[LongLeftArrow]reverse substitution
tmp=tmp/. sub;
CollectPattern[tmp,Tensor2[___]]/.subr
*)
CollectPattern[exp_,pattern_]:=Module[{pos=Position[exp,pattern],tmp,varlist,sub,uvar},
varlist=Extract[exp,pos]//Union;
uvar=Map[Unique[]&,varlist];
sub=MapThread[Rule,{varlist,uvar}];
tmp=exp/.sub;
tmp=Collect[tmp,uvar];
tmp/.Map[Reverse[#]&,sub]
];


(*Extract from Dot[] expression elements that do not match any of the patterns. Usage: DotKeepPattern1[patternlist][expression].  Returns (nokeeps) Dot[ keeps ]*)
DotKeepPattern1[patterns_][exp_]:=
Module[{tmp=exp,dot,times,test,dots,pos,repl={},i,DEBUG=0},
DotExpandMode[False];
IfDEBUG["DotKeepPattern",DEBUG>0,{exp},"exp"];
pos=Position[exp,HoldPattern[Dot[__]]];
dots=Extract[exp,pos];
For[i=1,i<=Length[dots],i++,
dot={};
tmp=dots[[i]];
IfDEBUG["DotKeepPattern",DEBUG>0,{i,tmp},"{i,tmp}"];
tmp=tmp//.Times->Dot;
tmp=Apply[List,tmp];
test=Map[FreePattern[#,patterns]&,tmp];
times=Pick[tmp,test,True];
times=Apply[Times,times];
dot=Pick[tmp,test,False];
dot=If[Length[dot]>0,Apply[Dot,dot],1];
AppendTo[repl,pos[[i]]->(times dot)];
];
tmp=ReplacePart[exp,repl]
];
(******)

(*Extracts terms in DotExp_ that do not match patterns_ in Dot[]->(no match) Dot[match].  Doesn't work for Power[a b,n m].
*)
DotPatternIn[patterns_][DotExp_]:=Module[{tmp=DotExp,test,times,dot,DEBUG=0},
IfDEBUG["DotPattern",DEBUG>0,{patterns,tmp},"{tmp}"];
tmp=Expand[tmp]//.Times|Dot->List//Flatten;
IfDEBUG["DotPattern",DEBUG>2,{tmp},"{tmp}"];
test=Map[FreePattern[#,patterns]&,tmp];
IfDEBUG["DotPattern",DEBUG>2,{test},"{test}"];
times=Pick[tmp,test,True];
times=Apply[Times,times];
dot=Pick[tmp,test,False];
dot=If[Length[dot]>0,Apply[Dot,dot],1];
IfDEBUG["DotPattern",DEBUG>2,{times,dot},"{times,dot}"];
tmp=times dot;
IfDEBUG["DotPattern",DEBUG>0,{tmp},"result"];
tmp
];

(*4.25.10*)
DotPatternIn1[patterns_][DotExp_]:=Module[{tmp=DotExp,test,times,dot,DEBUG=0},
IfDEBUG["DotPattern",DEBUG>0,{patterns,tmp},"{input}"];
tmp=Expand[tmp]//.Times|Dot->xDot//Flatten;
IfDEBUG["DotPattern",DEBUG>2,{tmp},"{tmp}"];
test=Map[FreePattern[#,patterns]&,tmp];
IfDEBUG["DotPattern",DEBUG>2,{test},"{test}"];
times=Pick[tmp,test,True];
times=times/.xDot->Times;
dot=Pick[tmp,test,False];
dot=If[Length[dot]>0,dot/.xDot->Dot,1];
IfDEBUG["DotPattern",DEBUG>2,{times,dot},"{times,dot}"];
tmp=times dot;
IfDEBUG["DotPattern",DEBUG>0,{tmp},"result"];
tmp
];

(*4.9.2010*)
DotKeepPattern[patterns_][exp_]:=
(*Extract from Dot[] expression elements that do not match any of the patterns. 
Usage: DotKeepPattern[patternlist][expression].
  Returns expression with Dot[]'s->
(nokeeps) Dot[ keeps ].  This is a frontend routine expands xPartialD's and eliminates remembering HoldPattern[] on Dot[__]. *)
Module[{tmp,dot,times,test,dots,pos,DEBUG=0},
DotExpandMode[True];
IfDEBUG["DotKeepPattern",DEBUG>0,{exp},"input"];
tmp=exp/.xPartialD[a_,b_]:>xPartialDDot[a,b];
pos=Position[tmp,HoldPattern[Dot[__]]];
IfDEBUG["DotKeepPattern",DEBUG>0,{pos},"pos"];
tmp=MapAt[DotPatternIn1[patterns],tmp,pos];
(*Apply twice to clean up*)
pos=Position[tmp,HoldPattern[Dot[__]]];
IfDEBUG["DotKeepPattern",DEBUG>0,{pos},"pos"];
tmp=MapAt[DotPatternIn1[patterns],tmp,pos]
];

(*
Solves for pattern_ in EqualExp_. Returns solution using first variable from ExtractPositionPattern[_,pattern]  *19Oct2013*)
Solve4Pattern[EqualExp_,pattern_]:=Module[{tmp=EqualExp/.Rule->Equal,pos,posd},
pos=ExtractPositionPattern[tmp,pattern];
posd=Map[#[[1]]->$$XX&,pos];
tmp=ReplacePart[tmp,posd];
tmp=Solve[tmp,$$XX][[1]];
tmp=tmp/.$$XX->pos[[1,2]](*Substitute for only first variable.*)
];
(*
Simpler version of above.  Forgot why previous one was rewritten that way. *6Sep2012*)
(*Solve4Pattern[EqualExp_,pattern_]:=Module[{tmp=EqualExp/.Rule->Equal,$XX},
tmp=tmp//.pattern\[Rule]$XX;
tmp=Solve[tmp,$XX];
tmp=tmp/.$XX\[Rule]pattern
];*)
(*
Solves for pattern_ in RuleExp_ 29June2012 *)
Rule4Pattern[RuleExp_,pattern_]:=Module[{tmp=RuleExp,patList,$X},
tmp=tmp/.Rule->Equal;
patList=ExtractPattern[pattern][tmp];
xPrint[patList];
tmp=tmp/.pattern->$X;
tmp=Solve[tmp,$X];
tmp=tmp/.$X->patList[[1]]
];
(*
MatrixSubs applies Rules->sublist_ to matrix equation where Plus[] is disabled.  The auto-evaluation of Plus[] creates unwanted results. *)
MatrixSubs[exp_,sublist_]:=Module[{tmp=exp,i,DEBUG=0},
tmp=tmp/.Plus->xPlus;
IfDEBUG["MatrixSubs",DEBUG>0,{tmp},"tmp"];
Do[
tmp= ReplaceAll[tmp,sublist[[i]]],
{i,Length[sublist]}];
tmp=tmp/.xPlus->Plus
];

(*EvenPowers eliminates odd powers of var_List in exp_.*)
EvenPowers[var_List][exp_]:=Module[{sub,tmp,delete,n,V,L},
{V,L}=Unique[{V,L}];
sub=Map[Rule[V:#,L V]&,var];
tmp=exp/.sub;
tmp=CoefficientList[tmp,L];
delete=Range[2,Length[tmp],2];
tmp=Delete[tmp,{delete}];
Apply[Plus,tmp]
];
(*IntegralOpDeleteOddPowers deletes odd powers of var_List from the deepest level IntegralOp in exp_ *)
IntegralOpDeleteOddPowers[var_List][exp_]:=Module[{tmp=exp,tmpe,tmpd,tmpn},
tmpe=ExtractIntegrand[tmp];
tmpd=tmpe[[2,1]]//Denominator;
tmpn=tmpe[[2,1]]//Numerator;
tmpn=tmpn//EvenPowers[{ pu[_],pd[_] }];
tmp=ReplacePart[tmp,tmpe[[1]]->tmpn/tmpd]
];


(*DifNoDependance[exp_,set1_List,set2_List] zeros xPartialD[a,b] if a\[Element]set1 and b\[Element]set2 or a\[Element]set2 and b\[Element]set1 *)
DifNoDependance[exp_,set1_List,set2_List]:=Module[{tmp=exp},
tmp=tmp/.xPartialD[a_,b_]:>0/;(ListMemberQ[a,set1]&&ListMemberQ[b,set2]||ListMemberQ[b,set1]&&ListMemberQ[a,set2]
);
tmp=tmp/.xPartialDu[a_,b_]:>0/;(ListMemberQ[a,set1]&&ListMemberQ[b,set2]||ListMemberQ[b,set1]&&ListMemberQ[a,set2]
)
];

(*Rule that lowers all indices in Tensor if possible*)
sLowerAllIndices=
Tensor[a_,b_,c_]:>Tensor[a,MapThread[If[#2===Void,Void,#1]&,{b,c}],
MapThread[If[#2===Void,#1,#2]&,{b,c}]];

(*Rule that raises all indices in Tensor except except_List*)
sRaiseAllIndices[except_List]=
{Tensor[a_,b_,c_]:>Tensor[a,
MapThread[If[#1===Void&&!MemberQ[except,#2],#2,#1]&,{b,c}],MapThread[If[#1===Void&&!MemberQ[except,#2],Void,#2]&,{b,c}]],
xPartialD[a_,b_]:>xPartialDu[a,b]/;!MemberQ[except,b],xCovariantD[a_,b_]:>xCovariantDu[a,b]/;!MemberQ[except,b]
};
(*Lowers indices in Tensor's based upon index_List.  Applies \[Eta]uu (signature factor) on Tensor indices that are lowered.  
Usage:  LowerIndex\[Eta][{i1,i2,...}][expression] *)
LowerIndex\[Eta][index_List][exp_]:=Module[{tmp,tmp1,DEBUG=0,mname="LowerIndex\[Eta]"},
IfDEBUG[mname,DEBUG>0,{index,exp},"{index,exp}"];m
tmp=exp/.
Tensor[a_,b_,c_]:>Tensor[a,
MapThread[If[#2===Void&&MemberQ[index,#1],Void,#1]&,{b,c}],MapThread[If[#2===Void&&MemberQ[index,#1],#1,#2]&,{b,c}]
]Apply[Times,MapThread[If[#2===Void&&MemberQ[index,#1],\[Eta]uu[#1,#1],1]&,{b,c}]];
tmp/.fixTensorWithArg
];

(*Rule version of LowerIndex\[Eta].  Does not fixTensorWithArg *)
sLowerIndex\[Eta][index_List]:=Tensor[a_,b_,c_]:>Tensor[a,
MapThread[If[#2===Void&&MemberQ[index,#1],Void,#1]&,{b,c}],MapThread[If[#2===Void&&MemberQ[index,#1],#1,#2]&,{b,c}]
]Apply[Times,MapThread[If[#2===Void&&MemberQ[index,#1],\[Eta]uu[#1,#1],1]&,{b,c}]];
(*repairs notation of Tensor with arguements, e.g. (-Au[i])[x]->-Au[i][x] *)
fixTensorWithArg:={(a_ Tensor[b_,c_,d_])[e_]->a Tensor[b,c,d][e]
};

(*Manipulates limit expression into integration variable specification, e.g., a<x<b && c<y<d -> {{x,a,b},{y,c,d}}  *)
Limits2IntRange[limit_]:=Module[{tmp=limit,tmp1},
tmp=tmp/.LessEqual->Less;(*multiple Alternative does not work*)
tmp1=ExtractPattern[Inequality[a_,Less,b_,Less,c_]][tmp];
Map[{#[[3]],#[[1]],#[[5]]}&,tmp1]
];

(*
Zeros are Rules of local functions that are 0. *17Oct2013*)
Zeros:={IntegralOp[_,0]->0,xSum[0,__]->0,DerivOps[0,__]->0,xProduct[0,__]->0}
(*
includeFactors[op_Pattern,pos_][exp_] includes Times factor into op_Pattern, e.g., xSum[_,_], at position pos_ in argument of op_Pattern.  Takes terms like A xSum[B,n]->xSum[A B,n] *17Nov2013*)
includeFactors[op_Pattern,pos_][exp_]:=Module[{tmp=exp},
tmp=tmp//.a_ (oo:op):>MapAt[# a&,oo,pos]
]
(*
contourIntegralPrep[exp_] prepares exp_ for applying Residue--attempts to reduce express so that IntegralOp is on the interior most arguement. PROTOTYPE *17Nov2013*)
contourIntegralPrep[exp_]:=Module[{tmp=exp,tmp1},
tmp=tmp//ExpandAll;
tmp=tmp//DistributeOp[xSum[_,_]];
tmp=tmp//DistributeOp[xPartialD[_,_]];
tmp=tmp//.xPartialD[xSum[a_,n_],b_]->xSum[xPartialD[a,b],n]//ExpandAll;
tmp=tmp//DistributeOp[IntegralOp[_,_]];
tmp=tmp//includeFactors[xSum[_,_],1];
tmp=tmp//.IntegralOp[b_,xSum[a_,n_]]->xSum[IntegralOp[b,a],n];
tmp
]


Unprotect[Transpose];
Transpose[Dot[a_,b_]]:=Dot[Transpose[b],Transpose[a]]
Transpose[Times[c_,Dot[a_,b_]]]:=c Dot[Transpose[b],Transpose[a]]/;FreeQ[c,Dot]
Transpose[Times[c_,a_]]:=c Transpose[a]/;NumericQ[c]
Transpose[Transpose[a_]]:=a
Transpose[a_+b_]:=Transpose[a]+Transpose[b]
Protect[Transpose];

Unprotect[ConjugateTranspose];

ConjugateTranspose[(op:Dot|xDot)[a_,b_]]:=op[ConjugateTranspose[b],ConjugateTranspose[a]]
ConjugateTranspose[Times[a_,b_]]:=Times[ConjugateTranspose[b],ConjugateTranspose[a]]
ConjugateTranspose[Times[c_,Dot[a_,b_]]]:=ConjugateTranspose[c] Dot[ConjugateTranspose[b],ConjugateTranspose[a]]/;FreeQ[c,Dot]
ConjugateTranspose[ConjugateTranspose[a_]]:=a
ConjugateTranspose[a_+b_]:=ConjugateTranspose[a]+ConjugateTranspose[b]
ConjugateTranspose[Exp[a_]]:=Exp[ConjugateTranspose[a]]

ConjugateTranspose[Rule[a_,b_]]:=Rule[ConjugateTranspose[a],ConjugateTranspose[b]]
ConjugateTranspose[a_]:=Conjugate[a]/;NumericQ[a]
Protect[ConjugateTranspose];

(*Rule for distributing Transpose over Sums and Dot.
Usage:  exp//.sTransposeExpand  *)
sTransposeExpand:=
{Transpose[a__+b__]->Transpose[a]+Transpose[b],
Transpose[Dot[a__]]:>Map[Transpose[#]&,Dot[Reverse[a]]]};

(*Rule to ease typing of ConjugateTranspose.*)
subDaggerCT={SuperDagger->ConjugateTranspose,SuperStar->Conjugate};
(*
egRule: distribute SuperDagger over Matrix elements:$s=SuperDagger[a_]\[RuleDelayed]Map[Thread[SuperDagger[#]]&,Transpose[a]]/;MatrixQ[a]
*)

(* Replaces Conjugate[realVar]|ConjugateTranspose[realVar]->realVar in exp_ if realVar is MemberQ of reals_  *)
ConjugateReals[exp_,reals_List]:=Module[{tmp=exp},
tmp=ExpandConjugateTranspose[tmp];
tmp=tmp//.Conjugate[a_]:>a/;a\[Element]Reals;
tmp=tmp//.Conjugate[a_]:>a/;ListMemberQ[a,reals];
tmp=ExpandConjugateTranspose[tmp];
tmp=tmp/.ConjugateTranspose[a_]:>Transpose[a]/;ListMemberQ[a,reals]
];

(**)
Clear[tuConjugateSimplify]
tuConjugateSimplify::usage="tuConjugateSimplify[reals_List:{}][exp_] simplifies Conjugate[]'s in exp_ with optional reals_List of variables.";
tuConjugateSimplify[reals_List:{}][exp_]:=Block[{tmp=exp},
tmp=Expand[tmp];
tmp=tmp//.tuConjugateDistribute//.simpleDot;
tmp=tmp//.Conjugate[a_]:>a/;a\[Element]Reals;
tmp=tmp//.Conjugate[a_]:>a/;ListMemberQ[a,reals]
];
ConjugateSimplify[exp_,reals_List:{}]:=tuConjugateSimplify[reals][exp](*Compatibility*)
(**)
tuConjugateDistribute::usage="tuConjugateDistribute are Rules for distribution Conjugate[] over an expression. EG. exp_//.tuConjugateDistribute *19Jul2015* ";
tuConjugateDistribute:={Conjugate[a_+b_]->Conjugate[a]+Conjugate[b],
Conjugate[a_ b_]->Conjugate[a] Conjugate[b],
Conjugate[Power[a_,b_]]->Power[Conjugate[a],Conjugate[b]],
Conjugate[a_==b_]->Conjugate[a]==Conjugate[b],
Conjugate[a_->b_]->Conjugate[a]->Conjugate[b],
Conjugate[Sum[a_,b__]]:>Sum[Conjugate[a],b],
Conjugate[xSum[a_,d__]]->xSum[Conjugate[a],d],
Conjugate[Integrate[a_,b__List]]->Integrate[Conjugate[a],b],
Conjugate[IntegralOp[a_,d_]]->IntegralOp[a,Conjugate[d]],
Conjugate[(oo:DerivOps)[a_,d_]]->oo[Conjugate[a],Conjugate[d]],
Conjugate[(op:dotOps)[a_,b_]]->op[Conjugate[a] , Conjugate[b]]
};
DistributeConjugate[exp_]:=Module[{},exp//.tuConjugateDistribute]; (*Compatibility*)

tuConjugateTransposeExpand::usage="tuConjugateTransposeExpand[exp_] expands ConjugateTranspose and Conjugate terms in exp_. Aware of IntegralOp and DerivOps. *30Jul2015*";
tuConjugateTransposeExpand[exp_]:=
Block[{tmp=exp,tmp1=Null,sub,cOps=Conjugate|ConjugateTranspose},
tmp=tmp//.subDaggerCT;(* superDagger mean ConjugateTranspose *)
sub={
ConjugateTranspose[Conjugate[a_]]->Transpose[a],
Conjugate[ConjugateTranspose[a_]]->Transpose[a] ,
(cOp:cOps)[(op:Sum|xSum)[a_,b__]]->op[cOp[a],b],
(cOp:cOps)[IntegralOp[a_List,d_]]->IntegralOp[a,cOp[d]],
(cOp:cOps)[Integrate[a_,b__List]]->Integrate[cOp[a],b],

Conjugate[Power[a_,b_]]->Power[Conjugate[a],Conjugate[b]],
Conjugate[a_]:>Map[Conjugate[#]&,a]/;MemberQ[Flatten[{List,Plus,Equal,Rule,Times,DerivOps,Dot,xDot}],Head[a]],
ConjugateTranspose[(op:DerivOps)[a_,d_]]->op[ConjugateTranspose[a],Conjugate[d]],(*d scalar*)
ConjugateTranspose[(op:dotOps)[a_,b__]]->op[ConjugateTranspose[op[b]] , ConjugateTranspose[a]],
ConjugateTranspose[a_]:>Map[ConjugateTranspose[#]&,a]/;MemberQ[{List,Plus,Equal,Rule},Head[a]]
};
tmp=tmp//.sub
];
(**)
tuConjugateTransposeSimplify::usage="tuConjugateTransposeSimplify[reals_List:{}][exp_] simplifies ConjugateTranspose and Conjugate terms in exp_ accounting for reals_List.  
tuConjugateTransposeSimplify[reals_List:{},scalars_List:{}][exp_] simplifies ConjugateTranspose and Conjugate terms in exp_ accounting for reals_List and scalars_List.
tuConjugateTransposeSimplify[reals_List:{},scalars_List:{},hermitian_List:{}][exp_] simplifies ConjugateTranspose and Conjugate terms in exp_ accounting for reals_List, scalars_List, and hermitian_List. *30Jul2015*";
tuConjugateTransposeSimplify[reals_List:{}][exp_]:=Block[{tmp=exp},
tmp=Expand[tmp];
tmp=tuConjugateTransposeExpand[tmp]//simpleDot1a[{}];
tmp=tmp//.tuConjugateDistribute;
tmp=tmp//.Conjugate[a_]:>a/;a\[Element]Reals;
tmp=tmp//.Conjugate[a_]:>a/;ListMemberQ[a,reals];
tmp=tmp//.ConjugateTranspose[a_]:>Transpose[a]/;ListMemberQ[a,reals];
tmp=tmp//.Conjugate[a_]:>a/;ListMemberQ[a,reals]>0
];
tuConjugateTransposeSimplify[reals_List:{},scalars_List:{}][exp_]:=Block[{tmp=exp},
tmp=Expand[tmp];
tmp=tuConjugateTransposeExpand[tmp]//simpleDot1a[scalars];
tmp=tmp//.Conjugate[a_]:>a/;ListMemberQ[a,reals];
tmp=tmp//.ConjugateTranspose[a_]:>Transpose[a]/;ListMemberQ[a,reals];
tmp=tmp//.simpleTranspose[scalars];
tmp=tmp//simpleDot1a[scalars];
tmp=tmp/.Conjugate[a_]:>a/;ListMemberQ[a,reals]>0
];
tuConjugateTransposeSimplify[reals_List:{},scalars_List:{},hermitian_List:{}][exp_]:=Block[{tmp=exp},
tmp=Expand[tmp];
tmp=tuConjugateTransposeExpand[tmp]//simpleDot1a[scalars];
tmp=tmp//.Conjugate[a_]:>a/;ListMemberQ[a,reals];
tmp=tmp//.ConjugateTranspose[a_]:>Transpose[a]/;ListMemberQ[a,reals];
tmp=tmp//.simpleTranspose[scalars];
tmp=tmp//.simpleHermitian[hermitian];
tmp=tmp//simpleDot1a[scalars];
tmp=tmp/.Conjugate[a_]:>a/;ListMemberQ[a,reals]>0
];
(*Compatibility*)
ConjugateCTSimplify[exp_,reals_List:{}]:=tuConjugateTransposeSimplify[reals][exp];
ConjugateCTSimplify[exp_,reals_List:{},scalars_List:{}]:=tuConjugateTransposeSimplify[reals,scalars][exp];
ConjugateCTSimplify[exp_,reals_List:{},scalars_List:{},hermitian_List:{}]:=tuConjugateTransposeSimplify[reals,scalars,hermitian][exp];
ConjugateCTSimplify1:=tuConjugateTransposeSimplify;

(* Distributes Conjugate and ConjugateTranspose over exp_. Replaces SuperDagger with ConjugateTranspose.*)
DistributeConjugateCT[exp_]:=
Module[{tmp=exp,tmp1=Null,sub},
tmp=tmp//.subDaggerCT/.Dot->xDot;(*Dot interferes with Rule sometimes.*)
sub={
Conjugate[Power[a_,b_]]->Power[Conjugate[a],Conjugate[b]],
Conjugate[Sum[a_,b__]]:>Sum[Conjugate[a],b],
Conjugate[xSum[a_,d__]]->xSum[Conjugate[a],d],
Conjugate[Integrate[a_,b__List]]->Integrate[Conjugate[a],b],
Conjugate[IntegralOp[a_,d_]]->IntegralOp[a,Conjugate[d]],
Conjugate[a_]:>Map[Conjugate[#]&,a]/;MemberQ[{List,Plus,Equal,Rule,Times,xPartialD,xPartialDu,Dot,xDot},Head[a]],
(**)
ConjugateTranspose[Sum[a_,b__]]->Sum[ConjugateTranspose[a],b],
ConjugateTranspose[xSum[a_,d__]]->xSum[ConjugateTranspose[a],d],
ConjugateTranspose[IntegralOp[a_,d_]]->IntegralOp[a,ConjugateTranspose[d]],
ConjugateTranspose[xPartialD[a_,d_]]->xPartialD[ConjugateTranspose[a],Conjugate[d]],(*d scalar*)
ConjugateTranspose[xPartialDu[a_,d_]]->xPartialDu[ConjugateTranspose[a],Conjugate[d]],
ConjugateTranspose[xDot[a_,b_]]->xDot[ConjugateTranspose[b] , ConjugateTranspose[a]],
ConjugateTranspose[a_]:>Map[ConjugateTranspose[#]&,a]/;MemberQ[{List,Plus,Equal,Rule},Head[a]],

ConjugateTranspose[Conjugate[a_]]->Transpose[a],
Conjugate[ConjugateTranspose[a_]]->Transpose[a]
};
tmp=tmp//.sub/.xDot->Dot
];
(* 
ExpandConjugateTranspose[exp_] expands ConjugateTranspose and Conjugate terms in exp_. (Replaces DistributeConjugateCT.) *10Sep2012*)
ExpandConjugateTranspose[exp_]:=
Module[{tmp=exp,tmp1=Null,sub,cOps=Conjugate|ConjugateTranspose},
tmp=tmp//.subDaggerCT;(* superDagger mean ConjugateTranspose *)
sub={
ConjugateTranspose[Conjugate[a_]]->Transpose[a],
Conjugate[ConjugateTranspose[a_]]->Transpose[a] ,
(cOp:cOps)[(op:Sum|xSum)[a_,b__]]->op[cOp[a],b],
(cOp:cOps)[IntegralOp[a_List,d_]]->IntegralOp[a,cOp[d]],
(cOp:cOps)[Integrate[a_,b__List]]->Integrate[cOp[a],b],

Conjugate[Power[a_,b_]]->Power[Conjugate[a],Conjugate[b]],
Conjugate[a_]:>Map[Conjugate[#]&,a]/;MemberQ[Flatten[{List,Plus,Equal,Rule,Times,DerivOps,Dot,xDot}],Head[a]],
ConjugateTranspose[(op:DerivOps)[a_,d_]]->op[ConjugateTranspose[a],Conjugate[d]],(*d scalar*)
ConjugateTranspose[(op:dotOps)[a_,b__]]->op[ConjugateTranspose[op[b]] , ConjugateTranspose[a]],
ConjugateTranspose[a_]:>Map[ConjugateTranspose[#]&,a]/;MemberQ[{List,Plus,Equal,Rule},Head[a]]
};
tmp=tmp//.sub
];
(*
SimpleConjugateTranspose[reals_List,scalars_List,hermitian_List][exp_] expands and simplifies exp_ based upon reals_List,scalars_List,hermitian_List  *10Sep2012*)
SimpleConjugateTranspose[reals_List,scalars_List,hermitian_List][exp_]:=Module[{tmp=exp},
tmp=Expand[tmp];
tmp=ExpandConjugateTranspose[tmp];
tmp=tmp//simpleDot1a[scalars];
tmp=tmp//.Conjugate[a_]:>a/;a\[Element]Reals;
tmp=tmp//.Conjugate[a_]:>a/;ListMemberQ[a,reals];
tmp=tmp//.ConjugateTranspose[a_]:>Transpose[a]/;ListMemberQ[a,reals];
tmp=tmp//.simpleTranspose[scalars];
tmp=tmp//.simpleHermitian[hermitian];
tmp=tmp//simpleDot1a[scalars];
tmp
];

(*Rules for simplifying Hermitian variables.*)
simpleHermitian[hermitian_List]:=
{ConjugateTranspose[a_]:>a/;ListMemberQ[a,hermitian]};
(*
Commutator to Dot notation *5Dec2013*)
commutatorDot:={CommutatorP->ACommutator,CommutatorM->MCommutator}

tuCommutatorSimplify::usage="tuCommutatorSimplify[constant_List:{}][exp_] expands and simplify CommutatorM|P in exp_. *12Oct2015*";
tuCommutatorSimplify[constant_List:{}][exp_]:=Block[{tmp=exp,tmp1,cOp=CommutatorM|CommutatorP,$const},
$const[a_]:=tuMemberQ[a,constant]||NumericQ[a];
While[tmp1=!=tmp,
tmp1=tmp;
xPrint["tmp:  ",tmp];
tmp=tmp/.(op:cOp)[a_,b_]:>op[Expand[a],Expand[b]];
tmp=tmp//.(op:cOp)[a_+a1_,b_]:>op[a,b]+op[a1,b];
tmp=tmp//.(op:cOp)[a_,b_+b1_]:>op[a,b]+op[a,b1];
tmp=tmp//.(op:cOp)[a_  a1_,b_]:>a  op[a1,b]/;$const[a];
tmp=tmp//.(op:cOp)[a_  ,b_ b1_]:>b  op[a,b1]/;$const[a];
tmp=tmp//.(op:CommutatorP)[a_  ,b_]:>2 a  b/;$const[a]||$const[b];
tmp=tmp//.(op:CommutatorM)[a_  ,b_]:>0/;$const[a]||$const[b];
tmp=tmp//.(op:cOp)[(ss:(Sum|xSum))[a_,b_],c_]->ss[op[a,c],b];
tmp=tmp//.(op:cOp)[c_,(ss:(Sum|xSum))[a_,b_]]->ss[op[c,a],b];

tmp=tmp//.(cop:CommutatorM)[a_ ,(dop:dotOps)[b_ ,b1__]]:>dop[cop[a,b],b1]+dop[b,cop[a,dop[b1]]];
tmp=tmp//.(cop:CommutatorM)[(dop:dotOps)[a_ ,b__],b1_]:>dop[a,cop[dop[b],b1]]+dop[cop[dop[a],b1],b];
];
tmp
];
simpleCommutator[constant_List:{}][exp_]:=tuCommutatorSimplify[constant][exp];(*Compatibility*);

(*
jacobiID[a_,b_,c_] generates Jacobi identity form from a_,b_,c_. *25Nov2013*)
jacobiID[a_,b_,c_]:=Module[{$aa,$bb,$cc,$p,$t},
$t=CommutatorM[$aa,CommutatorM[$bb,$cc]];
$p=Permute[{$aa,$bb,$cc},AlternatingGroup[3]];
$p=Map[Thread[#->{a,b,c}]&,$p];
$p=Apply[Plus,Map[$t/.#&,$p]];
$p
]


"e[] == unit vector.";
(*Distributes pair operator op_ in expression op_.A.op_ over each term in exp_, e.g.,
op_.A B.op_->op_.A.op_.op_.B.op_ *)
ExpandPairOp[op_,exp_]:=Module[{tmp=exp,tmp1},
While[tmp1=!=tmp,
tmp1=tmp;
tmp=tmp/.{(*Odd that //. yields different results.*)
DotExpand,
Dot[op,b_ c_,op]:>Dot[op,b,op,op,c,op]/;FreeQ[b,op]&&FreeQ[c,op],
Dot[op,b_,c_,op]:>Dot[op,b,op ,op,c,op]/;FreeQ[b,op]&&FreeQ[c,op]
};
tmp=tmp//.simpleDot;
];
tmp
];

(*NOTE: DotExpand works for only simple sums.  Need to precede it with ExpandAll. *)
DotExpand={(op:Dot|xDot)[a___,b_+c_,d___]:>op[a,b,d]+op[a,c,d]};
(**)

(*Keeps under Dot items in clist. Usage  expression/.Dot[a___]\[RuleDelayed]dotKeep[{ keep_list }]  [a].  Returns  nokeep_list Dot[ keep_list ]*)
(* Newer version. 2010.2.16 *)
DotKeep1[clist_,seq_]:=
Module[{tmp=seq,i,j,member,dot={},times={1},test,DEBUG=0},
tmp=tmp/.Times->Dot/.simpleDot;
If[DEBUG>0,Print["DotKeep< ",clist," : ",tmp," ",Length[tmp]]];
For[i=1,i<=Length[tmp],i++,
test=tmp[[i]];
If[DEBUG>1,Print["DotKeep: ",test," : ",clist]];
member=False;
If[MemberQ[clist,test],member=True];
For[j=1,j<=Length[clist],j++,
If[! FreeQ[test,clist[[j]]],member=True]
];
If[ member,
AppendTo[ dot,test],
AppendTo[ times,test]
];
If[DEBUG>1,Print["DotKeep: ",dot,times]];
];
tmp=1;
If[Length[times]>0,
tmp=Apply[Times,times]];
If[Length[dot]>0,
tmp=tmp Apply[Dot,dot]];
If[DEBUG>0,Print["DotKeep>> ",tmp]];
tmp
];

tuDotTermLeft::usage="tuDotTermLeft[term_,block_List][exp_Dot]\[IndentingNewLine]moves term_ in exp_Dot to the left up to any pattern in block_List.  Any matching pattern will block since FreeQ is used to determine content.  \[IndentingNewLine]Usage: b.c.d.b.a.d/.dd:HoldPattern[Dot[_]]\[RuleDelayed]tuDotTermLeft[a,{c}][dd] -> b.c.a.d.b.d\[IndentingNewLine]*15May2015";
Clear[tuDotTermLeft];
tuDotTermLeft[term_,block_List][exp_Dot]:=Module[{$=exp,$p},(*
$p=tuExtractPositionPattern[term][$/.Dot\[Rule]xDot];
Print[$," ",$p," ",term];*)
$=$//.a_  .  tt:term :> tt  . a/;ListFreeQ[a,block]
];
MoveDotLeft[term_,block_List][exp_Dot]=tuDotTermLeft[term,block][exp];

tuDotTermRight::usage="tuDotTermRight[term_,block_List][exp_Dot]\[IndentingNewLine]moves term_ in exp_Dot to the right up to any pattern in block_List.  Any matching pattern will block since FreeQ is used to determine content.  \[IndentingNewLine]Usage: b.a.d.a.b.d.c.d/.dd:HoldPattern[Dot[_]]\[RuleDelayed]tuDotTermRight[a,{c}][dd]->b.d.b.d.a.a.c.d\[IndentingNewLine]*15May2015";
Clear[tuDotTermRight];
tuDotTermRight[term_,block_List][exp_Dot]:=Module[{$=exp,$p},(*
$p=tuExtractPositionPattern[term][$];*)(*
xPrint[$p," ",term];*)
$=$//.tt:term . a_:>a. tt /;ListFreeQ[a,block]
];
MoveDotRight[term_,block_List][exp_Dot]=tuDotTermRight[term,block][exp];

(*
MoveDotLeft[term_,block_List,anticommute_List][exp_Dot] moves term_ in exp_Dot to the left until variable in block_List is encountered.  WARNING: anticommute_List may not have the proper behavior.  *29Mar2014*)
MoveDotLeft[term_,block_List,anticommute_List][exp_Dot]:=Module[{tmp=exp,tmp1,$},
xPrint[exp,"::",anticommute];
While[tmp1=!=tmp,
tmp1=tmp;
tmp=tmp//.a_ .term :> term .a  
(-1)^(Max[{1,
Length[Select[Apply[List,term . a],!ListFreeQ[#,anticommute]&]]}]+1)/;ListFreeQ[a,block];
xPrint[tmp];
tmp=tmp//.simpleDot2[{}];
];
tmp
];

GammaRight[exp_,gamma_]:=(* Moves gamma_ in Dot[] expression to the right until the end or the term disappears.  Usage: expression/.Dot[a__]:> GammaRight[a].  Returns replacement for Dot[]. *)
Module[{ tmp=exp,tmp1,out,gpos,Ngpos,igpos,indu=Null,indd=Null,pair,DEBUG=0},
If[DEBUG>0,Print["GammaRight: ",tmp," : ",gamma]];
While[tmp1=!=tmp,
tmp1=tmp;
indu=gamma/.\[Gamma]@u[a_]->a;
indd=gamma/.\[Gamma]@d[a_]->a;
tmp=tmp/.Dot[a___,gamma,b_,c___]:>Dot[a,CommuteG[gamma,b],c]/;(MemberQ[{b},\[Gamma]@u[_]||MemberQ[{b},\[Gamma]@d[_]]]);
tmp=Expand[tmp]/.simpleDot//Expand;

If[DEBUG>0,Print["GammaRight>  ",tmp]];
tmp=tmp/.Dot->xDot;
tmp=tmp//.xDot[a__]:>DotKeep1[{\[Gamma]@d[_],\[Gamma]@u[_]},{a}];
tmp=Expand[tmp]/.simpleDot;
tmp=tmp//.{Dot[a___,\[Gamma]@d[b_],\[Gamma]@u[b_],c___]:>dim[x]Dot[a,c],Dot[a___,\[Gamma]@u[b_],\[Gamma]@d[b_],c___]:>dim[x] Dot[a,c]};

If[DEBUG>0,Print["GammaRight>> ",tmp]];
];
tmp
];
GammaRight[exp_,gamma_Tensor]:=(* Moves gamma matrix gamma_ in expression with Dot[,gamma_,\[Gamma],\[Gamma]...]'s through \[Gamma]'s to the far right or until it disappears.  
Usage: GammaLeft[exp_,gamma_].  Returns exp_ with Dot[,gamma_,...]'s replaced with Dot[,gamma_,] where gamma_ is moved to the right. *)
Module[{ tmp=exp,tmp1,gammaT,isgamma,out,DEBUG=0,mname="GammaRight"},
IfDEBUG[mname,DEBUG>0,{tmp,gamma},"{tmp,gamma}"];
gammaT=Apply[List,gamma];
isgamma=Count[{gamma},Tensor[\[Gamma],{_},{_}]]==1;
While[tmp1=!=tmp&&isgamma,
tmp1=tmp;
tmp=tmp/.Dot[a___,gamma,b_,c___]:>Dot[a,CommuteG[gamma,b],c]/;Count[{b},Tensor[\[Gamma],{_},{_}]]==1;
tmp=Expand[tmp]//.DotExpand//.simpleDot//Expand;
];
tmp
];


GammaLeft[exp_,gamma_Tensor]:=(* Moves gamma matrix gamma_ in expression exp_ with Dot[,\[Gamma],\[Gamma],gamma_,...]'s through \[Gamma]'s to the far left or until it disappears.  
Usage: GammaLeft[exp_,gamma_].  Returns exp_ with Dot[,gamma_,...]'s replaced with Dot[,gamma_,] where gamma_ is moved to the left. *)
Module[{ tmp=exp,tmp1,gammaT,isgamma,DEBUG=0,mname="GammaLeft"},
IfDEBUG[mname,DEBUG>0,{tmp,gamma},"{tmp,gamma}"];
gammaT=Apply[List,gamma];
isgamma=Count[{gamma},Tensor[\[Gamma],{_},{_}]]==1;
While[tmp1=!=tmp&&isgamma,
tmp1=tmp;
tmp=tmp/.Dot[a___,b_,gamma,c___]:>Dot[a,CommuteG[b,gamma],c]/;Count[{b},Tensor[\[Gamma],{_},{_}]]==1;
tmp=Expand[tmp]//.DotExpand//.simpleDot//Expand;
];
tmp
];

GammaRight[gamma_Tensor][exp_]:=(* Moves gamma matrix gamma_ in expression exp_ with Dot[,gamma_,\[Gamma],\[Gamma],...]'s through \[Gamma]'s to the far right or until it disappears.  
Usage: GammaRight[gamma_][exp_].  Returns exp_ with Dot[,gamma_,...]'s replaced with Dot[...,gamma_,] where gamma_ is moved to the right through other gamma's. *)
Module[{ tmp=exp,tmp1,gammaT,isgamma,DEBUG=0,mname="GammaRight"},
IfDEBUG[mname,DEBUG>0,{tmp,gamma},"{tmp,gamma}"];
gammaT=Apply[List,gamma];
isgamma=Count[{gamma},Tensor[\[Gamma],{_},{_}]]==1;
While[tmp1=!=tmp&&isgamma,
tmp1=tmp;
tmp=tmp/.Dot[a___,gamma,b_,c___]:>Dot[a,CommuteG[gamma,b],c]/;Count[{b},Tensor[\[Gamma],{_},{_}]]==1;
tmp=Expand[tmp]//.DotExpand//.simpleDot//Expand;
];
tmp
];

GammaLeft[gamma_Tensor][exp_]:=(* Moves gamma matrix gamma_ in expression exp_ with Dot[,\[Gamma],\[Gamma],gamma_,...]'s through \[Gamma]'s to the far left or until it disappears.  
Usage: GammaLeft[exp_,gamma_].  Returns exp_ with Dot[,gamma_,...]'s replaced with Dot[,gamma_,] where gamma_ is moved to the left. *)
Module[{ tmp=exp,tmp1,gammaT,isgamma,DEBUG=0,mname="GammaLeft"},
IfDEBUG[mname,DEBUG>0,{tmp,gamma},"{tmp,gamma}"];
gammaT=Apply[List,gamma];
isgamma=Count[{gamma},Tensor[\[Gamma],{_},{_}]]==1;
While[tmp1=!=tmp&&isgamma,
tmp1=tmp;
tmp=tmp/.Dot[a___,b_,gamma,c___]:>Dot[a,CommuteG[b,gamma],c]/;Count[{b},Tensor[\[Gamma],{_},{_}]]==1;
tmp=Expand[tmp]//.DotExpand//.simpleDot//Expand;
];
tmp
];

(* Commutes \[Gamma] matrices g1_, g2_, Returns -g2_.g1_+2 \[Eta]__[,] *)
CommuteG[g1_Tensor,g2_Tensor]:=
Module[{tmp,g1T,g2T,iup,idown,is5,twog,gtmp=1,out,DEBUG=0,mname="CommuteG"},
IfDEBUG[mname,DEBUG>0,{g1,g2},"{g1,g2}"];
g1T=Apply[List,g1];
g2T=Apply[List,g2];
iup=Flatten[{g1T[[2]],g2T[[2]]}];
idown=Flatten[{g1T[[3]],g2T[[3]]}];
is5=!FreeQ[{iup,idown},5];
IfDEBUG[mname,DEBUG>0,{iup,idown},"{iup,idown}"];
twog=(Count[{g1},Tensor[\[Gamma],{_},{_}]]+Count[{g2},Tensor[\[Gamma],{_},{_}]])==2;
Which[!twog,out=g1.g2 (* not 2 \[Gamma]'s return\[Rule]no change *),
twog&&g1===g2,
out=If[is5,1,Tensor[\[Eta],iup,idown]],
twog,
gtmp=If[is5,0,Tensor[\[Eta],iup,idown]];
out=-g2.g1+2gtmp
]
];

(*
Sorts Grassmanian variables {a_,b_} in Dot[a_,b_] expression..
Usage: exp/.Dot[a_,b_]\[RuleDelayed]GrassmanDotSort[a,b].*)
GrassmanDotSort[a_,b_]:=Module[{order=Order[a,b],tmp=Sort[{a,b}]},
If[order===0,order=1];
Apply[Dot,tmp]order
];
(*
Dot product of vectors {a_,b_} of Grassmanian variables. *)
GrassmanDot[a_,b_]:=Module[{tmp,tmpa,tmpb},
If[Dimensions[a][[1]]==1&&Dimensions[b][[2]]==1&&Dimensions[a][[2]]==Dimensions[b][[1]],
tmpa=Flatten[a];
tmpb=Flatten[b];
tmpa=MapThread[Dot,{tmpa,tmpb}]/.simpleDot;
tmp=tmpa/.Dot[c_,d_]:>GrassmanDotSort[c,d];
Apply[Plus,tmp]
]
];

(*
seqLabelTerm[matrix_,seq_] labels matrix_ elements with seq$[seq_][element] where matrix is MatrixQ, ArrayQ, or none.  This routine is used in NonCommutativeDot[] where seq_ is the arguement position of the matrix_ in ncDot[].  NOTE: label seq$ is global.  *1Apr2014*)
seqLabelTerm[matrix_,seq_]:=Module[{tmp=matrix,dim},
If[MatrixQ[matrix],
dim=Dimensions[tmp,2];
dim=Array[List,dim]//Flatten[#,1]&;
tmp=MapAt[seq$[seq][#]&,tmp,dim],
If[ArrayQ[matrix],
dim=Dimensions[tmp,2][[1]];
dim=Array[List[List[#]]&,dim]//Flatten[#,1]&;Print[dim,tmp];
tmp=MapAt[seq$[seq][#]&,tmp,dim],
tmp=seq$[seq][tmp]
]
]
];
(*
NonCommutativeDot[exp_ncDot] takes ncDot[] expressions and performs Dot[] operations among is terms so that the elements of each resulting term have the same ordering as in exp_ncDot.  NOTE: all Times[]->Dot[].  Usage: $exp/.dd:ncDot[__]:>NonCommutativeDot[dd]  *1Apr2014*)
NonCommutativeDot[exp_ncDot]:=Module[{tmp=exp},
tmp=MapIndexed[seqLabelTerm[#1,#2[[1]]]&,tmp];
tmp=tmp/.ncDot->Dot;
tmp=tmp/.Times->Dot;
tmp=tmp/.seq$[_][a_]->a;
tmp
]

(*Example of routine that moves the left arguement in pair_List contained in exp_ to the right until they are adjacent alternating arguement pairs each tranposition.*)
MovePairRight[pair_List][exp_]:=Module[{tmp=exp,tmpv=pair,tmpx1,x1,x2,tmpp},
While[(tmpp=Position[tmp,Apply[Alternatives,tmpv]];(x2=tmpp[[2,1]])-(x1=tmpp[[1,1]])>1),
tmpx1=Extract[tmp,{x1}];
If[tmpx1 === tmpv[[1]],tmpx1=tmpv[[2]],If[tmpx1 === tmpv[[2]],tmpx1=tmpv[[1]]]];
tmp=Permute[tmp,Cycles[{{x1,x1+1}}]];
tmp=ReplacePart[tmp,{x1+1}->tmpx1];
];
tmp
]


(*Returns Rule[First[mn_]\[Rule]_] for exp_\[Equal]0 for pair mn_. e.g., ZeroMN[I 2 \[Pi] m t/\[Beta],{m,n}] => m->0*)
ZeroMN[exp_,mn_]:=Module[{tmp},
tmp=Solve[exp==0,First[mn]];
If[Length[First[tmp]]>0,
tmp=First[First[tmp]],
tmp=Solve[exp==0,Last[mn]];
If[Length[First[tmp]]>0,
tmp=First[First[tmp]],
tmp=exp;
];
];
tmp
];
(* Returns xDiscreteDelta[First[mn_,_] for exp_\[Equal] 0 for pair mn_={m,n}. e.g., ZeroMN[I 2 \[Pi] (m-n) t/\[Beta],{m,n}]->xDiscreteDelta[First[m,n]]  *)
ZeroMNDiscreteDelta[exp_,mn_]:=Module[{tmp,DEBUG=0},
tmp=ZeroMN[exp,mn];
If[DEBUG>0,Print["ZeroMNDiscreteDelta: ",{exp,mn,tmp,Head[tmp]}]];
If[Head[tmp]===Rule,
tmp=tmp/.Rule->xDiscreteDelta,
tmp=exp
];
tmp
];

(*Returns \[Delta]uu[First[mn_,_], DiscreteDelta[] for exp_\[Equal] 0 for pair mn_={m,n}. e.g., ZeroMN[I 2 \[Pi] (m-n) t/\[Beta],{m,n}] *)
ZeroMN\[Delta][exp_,mn_]:=Module[{tmp,DEBUG=0,mname="ZeroMN\[Delta]"},
tmp=ZeroMN[exp,mn];
IfDEBUG[mname,DEBUG>0,{exp,mn,tmp},""];
If[Head[tmp]===Rule,
tmp=tmp/.Rule->\[Delta]uu,
tmp=exp
];
tmp
];
(* Rule for Sum|xSum consolidation*)
GatherSumSubs=subGatherSum={Sum->xSum,
xSum[xSum[a_,b__],c__]:>xSum[a,Apply[Sequence,Sort[{b,c}]]],
d_ xSum[a_,b__]:>xSum[Expand[d a],b],
d_ . xSum[a_,b__]->xSum[d. a,b],
xSum[a_,b__].d_->xSum[ a.d,b],
xSum[a_,b__]+xSum[c_,b__]->xSum[a+c,b]
};
(*Consolidation Rule[]'s for IntegralOp *)
GatherIntOpSubs=subGatherIntOp={IntegralOp[a_List,IntegralOp[b_List,c_]]:>IntegralOp[{a, b},c],d_ IntegralOp[a_,b_]:>IntegralOp[a,Expand[d b]],
IntegralOp[a_,b_]+IntegralOp[a_,c_]->IntegralOp[a,c+b]
};
(*
gatherIntegralOpRule for consoliating expressions with IntegralOp's * Added Dot. *21Nov2014*)
gatherIntegralOpRules:={
Conjugate[IntegralOp[a_,b_]]->IntegralOp[a,Conjugate[b]],
ConjugateTranspose[IntegralOp[a_,b_]]->IntegralOp[a,ConjugateTranspose[b]],
IntegralOp[a_,c_]d_->IntegralOp[a,c d],
Dot[a___,IntegralOp[ia_,ib_],b___]->IntegralOp[ia,a. ib. b],
IntegralOp[a_,b_]:>b spanLimits[a]/;NumericQ[b],
IntegralOp[a_,b_]:>IntegralOp[Sort[a],b],
IntegralOp[a_,d_]  IntegralOp[b_,c_] :>IntegralOp[Join[a,b],d c],
IntegralOp[a_,d_] .  IntegralOp[b_,c_] :>IntegralOp[Join[a,b],d . c],IntegralOp[a_,d_  IntegralOp[b_,c_] ]:>IntegralOp[Join[a,b],d c],
IntegralOp[a_,d_ .  IntegralOp[b_,c_] ]:>IntegralOp[Join[a,b],d . c],
IntegralOp[a_,IntegralOp[b_,c_ ]]:>IntegralOp[Join[a,b], c],
IntegralOp[a_,b_]+IntegralOp[a_,c_]->IntegralOp[a,c+b],
c1___ IntegralOp[a_,b_]+c2___ IntegralOp[a_,c_]->IntegralOp[a,c2 c+c1 b],
IntegralOp[a_,b_]-IntegralOp[a_,c_]->IntegralOp[a,b-c]
};


(*
gatherIntegralOp[exp_] apply gatherIntegralOpRues to exp_ *21Nov2014*)
gatherIntegralOp[exp_]:=Block[{tmp=exp,tmp1,i},
While[tmp1=!=tmp,
tmp1=tmp;
tmp=Fold[#1//.#2&,tmp1,gatherIntegralOpRules]
];
tmp
];
(*
SwitchOps[op1_,op2_][exp_] switches positions of op1_,op2_ in exp_.  op1_[op2_[arg2,parm2],parm1]->op2_[op1_[arg2,parm1],parm2] *3Oct2014*)SwitchOps[op1_,op2_][exp_]:=Module[{tmp=exp},
If[op1===IntegralOp &&op2===IntegralOp,
tmp=tmp/.IntegralOp[a1_,IntegralOp[a2_,b_]]->IntegralOp[a2,IntegralOp[a1,b]],
If[op1===IntegralOp,
tmp=tmp/.IntegralOp[intvars_,op2[arg2_,parms2___]]->op2[IntegralOp[intvars,arg2],parms2],
If[op2===IntegralOp,
tmp=tmp/.op1[op2[intvars_,arg_],parms1___]->op2[intvars,op1[arg,parms1]]],
tmp=tmp/.op1[op2[arg2_,parms2___],parms1___]->op2[op1[arg2,parms1],parms2]];
];
tmp
];

(*
Rule for moving DerivOps into IntegralOp *16Jul2013*)
DerivOpsInIntegralOp:=(dop:DerivOps)[IntegralOp[a_,b_],c_]->IntegralOp[a,dop[b,c]];
switchDerivOpsIntegralOp:=(dop:DerivOps)[IntegralOp[a_,b_],c_]->IntegralOp[a,dop[b,c]];
(*
IntegralOp to Integrate Rules.  *18Sep2012*)
subxIntegrate:=IntegralOp[a_,b_]:>xIntegrate[b,Apply[Sequence,Map[If[Length[#]==3,#,First[#]]&,a]]];
subxIntegrateOne:=IntegralOp[a_,b_]:>IntegralOp[Most[a],xIntegrate[b,Last[a]]];
subIntegralOp:=xIntegrate[a_,b__]:>IntegralOp[{b},a];
subIntegrate:=xIntegrate[a_,b__]:>Integrate[a,b];
addAssumptions[assume_]:=xIntegrate[a_,b__]->xIntegrate[a,b,Assumptions->assume];
subIntegrateAssume[assume_]:=xIntegrate[a_,b__]->Integrate[a,b,Assumptions->assume];
toIntegralOp=Integrate[a_,b__]->IntegralOp[If[Depth[{b}]<3,{{b}},{b}],a];

(**)
tuIntegrate::usage="tuIntegrate[assume_][exp_] applies Integrate[] to tuIntegral[] terms in exp_.   Assumptions may be introduced by setting assume_ *21Feb2015"; 
tuIntegrate[assume_:{}][exp_]:=Block[{$=exp,xIntegrate},
$=$/.tuIntegral[a_,b_]:>xIntegrate[b,Apply[Sequence,Map[If[Length[#]==3,#,First[#]]&,a]]];
If[Length[assume]>0,$=$/.
xIntegrate[a_,b__]->xIntegrate[a,b,Assumptions->assume]];
$=$/.xIntegrate->Integrate
];

(* 
ExchangexPartialDSum[exp_] switches (dop:DerivOps)[(op:sum)[a_,c__],b_]\[RuleDelayed]op[dop[a,b],c] (added DerivOps) *20Oct2013*)
ExchangexPartialDSum[exp_]:=Module[{tmp=exp,tmp1,sum=Sum|xSum,DEBUG=0},
If[DEBUG>0,Print["ExchangePartialDSum: ",tmp]];
(*Partiald does not substitute, change to xPartialD *)
tmp=tmp/.distributePartialD;
tmp=tmp//.(dop:DerivOps)[(op:sum)[a_,c__],b_]:>op[dop[a,b],c];(*
tmp=tmp/.xPartialD[xSum[a_,c__],b_]\[RuleDelayed]xSum[xPartialD[a,b],c];*)
tmp
];

(*Contracts xDiscreteDelta[n_,m_] in xSum.  Eliminates on xSum[]. 
3.1.2010*)
SumDiscreteDelta[exp_]:=Module[{tmp,tmp1=Null,pos,arg,index,sumvar,xsum,xdelta,posd,n,m,repl={},sub,i,DEBUG=0},
tmp=exp//DistributeSum;
While[tmp=!=tmp1,
If[DEBUG>0,Print["SumDiscreteDelta: ",tmp]];
tmp1=tmp;
pos=Position[tmp,xSum[__]];
For[i=1,i<=Length[pos],i++,
xsum=Extract[tmp,pos[[i]]];
{arg,index}=Apply[List,xsum];
If[Head[index]===List,
sumvar=First[index],sumvar=index];

If[DEBUG>0,Print["SumDiscreteDelta{arg,index}: ",{arg,index}]];

xdelta=Extract[arg,posd=Position[arg,xDiscreteDelta[__]]]//First;
sub=Null;
If[!FreeQ[xdelta,sumvar],
If[Length[xdelta]==2,
sub=Solve[Apply[Equal,xdelta],sumvar][[1]];
];
If[Length[xdelta]==1,
sub=Solve[First[xdelta]==0,sumvar][[1]];
];
];

If[DEBUG>0,Print["SumDiscreteDelta{Length[xdelta],xdelta,sub}: ",{Length[xdelta],xdelta,sub}]];
If[DEBUG>0,Print["SumDiscreteDelta{sub,arg}: ",{sub,arg}]];

If[sub=!=Null,arg=arg/.sub/.xDiscreteDelta[__]->1;AppendTo[repl,pos[[i]]->arg]];

If[DEBUG>0,Print["SumDiscreteDelta{index,sub,repl}: ",{index,sub,repl}]];

];
];
tmp=ReplacePart[tmp,repl]
];

(**)
tuExtractIntegrand::usage="tuExtractIntegrand[exp_] returns position\[Rule]integrand Rule of first IntegralOp[a_,b_]|tuIntegral[a_,b_]|xIntegral[a_,b__] found in exp_. Adjustment is made for the arguement postion of the integral arguement list. *8Nov2015*";
tuExtractIntegrand[exp_]:=Block[{pos,tmp},
tmp=tuExtractPositionPattern[IntegralOp[a_,b_]|tuIntegral[a_,b_]|xIntegral[a_,b__]][exp]//First;
If[FreeQ[tmp,Integrate],
{   Append[First[tmp],2]->tmp[[2,2]] },
{   Append[First[tmp],1]->tmp[[2,1]] }
]//First
];
ExtractIntegrandP:=tuExtractIntegrand;

(**)
tuIntegralSimplify::usage="tuIntegralSimplify[exp_] applies tuIntegralSimplify[,] to all xIntegral's in exp_ which removes from integrand_ of xIntegral[] terms that are not functions of the integration variables. EG: exp//tuIntegralSimplify  *8Mar2016*" ;
tuIntegralSimplify[exp_]:=Block[{tmp=exp}, 
tmp=tmp/.xIntegral[a_,b__]:>tuIntegralSimplify[a,b]
];
tuIntegralSimplify[integrand_,vars0__]:=Block[{vars,terms,pick,keep,out,ret},
(*Make list of integration variables where vars is List of Lists.*)
vars=Map[If[Head[#]===List,First[#],#]&,{vars0}];xPrint[vars];
(*Integrand must be a Product of terms to be factorable.*)
ret=If[Head[integrand]===Times,
terms=Apply[List,integrand];
pick=Map[ListFreeQ[#,vars]&,terms];
keep=Apply[Times,Pick[terms,pick,False]];
out=Apply[Times,Pick[terms,pick]];
out xIntegral[keep,vars0],
xIntegral[integrand,vars0]
];
ret/.xIntegral[0,_]->0
];

tuOpMerge::usage="tuOpMerge[op_:xIntegral] Rule for merge nested operator into one *8Mar2016*";
tuOpMerge[op_:xIntegral]:={op[op[a_,b__],c__]->op[a,c,b]};

(*
simpleIntegralOp[vars0_List,integrand_] removes from integrand_ of IntegralOp[] terms that are not functions of the integration variables. 
Usage: exp//.IntegralOp->simpleIntegralOp  *2Oct2014*)
simpleIntegralOp[vars0_List,integrand_]:=Module[{vars,terms,pick,keep,out,ret},
(*Make list of integration variables where vars is List of Lists.*)
vars=Map[{#[[1]]}&,vars0]//Flatten;
(*Integrand must be a Product of terms to be factorable.*)
ret=If[Head[integrand]===Times,
terms=Apply[List,integrand];
pick=Map[ListFreeQ[#,vars]&,terms];
keep=Apply[Times,Pick[terms,pick,False]];
out=Apply[Times,Pick[terms,pick]];
out IntegralOp[vars0,keep],
IntegralOp[vars0,integrand]
];
ret/.IntegralOp[_,0]->0
];

(**)
tuSimpleIntegralOp::usage="tuSimpleIntegralOp[exp_] applies simpleIntegralOp to all IntegralOp's in exp_ which removes from integrand_ of IntegralOp[] terms that are not functions of the integration variables. EG: exp//tuSimpleIntegralOp  *7Jan2015" ;
tuSimpleIntegralOp[exp_]:=Block[{tmp=exp}, 
tmp=tmp/.IntegralOp->simpleIntegralOp
];
tuSimpleIntegralOp[exp_]:=Block[{tmp=exp}, 
tmp=tmp/.IntegralOp[a_,b_]:>(tuIntegralSimplify[b,Apply[Sequence[a]]]/.xIntegral[ii_,vv__]->IntegralOp[{vv},ii]);
];(*UNTESTED*)

(*
IntegrandKeep[vars_List][exp_] simplifies IntegralOp's by moving integrand terms not containing any vars_List (Patterns OK) outside of IntegralOp expression. *13Jun2013*)
IntegrandKeep[vars_List][exp_]:=Module[{tmp,pos,ipos,args,intg,vars0,integrand,terms,pick,keep,out},
(*First IntegralOp Times terms*)
pos=ExtractPositionPattern[exp,IntegralOp[_,_]];
Do[
{vars0,integrand}=Apply[List,pos[[ipos,2]]];
xPrint[{vars0,integrand}];
(*Integrand must be a Product of terms.*)
If[Head[integrand]==Times,
terms=Apply[List,integrand];
pick=Map[ListFreeQ[#,vars]&,terms];
keep=Apply[Times,Pick[terms,pick,False]];
out=Apply[Times,Pick[terms,pick,True]];
pos[[ipos,2]]=out IntegralOp[vars0,keep]
];
xPrint[{vars0,pos[[ipos,2]]}];
,{ipos,Length[pos]}
];
ReplacePartTU[exp,pos]
];

(*
IntegrandWithout[vars_List] simplifies IntegralOp's by moving integrand terms containing any vars_List (Patterns OK) to outside of IntegralOp expression. Moves NumericQ[] terms outside IntegralOp.  *13Jun2013*)
IntegrandWithout[vars_List][exp_]:=Module[{tmp,pos,ipos,args,intg,vars0,integrand,terms,pick,keep,out},
(*First IntegralOp Times terms*)
pos=ExtractPositionPattern[exp,IntegralOp[_,_]];
Do[
(*Only applies to first IntegralOp encountered.*)
{vars0,integrand}=Apply[List,pos[[ipos,2]]];
(*Integrand must be a Product of terms.*)
If[Head[integrand]==Times,
terms=Apply[List,integrand];
pick=Map[ListFreeQ[#,vars]&&!NumericQ[#]&,terms];
keep=Apply[Times,Pick[terms,pick,True]];
out=Apply[Times,Pick[terms,pick,False]];
pos[[ipos,2]]=out IntegralOp[vars0,keep]
];
xPrint[{vars0,pos[[ipos,2]]}];
,{ipos,Length[pos]}
];
ReplacePartTU[exp,pos]
];

(*
switchIntegralOpVariable[dRule_Rule][exp_IntegralOp] switches integration variables specified by dRule_Rule ( systax: d[currentVar]->jacobian d[newVar] ) so IntegralOp[{{currentVar}},integrand]->IntegralOp[{{newVar}},jacobian integrand] Requires varlist->{{x},{y},...}  *20Nov2013*)
switchIntegralOpVariable[dRule_Rule][exp_IntegralOp]:=Module[{tmp,tmp1,varlist,var1,var2,jacob},
tmp=exp;
var1=dRule[[1,1]];
tmp1=ExtractPositionPattern[dRule[[2]], d[_]];
var2=tmp1[[1,2,1]];
jacob=Delete[dRule[[2]],tmp1[[1,1]]];
tmp=tmp/.IntegralOp[{a0___,a_,a1___},b_]:>IntegralOp[{a0,{var2},a1},b jacob]/;a==={var1};
tmp
];

(**)
tuIntegrateOne::usage="tuIntegrateOne[parm_,assumption_:{}][exp_] applies Integrate[] to integration variable parm_ of IntegralOp[] in exp_. assumption_ is optional. *4Jan2015*";
tuIntegrateOne[parm_,assumption_:{}][exp_]:=Block[{tmp=exp,remainingVars},
tmp=tmp/.IntegralOp[a_,b_]:>
If[(remainingVars=DeleteCases[a,parm])!={},
IntegralOp[remainingVars,Integrate[b,If[Length[parm]>1,parm,parm[[1]]](*Indefinite integral check*),Assumptions->assumption]],Integrate[b,If[Length[parm]>1,parm,parm[[1]]],Assumptions->assumption]]/;MemberQ[a,parm];
tmp
];
IntegrateOne[parm_,exp_]:=tuIntegrateOne[parm][exp];

(*
addIntegralOpVar[var_List] adds var_List to IntegralOp[vars,_] var_List must be a List of Lists. *28Nov2012*)
addIntegralOpVar[var_List]:=IntegralOp[a_,b_]:>IntegralOp[Join[a,var],b];
(*
simpleIntegralOpVar[var_,vRule_][exp_IntegralOp] simplifies the integration variables, vars_ in IntegralOp[vars,integrand] when vars_ have coefficients attached.  The integrand is compensated for coefficients of var. The optional vRule_ is to change the limits of the integration in case it is a function of another variable.
Usage: tmp/.int:IntegralOp[a_,b_]:>simpleIntegralOpVar[{ku1[{1,2}],ku1[{3,4}]},
tp->t ][ int ]  /;!FreeQ[a,ku1[{1,2}]]   *26Apr2014*)
simpleIntegralOpVar[var_,vRule_:{}][exp_IntegralOp]:=Module[{tmp=exp,intvars,newv,integrand,apply,vfact},
{intvars,integrand}=Apply[List,exp];xPrint[{intvars,integrand}];
apply[v_]:=Module[{},intvars=Map[
If[FreeQ[#,v],
(*Do nothing*)
#,
(*factor intgrand, adjust limits*)
integrand =integrand(#[[1]]/.v->1);
newv=#;vfact=(#[[1]]/.v->1);newv=Map[#/vfact&,newv];newv[[2;;3]]=newv[[2;;3]]/.vRule;
xPrint[#,":",v,":",vfact,":",newv];
{newv}]&,intvars]
];
Map[apply[#]&,Flatten[{var}]];
IntegralOp[intvars,integrand]/.formIntegralOpVar
]
(*
formIntegralOpVar is a Rule that correctly formats the vars_ in IntegralOp. *29May2014*)
formIntegralOpVar:=IntegralOp[var_List,grand_]:>IntegralOp[Sort[Flatten[{#}]&/@var],grand]
(*
TotalDiffByParts[productexp_, derivative_] generates a expression generated by differentiating by parts where productexp_ is the expression to be converted into a sum of two expressions \[Rule] TotalDerivative - Derivative[term-derivative_] derivative_. 
derivative_ defines the differential used for conversion.  Handles Times|Dot|xDot productexp_'s. *15Jul2014*)
tuTotalDiffByParts::usage="tuTotalDiffByParts[productexp_,derivative_] generates a expression generated by differentiating by parts where productexp_ is the expression to be converted into a sum of two expressions \[Rule] TotalDerivative-Derivative[term-derivative_] derivative_. \[IndentingNewLine]derivative_ defines the differential used for conversion.  Handles Times|Dot|xDot|CenterDot productexp_'s. *15Jul2014*";
tuTotalDiffByParts[productexp_, derivative_]:=Module[{tmp=productexp,var,f1,tmp2,tmp3,dHead=Head[derivative],OP=Times|Dot|xDot|CenterDot,xOP,$s,$placeholder},
{f1,var}=Apply[List,derivative];(*break out derivative arguements*)
tmp=tmp/.op:OP->xOP[op];(*Freeze OPs ordering*)
$s=derivative->f1/.op:OP->xOP[op];
tmp2=tmp/.$s;
$s=derivative->$placeholder/.op:OP->xOP[op];
tmp3=tmp/.$s;
tmp3=dHead[tmp3,var]//.xOP[op_]->op;
tmp3=tmp3//DerivativeExpand[{$placeholder}];
tmp3=tmp3/.$placeholder->f1;
tmp2=dHead[tmp2,var]//.xOP[op_]->op;(*Replace OPs*)
Return[DD[tmp2]- tmp3];
];
TotalDiffByParts:=tuTotalDiffByParts;
TotalDiffByParts1:=tuTotalDiffByParts;(*Compatibility*)

(*TotalDiffByParts1[productexp_, derivative_] generates a expression generated by differentiating by parts where productexp_ is the expression to be converted into a sum of two expressions\[Rule]total derivative + term with double derivative_. 
derivative_ is the differential used for conversion. Corrected to include proper handling of OP's terms. Terms with Dot[] are treated simply.  *22Mar2014*)
(*TotalDiffByParts1[productexp_, derivative_]:=Module[{tmp=productexp,var,f1,tmp1,tmp2,tmp3,dHead=Head[derivative],xderiv,dLocCheck,OP=Times|Dot|xDot,xOP,head,terms,with,without,g,f,gdf,dfg,DEBUG=1},
{f1,var}=Apply[List,derivative];(*break out derivative arguements*)
(*in case \[Exists] power of derivative use only one*)
tmp2=tmp/.derivative\[Rule]f1;
(*for more complex derivatives, but not mixed operations: Times, Dot*)
head=Head[tmp];
terms=Apply[List,tmp];
with=Apply[head,Select[terms,!FreeQ[#,f1]&]]/.f1->f1[var]/.xPartialD->D;
f=Apply[head,Select[terms,FreeQ[#,f1]&]];
g=Integrate[with,var] ;(**)
gdf=head[g,Head[derivative][f,var]];
dfg=Head[derivative][head[f,g],var];(*
Print["tmp: ",tmp];*)
If[FreeQ[tmp,Dot|xDot]
,tmp=dfg-gdf (*This is result if no Dot|xDot is not involved in IBP.*)
,(*The following is simplistic IBP for Dotted expressions.*)
tmp=tmp/.(a:derivative)^n_\[RuleDelayed]a xderiv^(n-1);(*CHECK*)
tmp1=tmp/.derivative\[Rule]dLocCheck;
xPrint[">>",tmp,":",derivative,":",dHead,":",tmp1];
If[!FreeQ[tmp1,dLocCheck],
(*find immediate operator for dLocCheck *)
tmp3=tmp1/.(op:OP)[a___,dLocCheck,b___]->xOP[op];
tmp3=ExtractPattern[xOP[_]][tmp3][[1]];xPrint["tmp3: ","  >>",tmp3,"<< "];
tmp3=tmp3[[1]][dHead[tmp1,var]];xPrint["tmp3: ","  >>",tmp3,"<< "];
tmp3=tmp3//DerivativeExpand[{dLocCheck}];xPrint["tmp3: ","  >>",tmp3,"<< "];
tmp3=tmp3/.dLocCheck->f1;xPrint["tmp3: ",f1," : ",tmp1,"  >>",tmp3,"<< "];
tmp=dHead[tmp2,var]-tmp3//simpleDot3[{}];(*
If[DEBUG>0,Print[">>f1 ",tmp,":",tmp1,":",tmp2,":",f1]];*)
tmp=tmp/.xderiv\[Rule]derivative;(*
Print["TotalDiffByParts1: ",{derivative,tmp,f1,var,tmp1,tmp2}]*)
,
tmp=productexp
]
];
tmp
];*)

(*Generates a list from pure product of terms including Power terms with defined power.*)
Product2List[exp_]:=Module[{},
If[FreeQ[exp,Plus],
exp/.Power[a_,b_]:>DotPower[a,b]/.Times->Dot/.Dot->List,
exp]
];
(*
gatherDerivOp is a Rule that gathers DerivOps into one DerivOp.  Usage: exp_//.gatherDerivOp.
Eg. -\[ImaginaryI] (Subscript[Underscript["\[PartialD]", _], t][(J^-)[t]]-Subscript[Underscript["\[PartialD]", _], t][(J^+)[t]])\[LongRightArrow]Subscript[Underscript["\[PartialD]", _], t][-\[ImaginaryI] ((J^-)[t]-(J^+)[t])]  *10Jul2014*)
gatherDerivOp:={
a_ ( dd:DerivOps)[b_,c_]->dd[a b,c],
 ( dd:DerivOps)[b_,a_]+ (dd:DerivOps)[c_,a_]->dd[ c+ b,a]
};

(*
Expansion Rules for various Differentials {xD[_],xPartialD,xCovariantD} etc. *5Aug2012*)
xPartialDExpand[constants_List]:={tuPartialD,tuPartialDu,DifExpand[xPartialD|xPartialDu,constants]}//Flatten;
xCovariantDExpand[constants_List]:={DifExpand[xCovariantD|xCovariantDu,constants]}//Flatten
xLieDExpand[constants_List]:={DifExpand[xLieD,constants]}//Flatten;
xD\[Delta]Expand[constants_List]:=DifExpand[xD[_]|xDu[_],constants]//Flatten;
(*
Multiple differential expansion Rule  *)
ExpandDerivDvar:={(head:tuDExpand)[a_,b_List]:>head[head[a,First[b]],Rest[b]]/;Length[b]>1,(head:DerivOps)[a_,b_List]:>head[a,b[[1]]]/;Length[b]==1};

(**)
tuDerivativeExpand::usage="tuDerivativeExpand[constants_List][exp_] Expands exp_ with Leibnitz like rules. Constants_List may be specified.  e.g., tuDerivativeExpand[{constants}][exp_]. *16August2012";
tuDerivativeExpand[constants_List:{}][exp_]:=
Block[{tmp=exp,ops=DerivOps},(*Expansion for multiple tuOOps *)
tmp=tmp//.tuDExpandMultiVar;
tmp=tmp//.tuDExpand[ops,constants]
];
DerivativeExpand[constants_List][exp_]:=tuDerivativeExpand[constants][exp]
(**)
tudExpand::usage="tudExpand[\[Delta]1_,constants_List:{}][exp_] expands differential operator \[Delta]1_ using basic Liebnitz Rule[]s. *29Nov2012*";
tudExpand[\[Delta]1_,constants_List:{}][exp_]:=Block[{tmp=exp,sub,name,tmp0,xtmp,ProductOp=Flatten[Times|dotOps|Wedge]},
sub={
(name:\[Delta]1)[a_]:>0/;NumericQ[a],
(name:\[Delta]1)[a_]:>0/;ListMemberQ[a,constants],
(name:\[Delta]1)[a_^n_]:>0/;ListMemberQ[a,constants]&&NumericQ[n],
(name:\[Delta]1)[1/a_]:>0/;ListMemberQ[a,constants],
(name:\[Delta]1)[1/a_^n_]:>0/;ListMemberQ[a,constants]&&NumericQ[n],
(name:\[Delta]1)[Conjugate[a_]]:>Conjugate[name[a]],
(name:\[Delta]1)[ConjugateTranspose[a_]]:>ConjugateTranspose[name[a]],
(name:\[Delta]1)[Transpose[a_]]:>Transpose[name[a]],
(name:\[Delta]1)[Tr[a_]]:>Tr[name[a]],
(name:\[Delta]1)[a__]:>Thread[name[a]]/;(Head[a]==List),
(name:\[Delta]1)[(OP:DerivOps)[T_,i___]]->OP[name[T],i],
(name:\[Delta]1)[Exp[a_]]->Exp[a] name[a],
(name:\[Delta]1)[Log[a_]]-> name[a]/a,
(name:\[Delta]1)[a_^n_]:>n name[a]a^(n-1),
(0&->0) (*in case \[Delta]1 is Derivative[1] which produces 0& for NumberQ. *)
}//Flatten;
While[tmp=!=tmp0,
tmp0=tmp;
tmp=tmp//ExpandAll;
tmp=tmp//.(name:\[Delta]1)[a_ +  b_]->name[a]+ name[b];
tmp=tmp//.(name:\[Delta]1)[(oo:ProductOp)[a_  ,b__]]:>oo[name[a],b]+oo[a ,If[Length[{b}]>1,name[oo[b]],name[b]]];
tmp=tmp//.sub;
];
tmp
];
\[Delta]Expand[\[Delta]1_,constants_List:{}][exp_]:=tudExpand[\[Delta]1,constants][exp];
(**)
tudFnc::usage="tudFnc[var_,dOp_:d,constants_:{}][exp_] apply dOp_ via tudExpand[dOp,constants] and then does d[exp_]->D[exp_,var] dOp_[var]. var_ can be a List of var's. *22Aug2014*";
tudFnc[var_,dOp_:d,constants_:{}][exp_]:=Block[{tmp=exp,vars=Flatten[{var}]},
tmp=tmp//tudExpand[dOp,constants];
tmp=tmp/.dOp[fn_[a__]]:>Apply[Plus,Map[D[fn[a],#]dOp[#]&,vars]];
tmp
];
dFnc[var_,dOp_:d,constants_:{}][exp_]:=tudFnc[var,dOp,constants][exp];
(**)
tudFncRule::usage="tudFncRule[var_,dOp_:d,constants_:{}] creates Rule for applying tudFnc[].  Expands d[ exp_[var_] ] using D[,] operator. Generate D[exp_,var] d[var] dOp_ via \[Delta]Exapnd[dOp,constants] and then does d[exp_]->D[exp_,var] dOp_[var].  var_ can be a List of var's. *22Aug2014*";
tudFncRule[var_,dOp_:d,constants_:{}]:=dOp[exp_]:>tudFnc[var,dOp,constants][dOp[exp]];
dFncRule[var_,dOp_:d,constants_:{}]:=tudFncRule[var,dOp,constants];

(*
dFncfn[fn_,dOp_:d,constants_:{}][exp_] expands exp_ containing term d[fn_[]] and expanding it by taking derivatives of fn_[arg__] for each arg. Works like dFnc but by function name fn_. *29Sep2014*)dFncfn[fn_,dOp_:d,constants_:{}][exp_]:=Module[{tmp=exp,vars,narg},
tmp=tmp//\[Delta]Expand[dOp,constants];
vars=tmp//ExtractPattern[dOp[fn[a__]]]//First;
vars=vars/.dOp[fn[a__]]:>{Length[{a}],a}//Flatten;
narg=Array[$arg,vars[[1]]];
tmp=tmp/.dOp[fn[a__]]:>dOp[fn[Apply[Sequence,narg]]];
tmp=tmp/.dOp[fn[a__]]:>Apply[Plus,Map[D[fn[a],#]dOp[#]&,narg]];
narg=narg->Rest[vars]//Thread;
tmp/.narg
];
(**)
Clear[tuDArgSwitch];
tuDArgSwitch::usage="tuDArgSwitch[derIn_List,derOut_List][exp_] switches order of derivative between variables {derIn_,derOut_} in exp_.  The pair of derivatives must be adjacent pairs with no variables in between. i.e., tuDPartial[tuDPartialu[A,i],j].  *14Nov2014*";
tuDArgSwitch[derIn_List,derOut_List][exp_]:=Block[{tmp=exp,sub,XXX},
tmp=tmp//.\[Delta][a_]->xD[XXX][a,XXX];(*include \[Delta] make uniform arguements*)
If[!IntersectingQ[derIn,derOut],
sub=(OP1:DerivOps)[(OP2:DerivOps)[c_,d_],e_]:>OP2[OP1[c,e],d]/;(MemberQ[derIn,d]&&MemberQ[derOut,e]);
xPrint[sub];
tmp=tmp//.sub,
tmp=SwitchDerivERROR[derIn,derOut][tmp]
];
tmp=tmp//.xD[XXX][a_,XXX]->\[Delta][a]
];
SwitchDeriv[derIn_List,derOut_List][exp_]:=tuDArgSwitch[derOut,derIn][exp];(*Compatibility*)

(* 
Integration by parts assume total derivative->0 example: 
{
xPartialDu[a_,b_]c_:>-xPartialDu[c,b]a/;!(FreeQ[a,T[\[CurlyEpsilon],"u",_]]&&FreeQ[a,T[\[CurlyEpsilon],"d",_]]),
xPartialD[a_,b_]c_:>-xPartialD[c,b]a/;!(FreeQ[a,T[\[CurlyEpsilon],"u",_]]&&FreeQ[a,T[\[CurlyEpsilon],"d",_]])
}*)

(*
IncludeConstantxPartial[constant_List][exp_] will include into xPartialD's the terms in constant_List if they are connected by simple Times.  Changes the Attributes of xTimes.  *17Sep2013*)
IncludeConstantxPartial[constant_List][exp_]:=Module[{tmp,ops=xTimes,xP=xPartialD|xPartialDu,pat,newpat={},cpat,i},
SetAttributes[xTimes,{Flat,Listable,OneIdentity,Orderless,Protected}];
cpat=Apply[Alternatives,constant];
tmp=exp//.(cp:cpat)(xp: xP)[a_,b_]:>xp[xTimes[cp, a],b];
pat=ExtractPositionPattern[tmp,xTimes[__]];
For[i=1,i<=Length[pat],i++,
If[FreeQ[Apply[List,pat[[i,2]]],ops],(*simple ops only*)
xPrint[pat[[i]]];
pat[[i,2]]=pat[[i,2]]/.(op:ops)[(cp:cpat),(xp:xP)[a_,b_]]->xp[op[cp, a],b];
AppendTo[newpat,pat[[i]]];
];
];
SetAttributes[xTimes,{}];
ReplacePartTU[tmp,newpat]/.xTimes->Times
];

Clear[tuOperatorDot2Nest];
tuOperatorDot2Nest::usage="tuOperatorDot2Nest[exp_] replaces Dot|xDot operator expressions in exp_ with nested expression, i.e.,  xDot[op1[_],op2[_],op3[_]]\[Rule]op1[op2[op3[_]]].  The arguement of each operator is expressed as Blank[].  *13Nov2015*";
tuOperatorDot2Nest[exp_]:=Block[{$0=exp,$1,$argn,$Arg,$head,xBlank,$right},
If[!MatchQ[$head=Head[$0],dotOps],Return[$0]];(*Only dotOps allowed*)
$0=$0//.tuOpSimplify[dotOps]/.Blank->$Arg/.$head->xDot;(*Operator arguements specified by Blank[]. Dot causes problems. *)
$1=$0//tuExtractPositionPattern[$Arg[]];xPrint["MM:",$1];
While[Length[$1]>0,
$argn=$1[[-1,1,1]];
$right=$0[[$argn+1;;-1]]/.xDot->xBlank;xPrint["PP ",$argn,":",$1[[-1,2]]=$right," : ",$0];
$0=Drop[tuReplacePart[$0,{$1[[-1]]}],{$argn+1,-1}];
$1=Delete[$1,-1]
];
$0/.xBlank[]->Blank[]//.xBlank->xDot/.xDot->$head
];
(*
evalDifferentialOps[opdef_][exp_] evaluates nested Ops,eg., op1[op2[op3[arg]]] expressed as xDot[op1,op2,op3] where opdef_ is name of DelayedRules the discribes the op's, eg, opdef_[arg_]:={a\[Rule]a[arg],b\[Rule]b[arg],c[yy_]\[Rule]xPartialD[arg,yy]} The label arg must be used to specify the position the arguement. Even multiplicative operation must be specified in opdef_ ,eg., x xPartialD[] . *17Aug2014*)evalDifferentialOps[opdef_][exp_]:=Module[{$=exp,op},
$=$/.dd:xDot[a__]:>Fold[op,arg,Reverse[dd]];
op[a_,b_]:=(b/.opdef[a]);
$
];
(*
$sa[arg_]:={a\[Rule]a[arg],b\[Rule]b[arg],c[yy_]\[Rule]xPartialD[arg,yy]}
xDot[a,c[Y],b]
%//evalDifferentialOps[$sa]
*)
(*
derivativeSummedIndices[varPat_,var_,index_,constants_List][exp_] differentiates exp_ by varPat_ with target variable var_ with implicit summed index_.  Replaces varPat_ index with index_ in exp_.  Returns exp_ with the xPartialD[varPat_,var_] replaced by \[Delta][].  *18Sep2014*)
derivativeSummedIndices[var_,index_,dummy_List,constants_List][exp_]:=Module[{varPat,tmp,ipos},
tmp=UniqueDummyIndices[dummy][exp];
tmp=xPartialD[tmp,var];
tmp=tmp//DerivativeExpand[constants];
ipos=ExtractPositionPattern[var,index];
ipos[[1,2]]=vv__;
varPat=ReplacePartTU[var,ipos];
tmp=tmp/.pp:xPartialD[varPat,var]:>DD[derivativeToDelta[index][pp]]//Expand//simpleDot3[{DD[_]}];
xPrint["KK",tmp];
tmp=tmp/.b__  DD[a_]:>ContractUpDn[\[Delta],{a[[2,1]]}][b a[[1]]];(*CHECK only product of Tensor*)
Return[tmp];
];
(*TEST: T[g,"uu"][i,j]T[x,"d"][i]T[x,"d"][j]//derivativeSummedIndices[T[x,"d"][k],k,{T[g,"uu"][_,_]}]
*)
(*
derivativeToDelta[index_][exp_] converts exp_ == xPartialD[x^(i K),x^(j L)] into \[Delta]^(i j) where x's are Tensors with up-down indices. Return[0] if Tensors are not the same shape or name. Returns {i} the index that is not referenced by derivative index. *18Sep2014*)
derivativeToDelta[index_][exp_]:=Module[{tmp=exp,ipos,ud,lengths},
tmp=Apply[List,tmp];
If[tmp[[1,1]]=!=tmp[[2,1]],Return[0]];(*not same variable name*)
tmp=tuIndexParser/@tmp;
If[(Last[#]&/@tmp)=!=({{},{}}) , Return[0]];
If[ FreeQ[tmp[[2,2]],index] ,Return[0] ];
tmp=#[[2]]&/@tmp;(*up-down indices*)
lengths=Length/@#&/@tmp;
If[lengths[[1]]=!=lengths[[2]],Return[0]];(*different up-down structure*)
ipos=Position[tmp[[2]],index];
tmp=Extract[tmp[[1]],ipos];
tmp={tmp,index}//Flatten;
ud=If[ipos[[1,1]]===1,"ud","du"];
Return[{T[\[Delta],ud][Apply[Sequence,tmp]],tmp}]
];(*
derivativeToDelta::1="general index error";
derivativeToDelta::2="no index found";*)
(*xPartialD[T[x,"uu"][i,k],T[x,"uu"][j,L]]
%//derivativeToDelta[j]
*)

(**)
tuTrigFunc:={Cos,Sin,Tan,Tanh,Cot,Coth,Sinh,Cosh,Sec,Sech,Csc,Csch};
tuTrigDerivativeExpand::usage="tuTrigDerivativeExpand[constants_List:{}][exp_] expands DerivOps of Trig functions by applying Rule[] DerivOps->D.  TODO: replace resulting D[]'s with original DerivOps and determine if constants_List is necessary since arguements of functions are explicit. *17Jan2015*";
tuTrigDerivativeExpand[constants_List:{}][exp_]:=Block[{tmp=exp},tmp=tmp//.(op:DerivOps)[a_,b_]:>D[a,b]/;!ListFreeQ[a,{Cos,Sin,Tan,Tanh,Cot,Coth,Sinh,Cosh,Sec,Sech,Csc,Csch}];
tmp=tmp/. HoldPattern[D[a_,b_]]:>0/;MemberQ[constants,a]
];

tuOrderDerivativeArguements[exp_]:=Block[{tmp=exp,derivOp=xPartialD|xPartialDu|xD[_]|xDu[_]},
tmp=tmp//.(dd1:tuDerivOps)[(dd2:tuDerivOps)[a_,b_],c_]:>dd2[dd1[a,c],b]/;OrderedQ[{b,c}]
];



(**)
tuTensorQ::usage="tuTensorQ[exp_] returns True if exp_ is Tensor or tuDerivOps *11Sep2015*";
tuTensorQ[exp_]:=tuMemberQ[Head[exp],List@@Flatten[Tensor|tuDerivOps]];

(* Adds/modifies index to existing indices.*)
AddBaseIndex[index_List]:=Module[{tmp,DEBUG=0,mname="AddBaseIndex"},
IfDEBUG[mname,DEBUG>0,{index},"in"];
tmp=Append[CompleteBaseIndices,index];
IfDEBUG[mname,DEBUG>0,{tmp},"tmp"];
tmp=tmp/.{index[[1]],a_}->index//DeleteDuplicates;
IfDEBUG[mname,DEBUG>0,{tmp},"tmp"];
DeclareBaseIndices[Apply[Sequence,tmp]];
CompleteBaseIndices
];
(*
CheckIndices applies ParseTermIndices to eech level 2 term in exp_. 4Jul2012*)
CheckIndices[exp_]:=Module[{tmp=exp},
Map[ParseTermIndices[#]&,Apply[List,tmp]]
];
(*
SwitchLabel[exp_,{a,b}] switches label a,b in exp_ *)
SwitchLabel[exp_,mn_List]:=Module[{tmp=exp,XXXX},
tmp=tmp/.First[mn]->XXXX/.Last[mn]->First[mn]/.XXXX->Last[mn]
];
(*SwitchLabel[exp_,{a,b}] switches label a,b in exp_ *)
SwitchLabel[mn_List][exp_]:=Module[{tmp=exp,XXXX},
tmp=tmp/.First[mn]->XXXX/.Last[mn]->First[mn]/.XXXX->Last[mn]
];

(**)
tuIndexSymmetrize::usage="tuIndexSymmetrize[indexPair_List][exp_] symmetrizes exp_ over indexPair_. eg: tuIndexSymmetrize[{i,j}][\!\(\*SubscriptBox[\(A\), \(ij\)]\)]->(\!\(\*SubscriptBox[\(A\), \(ij\)]\)+\!\(\*SubscriptBox[\(A\), \(ji\)]\))/2 . *7Aug2012*";
tuIndexSymmetrize[indexPair_List][exp_]:=Block[{tmp1,tmp2},
(exp+tuIndexSwap[indexPair][exp])/2
];
Symmetrize2[indexPair_List][exp_]:=tuIndexSymmetrize[indexPair][exp];
(**)
tuIndexAntiSymmetrize::usage="tuIndexAntiSymmetrize[indexPair_List][exp_] antisymmetrizes exp_ over indexPair_. eg: tuIndexAntiSymmetrize[{i,j}][\!\(\*SubscriptBox[\(A\), \(ij\)]\)]->(\!\(\*SubscriptBox[\(A\), \(ij\)]\)-\!\(\*SubscriptBox[\(A\), \(ji\)]\))/2 . *7Aug2012*";
tuIndexAntiSymmetrize[indexPair_List][exp_]:=Module[{tmp1,tmp2},
(exp-tuIndexSwap[indexPair][exp])/2
];
AntiSymmetrize2[indexPair_List][exp_]:=tuIndexAntiSymmetrize[indexPair][exp](*Compatibility*)


(*Symmetrize[tensorindex_List][exp_] applies a list of {tensorindex={tensorName,order,index_List} to exp_.  If order < 0 then index_List specify AntiSymmetric relationship.  Uses Tensorial routines. Name changed to SymmetrizeTU to eliminate conflicts with V.9.  *3Jan2013*)
SymmetrizeTU[tensorindex_][exp_]:=Module[{tmp=exp,tmp1,tmp2,up0,dn0,up1,dn1,order,Symmetrize1},
Symmetrize1[tensorindex1_List][exp1_]:=If[tensorindex1[[2]]>0,SymmetrizeSlots[tensorindex1[[1]],tensorindex1[[2]],Symmetric[Apply[Sequence,tensorindex1[[3]]]]][exp1],
SymmetrizeSlots[tensorindex1[[1]],-tensorindex1[[2]],AntiSymmetric[Apply[Sequence,tensorindex1[[3]]]]][exp1]];
Fold[Symmetrize1[#2][#1]&,tmp,tensorindex]
];

(*
symmetrize[vars_List][exp_] symmetrizes exp_ wrt vars_List by summing permutations over vars_List.  NOTE: check for unusual results!! *16Dec2013*)
symmetrize[vars_List][exp_]:=Module[{tmp=exp},
tmp=tmp//ExpandAll;
tmp=Distribute[Hold[symmetrizeSub][1,vars][tmp]];(*Hold to stop evaluation before Distribute.*)
tmp//ReleaseHold
];
(*
antisymmetrize[vars_List][exp_] antisymmetrizes exp_ wrt vars_List by summing permutations over vars_List.  *16Dec2013*)
antisymmetrize[vars_List][exp_]:=Module[{tmp=exp},
tmp=tmp//ExpandAll;
tmp=Distribute[Hold[symmetrizeSub][-1,vars][tmp]];(*Hold to stop evaluation before Distribute.*)
tmp//ReleaseHold
];
symmetrizeSub[sign_,vars_List][exp_]:=Module[{tmp=exp,tmp1,sum=0,pos,posp,is,vs,cycle,perms,nperm,perm},
xPrint["vars,tmp : ",vars,tmp];
pos=ExtractPositionPattern[tmp,vars];
is=Map[#[[1]]&,pos]; 
vs=Map[#[[2]]&,pos]; If[Length[vs]===0,Return[exp]];
perms=Permutations[vs];
nperm=Length[perms];
xPrint[pos,perms];
Do[
posp=Thread[Rule[is,perms[[$$i]]]];
xPrint[posp];
sum=sum+(sign)^($$i-1)ReplacePartTU[tmp,posp],
{$$i,nperm}
];
Return[ sum/nperm]
];

(*OrderSymmetricTensor[tensor_Tensor] Canonical orders all slots of tensor_Tensor.  May be useful in simplifying Tensor expressions. 
*)
OrderSymmetricTensor[tensor_Tensor]:=Module[{tmp,name,ups,dns,indices},
{name,ups,dns}=Apply[List,tensor];
indices=Table[i,{i,Length[ups]}];(*25Apr2012 untested*)
OrderSymmetricTensor[tensor,indices]
];
(*OrderSymmetricTensor[tensor_Tensor,indices_List] Canonical orders slots indices_List (Integers) of tensor_Tensor 
*)
OrderSymmetricTensor[tensor_Tensor,indices_List(*Integer*)]:=Module[{tmp,tmps,tmp0,sub,name,ups,dns,nosym,cases},
{name,ups,dns}=Apply[List,tensor];
cases=Map[{#}&,indices];
nosym=Table[{i},{i,Length[ups]}];
nosym=Delete[nosym,cases];
tmp0=Thread[List[ups,dns]];
tmps=Delete[tmp0,nosym];
tmp=MapIndexed[DeleteCases[#,Void][#]&,tmps];
tmp=tmp//Sort;
tmp=Map[#/.f_[a_]->a&,tmp];
sub=Thread[Rule[cases,tmp]];
tmp=ReplacePart[tmp0,sub]//Transpose;
Tensor[name,tmp[[1]],tmp[[2]]]
];

tuTensorAntiSymmetricOrdered::usage="tuTensorAntiSymmetricOrdered[tensor_Tensor,indices_List(*Integer*)]  Canonically order indices_List Slots of tensor_Tensor multiplied by (-1)^Signature[indices] *22May2015*)";
tuTensorAntiSymmetricOrdered[tensor_Tensor,indices_List(*Integer*)]:=Module[{tmp,tmps,tmp0,sub,name,ups,dns,nosym,cases,signature},
{name,ups,dns}=Apply[List,tensor];
cases=Map[{#}&,indices];
nosym=Table[{i},{i,Length[ups]}];
nosym=Delete[nosym,cases];
tmp0=Thread[List[ups,dns]];
tmps=Delete[tmp0,nosym];
tmp=MapIndexed[DeleteCases[#,Void][#]&,tmps];
signature=Signature[tmp];
tmp=tmp//Sort;
tmp=Map[#/.f_[a_]->a&,tmp];
sub=Thread[Rule[cases,tmp]];
tmp=ReplacePart[tmp0,sub]//Transpose;
signature Tensor[name,tmp[[1]],tmp[[2]]]
];
OrderAntiSymmetricTensor[tensor_Tensor,indices_List]:=tuTensorAntiSymmetricOrdered[tensor,indices];(*Compatibility*)

(*OrderAntiSymmetricTensor[tensor_Tensor] Canonical orders all slots of anti-symmetric tensor_Tensor.  May be useful in simplifying Tensor expressions. 
*)
OrderAntiSymmetricTensor[tensor_Tensor]:=Module[{tmp,name,ups,dns,indices},
{name,ups,dns}=Apply[List,tensor];
indices=Table[i,{i,Length[ups]}];(*25Apr2012 untested*)
OrderAntiSymmetricTensor[tensor,indices]
];

(**)
tuOrderRiemann::usage="tuOrderRiemann[exp_] canonically orders the indices of a 4-indexed Riemann tensor ((\!\(\*SuperscriptBox[\(R\), \(i\)]\)\!\(\*SubscriptBox[\()\), \(jkl\)]\)] *24Jan2015* ";
tuOrderRiemann[exp_]:=Block[{tmp,pos},
tmp=exp;
pos=tmp//tuExtractPositionPattern[Tensor[R,_,_]];
pos=pos/.T[R,"uddd"][i_,j_,k_,l_]:>-T[R,"uddd"][i,j,l,k]/;OrderedQ[{l,k}];
pos=pos/.T[R,"uddd"][i_,j_,k_,l_]:>-T[R,"uddd"][j,i,k,l]/;OrderedQ[{j,i}];
tmp=tuReplacePart[tmp,pos]
];
(**)
tuSwap::usage="tuSwap[this_,that_][exp_] swaps the symbols this_ for that_ in exp_. *16Feb2016*";
tuSwap[this_,that_][exp_]:=Block[{tmp=exp,pair={this,that},XXXX,YYYY},
If[this=!=that,
pair=SortBy[pair,Length];
tmp=tmp//.pair[[2]]->XXXX//.pair[[1]]->YYYY//.XXXX->pair[[1]]//.YYYY->pair[[2]];
];
tmp
];
Swap[pair_List][exp_]:=tuSwap[pair[[1]],pair[[2]]][exp];(*Compatibility*)
(*Swaps sequential pairs of anything in expressions.*)
Swaps[pairs_List][exp_]:=Module[{tmp=exp,DEBUG=0,mName="Swaps"},
IfDEBUG[mName,DEBUG>0,{tmp,pairs,Depth[pairs]},"tmp,pairs"];
tmp= Fold[Swap[#2][#1]&,exp,pairs];
tmp
];
(*
SwapVarFromAtoB[var_,A_List,B_List] Swap var_ in A_ for the corresponding one in B_.  Returns {A_List,B_List} with var_ Swapped.   *8May2013*)
SwapVarFromAtoB[var_,A_List,B_List]:=Module[{tmp,pos,xpos,i,len,xA=A,xB=B},
If[Length[xA]==Length[xB],
pos=Position[xA,var,1]//Flatten;
len=Length[pos];
If[len>0,
For[i=1,i<=len,i++,
xpos=pos[[i]];
tmp=xB[[xpos]];
xB[[xpos]]=xA[[xpos]];
xA[[xpos]]=tmp;
];
];
];
{xA,xB}
];

(* Returns list of positions in list_ of form_ or {} if none found.*)
IndicesQ[list_List,form_]:=Module[{i,pos={}},
For[i=0,i<=Length[list],i++,If[list[[i]]===form,AppendTo[pos,i]]];
pos
];

(*ContractMetric[\[Delta]_][term_Times] Einstein like contraction (up/dn) of term_Times using \[Delta]_ as metric variable. The choice of contraction indices is not controlled and does not check for proper up/dn relationship in term_Times, only the presence of \[Delta] indices as symbol in term_Times.  Assumes properly formed index relationships in term_Times.  Works only for 2-component \[Delta]_ metric functions.  Operates on numerator only. Leaves Tr[\[Delta]_] to be computed outside of this routine.  *28Jul2013.*)
ContractMetric[\[Delta]_][term_]:=Module[{tmp=Numerator[term],denom=Denominator[term],test,pos,i,contractindex,dummy,gindex,flatgindex},
If[Head[term]=!=(Times|xTimes)&&FreeQ[term,Tensor[\[Delta],_,_]],Return[term]];
While[tmp=!=test,
test=tmp;
dummy=tuIndexParser[tmp] [[1]];(*
Print["test: ",test,dummy];*)
pos=ExtractPositionPattern[tmp,Tensor[\[Delta],_,_]];
For[i=1,i<=Length[pos],i++,
gindex=tuIndexParser[pos[[i,2]]] [[2]];(*
Print["gindex:",gindex];*)
If[gindex[[1]]===gindex[[2]],(*Self contraction?*)
(*tmp=ReplacePartTU[tmp,{pos[[i,1]]->NDim}];*)
(*Leave Tr[g] to be determined<-depends on dimension.*)
Break[]
,(*else*)
flatgindex=Flatten[gindex];(*
Print["g: ",pos[[i,2]]];*)
If[(contractindex=Intersection[flatgindex,dummy])=!={},(*contract?*)
tmp=Delete[tmp,pos[[i,1]]];(*
Print["g1: ",pos[[i,2]]," : ",tmp];*)
If[!MemberQ[dummy,flatgindex[[1]]],(*contraction direction?*)
flatgindex=Reverse[flatgindex]];(*
Print[">>",contractindex,":",flatgindex];*)
If[gindex[[1]]=={}||gindex[[2]]=={},(*UpDn adjust*)tmp=UpDownIndexSwap[flatgindex[[1]]][tmp]
];
tmp=ReplaceIndexTU[Apply[Sequence,flatgindex]][tmp];
Break[];
];
Continue[]
];
];
];
tmp/denom
];

(*ContractUpDn[\[Delta]_][exp_] Einstein like contraction (up/dn) of terms in exp_ using \[Delta]_ as metric variable contained in each term of exp_. The choice of contraction indices is not controlled and does not check for proper up/dn relationship in exp_, only the presence of \[Delta] indices as symbol in exp_. Assumes properly formed index relationships in exp_. Works only for 2-component \[Delta]_ functions. 
Replaced *1Mar2013.*)
ContractUpDn[\[Delta]_][exp_]:=Module[{tmp=exp(*Do ExpandAll to Reduce complexity. But may generate inconsistent dummy indices.*),pos,tmp1,indices,sub,up,dn,test,dummy,contract,i,gindex,contractindex},
(*Extract Times[\[Delta],...]*)
pos=ExtractPositionPattern[tmp,Tensor[\[Delta],a_,b_] c_];(* BUG does not find straight Times term *)
pos=Map[#[[1]]->ContractMetric[\[Delta]][#[[2]]]&,pos];
tmp=ReplacePartTU[tmp,pos]
];
(* [\[Delta]_,index_List][exp_] Einstein like contraction (up/dn) of terms in exp_ using \[Delta]_ as metric variable. The contraction uses indices ONLY in index_List.  Does nothing if exp_ indices in error, only the presence of \[Delta] indices as symbol in exp_. 
\[Delta]_ is Tensor of rank 2.  Expanded to handle ops at Level 1.  *19Sep2014.*)
ContractUpDn[\[Delta]_,index_List][exp_]:=Module[{tmp=ExpandAll[exp](*Minimize complex expressions*),sub,test,ops=Times|Dot|xDot},
tmp=tmp//simpleDot3[{Tensor[\[Delta],up_List,dn_List]}];(*Assume \[Delta]_ is scalar*)
tmp=tmp/.op:ops[ A__]:>tuIndexContractUpDn[op,\[Delta],index](*Only level 1 product terms.*)
];

(**)
Clear[tuIndexEliminateEta]
tuIndexEliminateEta::usage="tuIndexEliminateEta[exp_,noEta_,eta_,ups_List,dns_List,index_List] applies Einstein summing in exp_ over Tensor[eta_,ups_,dns_] containing indices index_. noEta_ contains exp_ without the eta_ Tensor. *11Nov2015*";
tuIndexEliminateEta[exp_,noEta_,eta_,ups_List,dns_List,index_List]:=Block[{up,dn,upi,dni},
up=DeleteCases[ups,Void];
dn=DeleteCases[dns,Void];
xPrint["tuIndexEliminateEta:",noEta,",",eta,",",up,dn,index];
upi=Intersection[up,index];
dni=Intersection[dn,index];xPrint["upi,dni:",upi,dni,Length[Flatten[upi,dni]]];
If[ListFreeQ[Flatten[up,dn],index]||up===dn||Length[Flatten[upi,dni]]<1,Return[exp]];(*eta has no sum index or same indices*)
xPrint["BB:",up,dn,index,upi,dni];
If[Length[up]==1&&Length[dn]==1,(*updn situation*)
If[ListMemberQ[upi,index],
tuIndexReplace[upi[[1]],dn[[1]]][noEta],
tuIndexReplace[dni[[1]],up[[1]]][noEta]],
If[Length[up]==2,(*upup or dndn situation*)
If[MemberQ[index,up[[1]]],xPrint["UU ",up[[1]],":",up[[2]],":",noEta,":",exp];
tuIndicesRaise[up[[1]],up[[2]]][noEta],
tuIndicesRaise[up[[2]],up[[1]]][noEta]],
If[MemberQ[index,dn[[1]]],
tuIndexLower[dn[[1]],dn[[2]]][noEta],
tuIndexLower[dn[[2]],dn[[1]]][noEta]]
]
]
];

Clear[tuIndexContractUpDn];
tuIndexContractUpDn::usage="tuIndexContractUpDn[\[Delta]_,index_List][exp_] Einstein contracts over index_List for Tensor[\[Delta]_,_,_] contained in exp_. *11Nov2015*";
tuIndexContractUpDn[\[Delta]_,index_List][exp_]:=Block[{$=exp,doIt,$test,dummy,error,updn,tensors,$deltas,$pos,$a},(*terms are product of these operators*)
{dummy,updn,error}=tuIndexParser[$];xPrint["00: ",$,":",{dummy,updn,error},":",index];
If[Intersection[dummy,index]=={}||error!={},Return[$]];(*No proper dummy index*)
(***********)
$deltas=$//tuExtractPositionPattern[Tensor[\[Delta],_,_]];(*List of possible deltas*)
xPrint["$deltas: ",$deltas,":",$];
Do[
$pos=$deltas[[ipos]];xPrint["$pos: ",$pos];
If[tuHasNoneQ[$pos[[2]],index],Continue[] ];(*No index*)
$pos=$//tuExtractPositionPattern[  $pos[[2]]  ];xPrint[">>> ",$pos];(*Get $ position*)
If[$pos=={},Continue[]];(*Not found*)
xPrint[">>",$," : ",\[Delta],":",$pos[[1,2,2]],$pos[[1,2,3]]];
$a=Delete[$,$pos[[1,1]]]; xPrint["$a: ",$,$a,\[Delta],$pos[[1,2,2]],$pos[[1,2,3]]];
$=tuIndexEliminateEta[$,$a,\[Delta],$pos[[1,2,2]],$pos[[1,2,3]],index]
,{ipos,Length[$deltas]}
];
$
];
tuIndexContractUpDn[exp_,\[Delta]_,index_]:=tuIndexContractUpDn[\[Delta],index][exp];
subContractUpDn[exp_,\[Delta]_,index_List]:=tuIndexContractUpDn[\[Delta],index][exp];(*Compatibility*)

(*ContractUpDnNot[\[Delta]_,index_List][exp_] Einstein like contraction (up/dn) of terms in exp_ using \[Delta]_ as metric variable. The contraction does NOT use indices in index_List, but the use of other indices is not controlled.  Does not check for proper up/dn relationship in exp_, only the presence of \[Delta] indices as symbol in exp_. Assumes properly formed index relationships in exp_.
CHECK WITH NEW VERSION of ContractUpDn
Repaired*11Dec2012.*)
ContractUpDnNot[\[Delta]_,index_List][exp_]:=Module[{tmp=ExpandAll[exp](*Minimize complex expressions*),sub,up,dn,test,dummy},
test[A_,from_,to_]:=!FreeQ[A,from]&&!MemberQ[{from,to},Void]&&ListFreeQ[from,index];
sub={
Tensor[\[Delta],{up1_,up2_},{dn1_,dn2_}]A_:>LowerIndexTU[dn1,dn2][A]/;test[A,dn1,dn2],
Tensor[\[Delta],{up1_,up2_},{dn1_,dn2_}]A_:>LowerIndexTU[dn2,dn1][A]/;test[A,dn2,dn1],
Tensor[\[Delta],{up1_,up2_},{dn1_,dn2_}]A_:>RaiseIndexTU[up1,up2][A]/;test[A,up1,up2],
Tensor[\[Delta],{up1_,up2_},{dn1_,dn2_}]A_:>RaiseIndexTU[up2,up1][A]/;test[A,up2,up1],
term:Tensor[\[Delta],ups_,dns_]A_:>If[
Length[up=DeleteCases[ups,Void]]==1&&
Length[dn=DeleteCases[dns,Void]]==1&&
(dummy=tuIndexParser[Tensor[\[Delta],ups,dns]A][[1]])=!={},(*expect only 1 index*)
xPrint[dummy,dn,up];
If[MemberQ[dn,dummy[[1]]],ReplaceIndexTU[dummy[[1]],up[[1]]][A],
If[MemberQ[up,dummy[[1]]],ReplaceIndexTU[dummy[[1]],dn[[1]]][A]]  ]
,
term
]
};
tmp=tmp//.sub
]

(*
Contract[\[Delta]_][exp_] does Kronecker like contraction on exp_ containing Subscript[\[Delta], i,j ]over all i,j indices. No control over which index is used.  Ignores up/dn positions of indices. 
*16Oct2014.*)
Contract[\[Delta]_][exp_]:=Block[{$tmp=ExpandAll[exp](*Minimize complex expressions*),contract,$XX},
(**)
contract[term_,updn0_List,A_]:=Block[{updn,ret=term},
updn=DeleteCases[Flatten[updn0],Void];xPrint[updn];
If[Length[updn]==2,
If[updn[[1]]===updn[[2]],ret=A,xPrint[Xupdn];
If[!ListFreeQ[A,updn],xPrint[xupdn];
ret=If[FreeQ[A,updn[[1]]],
A/.Rule[updn[[2]],updn[[1]]],
A/.Rule[updn[[1]],updn[[2]]]],
xPrint[A];
],
Print[ret];
]
];
ret
];
$tmp//.dd:Tensor[\[Delta],ups_,dns_]A_:>contract[Tensor[$XX[\[Delta]],ups,dns]A,{ups,dns},A]/.$XX[a_]->a (*The $XX helps cover multiple \[Delta]'s. *)
];

tuKroneckerDeltaEliminate::usage="tuKroneckerDeltaEliminate[\[Delta]_,index_List][exp_] eliminates KroneckerDelta \[Delta] indices specified by index_List found in exp_. Leaves 1 in place of \[Delta][] in exp_.  Currently, Works only first Kronecker \[Delta].  *12Oct2015*";
tuKroneckerDeltaEliminate[\[Delta]_,index_List][exp_]:=Block[{$=exp,$1,$s},
$1=$//tuExtractPattern[Tensor[\[Delta],_,_]];
$1=Select[$1,!tuFreeQ[#,index]&];
$1={$1[[1]]};(*Only contract on First \[Delta]*)
$s=tuIndexParser[$1][[2]]//Flatten;
$s=$s[[1]]->$s[[2]];
$s=tuRuleSolve[$s,index];
$=$/.$s/.{T[\[Delta],"dd"][a_,a_]->1,T[\[Delta],"uu"][a_,a_]->1,T[\[Delta],"ud"][a_,a_]->1,T[\[Delta],"du"][a_,a_]->1};
$
];

(*Contract[\[Delta]_,index_List][exp_] does Kronecker contraction on terms in exp_ containing \[Delta] over ONLY indices contained in index_List.  Ignores up/dn positions of indices. 
26Apr2012.*)
Contract[\[Delta]_,index_List][exp_]:=Module[{tmp=ExpandAll[exp](*Minimize complex expressions*),sub,updn},
sub={
Tensor[\[Delta],ups_,dns_]A_:>If[
Length[(updn=Flatten[{DeleteCases[ups,Void],DeleteCases[dns,Void]}])]==2&&! ListFreeQ[A,updn]&&!ListFreeQ[updn,index],
(A/.updn[[1]]:>updn[[2]]/;MemberQ[index,updn[[1]]]/.updn[[2]]:>updn[[1]]/;MemberQ[index,updn[[2]]]),
Tensor[\[Delta],ups,dns]A
]
};
tmp=tmp//.sub
];
(*ContractNot[\[Delta]_,index_List][exp_] does Kronecker contraction on terms in exp_ containing \[Delta] over all indices EXCEPT ones in index_List.  Ignores up/dn positions of indices. 
26Apr2012.*)
ContractNot[\[Delta]_,index_List][exp_]:=Module[{tmp=ExpandAll[exp](*Minimize complex expressions*),sub,updn},
sub={
Tensor[\[Delta],ups_,dns_]A_:>If[
Length[(updn=Flatten[{DeleteCases[ups,Void],DeleteCases[dns,Void]}])]==2&&! ListFreeQ[A,updn],
(A/.updn[[1]]:>updn[[2]]/;!MemberQ[index,updn[[1]]]/.updn[[2]]:>updn[[1]]/;!MemberQ[index,updn[[2]]]),
Tensor[\[Delta],ups,dns]A
]
};
tmp=tmp//.sub
];

(*
SwapListsN[a1_List,b1_List,i_Integer] swaps element i_Integer between a1_List and b1_List. *13Sep2012*)
SwapListsN[a1_List,b1_List,i_Integer]:=Module[{$h,a=a1,b=b1},
$h=a[[i]];  a[[i]]=b[[i]];  b[[i]]=$h;
{a,b}
];
(**)
tuIndicesLower::usage="tuIndicesLower[from_,to_:{}][exp_] lowers from_ indices to to_ indices. from_ and to_ may be lists of indices then the lowering is performed pairwise.  If to_ is omitted or not equal in Length then to_ = from_.  *29May2015*";
tuIndicesLower[from_,to_:{}][exp_]:=Block[{$=exp,$s,$f=Flatten[{from}],$t=Flatten[{to}]},
If[Length[$f]!=Length[$t],$t=$f];
$s=Thread[tuIndexLowerAll[$f,$t]];
Fold[#2[#1]&,$,$s]
];
LowerIndexTU1[from_List,to_List][exp_]:=tuIndicesLower[from,to][exp];(*Compatibility*)
LowerIndexTU[from_,to_][exp_]:=tuIndicesLower[from,to][exp];(*Compatibility*)
(**)
tuIndexLowerAll::usage="tuIndexLowerAll[from_,to_][exp_] lowers one index from_ to to_ found in exp_.  Handles indices in DerivOpsD to DerivOpsU *20Jun2015*";
tuIndexLowerAll[from_,to_][exp_]:=
Block[{upD,dnD,opD,subd,ipos,ip,xexp,xfrom,xto,$Pattern},
opD=DerivOpsU;
upD=Apply[List,opD];
dnD=Apply[List,DerivOpsD];
subd=Thread[Rule[upD,RemovePatterns[dnD]]];
subd=Map[Map[#/.a_:>If[Head[a]===Symbol,a,Head[a]]&,#]&,subd];
{xexp,xfrom,xto}=Map[#//.Pattern->$Pattern&,{exp,from,to}];
xexp=xexp//.t$:Tensor[A_,u_List,d_List]:>tuIndexLower[xfrom,xto][t$];
xexp=xexp//.(OP:opD)[a_,b_]:>(OP//.subd)[a,xto]/;(b//.Pattern->$Pattern)==xfrom;
xexp//.$Pattern->Pattern
];
(**)
tuIndexRaiseAll::usage="tuIndexRaiseAll[from_,to_][exp_] raises one index from_ to to_ found in exp_.  Handles indices in DerivOpsD to DerivOpsU *20Jun2015*"
tuIndexRaiseAll[from_,to_][exp_]:=
Block[{upD,dnD,opD,subd,ipos,ip,xexp,xfrom,xto,$Pattern},
opD=DerivOpsD;
dnD=Apply[List,opD];
upD=Apply[List,DerivOpsU];
subd=Thread[Rule[dnD,RemovePatterns[upD]]];
subd=Map[Map[#/.a_:>If[Head[a]===Symbol,a,Head[a]]&,#]&,subd];
{xexp,xfrom,xto}=Map[#//.Pattern->$Pattern&,{exp,from,to}];
xexp=xexp//.t$:Tensor[A_,u_List,d_List]:>tuIndexRaise[xfrom,xto][t$];
xexp=xexp//.(OP:opD)[a_,b_]:>(OP/.subd)[a,xto]/;(b//.Pattern->$Pattern)==xfrom;
xexp//.$Pattern->Pattern
];
(**)
tuIndicesRaise::usage="tuIndicesRaise[from_,to_:{}][exp_] raises from_ indices to to_ indices. from_ and to_ may be lists of indices then the raising is performed pairwise.  If to_ is omitted or not equal in Length then to_ = from_.  *29May2015*";
tuIndicesRaise[from_,to_:{}][exp_]:=Block[{$=exp,$s,$f=Flatten[{from}],$t=Flatten[{to}]},
If[Length[$f]!=Length[$t],$t=$f];
$s=Thread[tuIndexRaiseAll[$f,$t]];
Fold[#2[#1]&,$,$s]
] ;
RaiseIndexTU1[from_List,to_List][exp_]:=tuIndicesRaise[from,to][exp];(*Compatibility*)
RaiseIndexTU[from_,to_][exp_]:=tuIndicesRaise[from,to][exp];(*Compatibility*)

tuIndexRaise::usage="tuIndexRaise[var1_,var2_][A_Tensor] raises index var1_ to var2_ in A_Tensor. eg: $exp/. tt:Tensor[\[Gamma],{_},{ii:_}]\[RuleDelayed]tuIndexRaise[ii,ii][tt] *23Apr2015*";
tuIndexRaise[var1_,var2_][A_Tensor]:=
Block[{Name,u,d,$swap},{Name,u,d}=Apply[List,A];
{d,u}=If[MemberQ[d,var1],d=d//.var1->$swap;SwapVarFromAtoB[$swap,d,u],{d,u}];
{d,u}={d,u}//.$swap->var2;
Tensor[Name,u,d]
];
RaiseTensorIndex[A_Tensor,var1_,var2_]:=tuIndexRaise[var1,var2][A];

(**)
tuIndexLower::usage="tuIndexLower[var1_,var2_][A_Tensor] lowers index var1_ to var2_ in A_Tensor. eg: $exp/. tt:Tensor[\[Gamma],{ii:_},{_}]\[RuleDelayed]tuIndexLower[ii,ii][tt] *23Apr2015*";
tuIndexLower[var1_,var2_][A_Tensor]:=
Block[{Name,u,d,$swap},{Name,u,d}=Apply[List,A];
{u,d}=If[MemberQ[u,var1],u=u//.var1->$swap;SwapVarFromAtoB[$swap,u,d],{u,d}];
{d,u}={d,u}//.$swap->var2;
Tensor[Name,u,d]
];
LowerTensorIndex[A_Tensor,var1_,var2_]:=tuIndexLower[var1,var2][A];

(**)
tuIndexReplace::usage="tuIndexReplace[from_,to_][exp_] replaces all indices in exp_ from from_ to to_. *16Sep2015"
tuIndexReplace[from_,to_][exp_]:=Module[{
upD,dnD,subd,
ipos,xexp,xfrom,xto,ip,$Pattern
},
upD=DerivOpsU;
dnD=DerivOpsD;
{xexp,xfrom,xto}=Map[#//.Pattern->$Pattern&,{exp,from,to}];
xexp=xexp//.Tensor[A_,u_,d_]:>Tensor[A,ReplacePart[u,ip->xto],d]/;
Length[u]>0&&(ipos=Position[u,xfrom,1])=!={}&&(ip=ipos[[1,1]])>0;
xexp=xexp//.Tensor[A_,u_,d_]:>Tensor[A,u,ReplacePart[d,ip->xto]]/;
(Length[d]>0&&(ipos=Position[d,xfrom,1])=!={}&&(ip=ipos[[1,1]])>0);
xexp=xexp//.(OP:Apply[Alternatives,Join[upD,dnD]])[a_,b_]:>OP[a,xto]/;(b//.Pattern->$Pattern)==xfrom;xPrint["ReplaceIndexTU:",xexp];
xexp//.$Pattern->Pattern
];
ReplaceIndexTU[from_,to_][exp_]:=tuIndexReplace[from,to][exp];(*Compatibility*)
(**)
tuTensorIndexSwap::usage="tuTensorIndexSwap[slot1_Integer,slot2_Integer][tensor_Tensor] swaps slot1_ and slot2_ indices of tensor_  *22May2015*";
tuTensorIndexSwap[slot1_Integer,slot2_Integer][tensor_Tensor]:=Block[{$n,$u,$d,$},
{$n,$u,$d}=Apply[List,tensor];xPrint[{$n,$u,$d}];
If[Length[$u]<Max[slot1,slot2],Return[tensor]];(*Input Error. Do nothing.*)

If[$u[[slot1]]=!=Void&&$u[[slot2]]=!=Void,
$=$u[[slot1]];$u[[slot1]]=$u[[slot2]];$u[[slot2]]=$,
If[$d[[slot1]]=!=Void&&$d[[slot2]]=!=Void,
$=$d[[slot1]];$d[[slot1]]=$d[[slot2]];$d[[slot2]]=$,
If[$d[[slot1]]=!=Void&&$u[[slot2]]=!=Void,
$=$d[[slot1]];$d[[slot1]]=$u[[slot2]];$u[[slot2]]=$,
If[$u[[slot1]]=!=Void&&$d[[slot2]]=!=Void,
$=$u[[slot1]];$u[[slot1]]=$d[[slot2]];$d[[slot2]]=$
]]]];
Apply[Tensor,{$n,$u,$d}]
];
(**)
tuIndexSwap::usage="tuIndexSwap[indexPair_List][exp_] swap indexPair in exp_. EG: IndexSwap[{i,j}][\!\(\*SubscriptBox[\(A\), \(ikj\)]\)]->\!\(\*SubscriptBox[\(A\), \(jki\)]\)   *4Nov2014*";
tuIndexSwap[indexPair_List][exp_]:=Block[{tmp=exp,index1,index2,$ii,heads=DerivOps,subi,nestop,CX},
{index1,index2}=indexPair;
(*Handles AtomQ and Listable indices exp_*)
subi[i_]:=If[AtomQ[i],
i/.index1->$ii/.index2->CX[index1]/.$ii->CX[index2],
Map[If[AtomQ[#],#/.index1->$ii/.index2->CX[index1]/.$ii->CX[index2],#]&,i]];
nestop[term_]:=term/.(h:heads)[A_,i_]:>h[nestop[A],subi[i]];
tmp=tmp/.Tensor[A_,u_,d_]:>Tensor[A,subi[u],subi[d]];
tmp=nestop[tmp];
tmp//.CX[a_]->a
];
IndexSwap:=tuIndexSwap;
(**)
tuIndexSwapUpDown::usage="tuIndexSwapUpDown[index_][exp_] swaps UpDn position of index_ in exp_. index_ may be List in which case the indices are Fold[]d over List. *22Oct2015*";
tuIndexSwapUpDown[index_][exp_]:=Block[{tmp=exp,XXXX,YYYY},
If[Head[index]=!=List,
tmp=tmp//LowerIndexTU[index,XXXX];
tmp=tmp//RaiseIndexTU[index,YYYY];
tmp=tmp/.XXXX->index/.YYYY->index,
tmp=Fold[tuIndexSwapUpDown[#2][#1]&,exp,index]
];
tmp
];
UpDownIndexSwap[index_][exp_]:=tuIndexSwapUpDown[index][exp];(*Compatibility*)

(*
UpDownIndexSwap[upos_Integer,dpos_Integer][tensor_Tensor] swaps indices of tensor_Tensor by position [upos_Integer,dpos_Integer] There are NoChecks on inputs. *23July2012 *)
UpDownIndexSwap[upos_Integer,dpos_Integer][tensor_Tensor]:=Module[{tmp=tensor,$d,$u,xtmp},
xtmp=tmp=Apply[List,tmp];
$u=tmp[[2]];
$d=tmp[[3]];
tmp[[2]]=ReplacePart[$u,{dpos->$d[[dpos]],upos->$d[[upos]]}];
tmp[[3]]=ReplacePart[$d,{upos->$u[[upos]],dpos->$u[[dpos]]}];
Apply[Tensor,tmp]
];
(* Eliminates index m_ from exp_ containing \[Delta]uu[m_,n].  NEEDS expanding to \[Delta]ud, \[Delta]du, \[Delta]dd.  A strick version would check for proper up and down indices. *)
Simplify\[Delta]uu[exp_,m_]:=Module[{tmp=exp,tmp1,ind=m,DEBUG=0,mname="Simplify\[Delta]uu"},
While[tmp1=!=tmp,
tmp1=tmp;
tmp=tmp//.{
a_ \[Delta]@uu[m,b_]:>(a/.m->b)/;!FreeQ[{a},m]&&m=!=b,
a_ \[Delta]@uu[b_,m]:>(a/.m->b)/;!FreeQ[{a},m]&&m=!=b
};
IfDEBUG[mname,DEBUG>0,{m,tmp},"{m,tmp}"];
];
tmp
];

(*Simple index swapping routine across xPartialD.  A^m xPartialD[Subscript[A, m],n]-> Subscript[A, m] xPartialD[A^m,n].  WARNING there are no checks. *)
RaiseIndexInxPartialD[exp_]:=Module[{tmp,DEBUG=0,mName="RaiseIndexInxPartialD"},
IfDEBUG[mName,DEBUG>0,{exp},"input"];
tmp=exp/.c_ xPartialD[a_,b_]:>SwapIndexPartialD[{c,a,b}];
tmp=exp/.c_ xCovariantD[a_,b_]:>SwapIndexPartialD[{c,a,b}];
IfDEBUG[mName,DEBUG>0,{tmp},"tmp"];
tmp
];
(*Swaps indices in list {A^m,Subscript[A, m],mu}-> Subscript[A, m]xPartialD[A^m,mu].  Only one way->
 NEEDS two-way swap *)
SwapIndexPartialD[list_]:=Module[{indexdown,tmp1=list,DEBUG=0,mName="SwapIndexPartialD"},
indexdown=ParseTermIndices[tmp1[[2]]][[2,2]];
IfDEBUG[mName,DEBUG>0,{tmp1,indexdown},"tmp1,indexdown"];
If[indexdown=!={},
indexdown=First[indexdown];
tmp1[[1]]=tmp1[[1]]//LowerIndex[indexdown,indexdown];
tmp1[[2]]=tmp1[[2]]//RaiseIndex[indexdown,indexdown];
];
IfDEBUG[mName,DEBUG>0,{tmp1},"tmp1"];
tmp1[[1]]xPartialD[tmp1[[2]],tmp1[[3]]]
];

(*Lowers all xPartialDu[a_,b_]->g@uu[dum[b],b]xPartialD[a,dum[b]]*)
xPartialDuLower[exp_]:=Module[{},MetricContractG[exp/.xPartialDu[a_,b_]->xPartialD[a,dum[b]]g@uu[dum[b],b]]/.dum[a_]->a
];

(*g Tensor contractions.  Replaced by MetricContract[g_][exp_] except for Dimension *)
ContractG={
g@uu[a_,b_]g@dd[a_,c_]->g@ud[b,c],
g@uu[a_,b_]g@dd[c_,a_]->g@ud[b,c],
g@uu[b_,a_]g@dd[a_,c_]->g@ud[b,c],
g@uu[b_,a_]g@dd[c_,a_]->g@ud[b,c],

g@ud[a_,b_]g@dd[a_,c_]->g@dd[b,c],
g@ud[a_,b_]g@dd[c_,a_]->g@dd[b,c],
g@du[b_,a_]g@dd[a_,c_]->g@dd[b,c],
g@du[b_,a_]g@dd[c_,a_]->g@dd[b,c],

g@ud[a_,b_]g@du[a_,c_]->g@du[b,c],
g@ud[a_,b_]g@ud[c_,a_]->g@du[b,c],
g@du[b_,a_]g@du[a_,c_]->g@du[b,c],
g@du[b_,a_]g@ud[c_,a_]->g@du[b,c],

g@du[a_,a_]->Tr\[Eta],
g@ud[a_,a_]->Tr\[Eta]
};

(* Simple metric (g@uu,g@dd,g@ud,g@du) index contraction routine. g@uu[a,b]Addd[c,a,d]-> Adud[c,b,d]. Replaced by MetricContract[g_][exp_] *)
MetricContractG[exp_]:=Module[{tmp=exp,tmp1,pos,i,DEBUG=0},
For[i=0,tmp=!=tmp1,i++,
tmp1=tmp;
tmp=tmp//.ContractG;
tmp=tmp/.( g@uu[a_,b_]|g@uu[b_,a_])Tensor[T_,{c___},{d___}]:>Tensor[T,ReplacePart[{c},(pos=Position[{d},b])->a],ReplacePart[{d},pos->Void]]/;MemberQ[{d},b];
tmp=tmp/.( g@dd[a_,b_]|g@dd[b_,a_])Tensor[T_,{c___},{d___}f]:>Tensor[T,ReplacePart[{c},(pos=Position[{c},b])->Void],ReplacePart[{d},pos->a]]/;MemberQ[{c},b];
tmp=tmp/.( g@du[a_,b_]|g@ud[b_,a_])Tensor[T_,{c___},{d___}]:>Tensor[T,{c},ReplacePart[{d},(pos=Position[{d},b])->a]]/;MemberQ[{d},b];
tmp=tmp/.( g@ud[a_,b_]|g@du[b_,a_])Tensor[T_,{c___},{d___}]:>Tensor[T,ReplacePart[{c},(pos=Position[{c},b])->a],{d}]/;MemberQ[{c},b];
(* for tensors with arguements *)
tmp=tmp/.( g@uu[a_,b_]|g@uu[b_,a_])Tensor[T_,{c___},{d___}][arg___]:>Tensor[T,ReplacePart[{c},(pos=Position[{d},b])->a],ReplacePart[{d},pos->Void]][arg]/;MemberQ[{d},b];
tmp=tmp/.( g@dd[a_,b_]|g@dd[b_,a_])Tensor[T_,{c___},{d___}][arg___]:>Tensor[T,ReplacePart[{c},(pos=Position[{c},b])->Void],ReplacePart[{d},pos->a]][arg]/;MemberQ[{c},b];
tmp=tmp/.( g@du[a_,b_]|g@ud[b_,a_])Tensor[T_,{c___},{d___}][arg___]:>Tensor[T,{c},ReplacePart[{d},(pos=Position[{d},b])->a]][arg]/;MemberQ[{d},b];
tmp=tmp/.( g@ud[a_,b_]|g@du[b_,a_])Tensor[T_,{c___},{d___}][arg___]:>Tensor[T,ReplacePart[{c},(pos=Position[{c},b])->a],{d}][arg]/;MemberQ[{c},b];
If[DEBUG>0,Print[CR["MetricContractG: "],{tmp,pos}]];
];
tmp
];

(*Contracts metric tensor, g_, in exp_ where possible.  DOES NOT RECOGNIZE g_. *)
(*Does not handle g[i,j]fn[a[i]+b[i]] like expressions Replaced MatricContract[]*)
MetricContractGexp[g_][exp_]:=Module[{exp1=exp,tmp,tmp1,tmp2,pos,ipos,tmpp,tmpp1,posg,iposg,indexg,post,ipost,gUsed},
(*First do simple g contractions*)
exp1=Expand[exp1]//MetricContractG;
(*extract g_ products assuming g's are not embedded.*)
pos=ExtractPositionPattern[exp1,Times[a___,Tensor[g,_,_],b___]];
For[ipos=1,ipos<=Length[pos],ipos++,
tmpp1=tmpp=pos[[ipos,2]];
posg=ExtractPositionPattern[tmpp,Tensor[g,_,_]];
(* Go through and contract each g Tensor in product tmpp  *)
For[iposg=1,iposg<=Length[posg],iposg++,
(*eliminate one g and test for possible summing Tensors(may include other g's)*)
tmpp1=tmpp1/.Last[ posg[[iposg]] ]->1;
(*Examine remaining Tensors(possibly imbedded)*)
post=ExtractPositionPattern[tmpp1,Tensor[_,_,_]];
List["post:",post];
gUsed=posg;
For[ipost=1,ipost<=Length[post],ipost++,
tmp=post[[ipost,2]]posg[[iposg,2]];
tmp1=tmp//MetricContractG;
If[tmp=!=tmp1,(*If contracted, store new and do not use g again*)
post[[ipost,2]]=tmp1;gUsed[[iposg,2]]=1;posg[[iposg,2]]=1;
];
];
tmpp1=ReplacePart[tmpp1,post];
];
tmp=Apply[Times,Map[Last,gUsed]];
pos[[ipos,2]]=tmp tmpp1;
];
exp1=ReplacePart[exp1,pos]
];

(**)
tuMetricContract::usage="tuMetricContract[g_][exp_Times] Contracts (alla Einstein) exp_Times (Times expression) over metric g_.* 13Sep2012*";
tuMetricContract[g_][exp_Times]:=Block[{gterm,$u0,$d,$u,$d0,$c,tmp=exp,tmp1,tmp2,gpos,gpos1,ipos,pos,gvar,Igvar,Itmp2,gpat=g@uu[a_,b_]|g@dd[a_,b_]|g@ud[a_,b_]|g@du[a_,b_]},
gpos1=gpos=tmp//tuExtractPositionPattern[gpat];xPrint[gpos1];
While[tmp=!=tmp1,tmp1=tmp;
gpos1=gpos=tmp//tuExtractPositionPattern[gpat];
For[ipos=1,ipos<=Length[gpos]&&tmp==tmp1,ipos++,
pos=gpos1[[ipos,1]];gvar=gpos1[[ipos,2]];
tmp2=ReplacePart[tmp,{pos}->1];
Igvar=tuIndexParser[gvar];
Itmp2=tuIndexParser[tmp2];
xPrint["tmp2:",{tmp2,Itmp2}];
tmp=Which[
($u0=Intersection[ Itmp2 [[2,1]],$d=Igvar[[2,2]]])=!={}&&Length[$d]==2,
LowerIndexTU[$u0[[1]],$c=Complement[$d,{$u0[[1]]} ]  [[1]]][tmp2] ,
($d0=Intersection[ Itmp2 [[2,2]],$u=Igvar[[2,1]]])=!={}&&Length[$u]==2,
RaiseIndexTU[$d0[[1]],$c=Complement[$u,{$d0[[1]]} ]  [[1]]][tmp2] ,
($u0=Intersection[ Itmp2 [[2,1]],$d=Igvar[[2,2]]])=!={}&&Length[$d]==1,
ReplaceIndexTU[$u0[[1]],$c= Igvar[[2,1]] [[1]] ] [tmp2] ,
($d0=Intersection[ Itmp2 [[2,2]],$u=Igvar[[2,1]]])=!={}&&Length[$u]==1,
ReplaceIndexTU[$d0[[1]],$c=Igvar[[2,2]]  [[1]]][tmp2]  ,
True,
tmp
];(*xPrint[Imply,gvar[$u0[[1]],$c]\[Rule]{tmp}];*)
];
];
tmp
];
MetricContract[g_][exp_Times]:=tuMetricContract[g][exp];
(**)
tuMetricContractAll::usage="tuMetricContractAll[g_][exp_] applies tuMetricContract[g][term] over all Times[] terms in exp_. ";
tuMetricContractAll[g_][exp_]:=Block[{},
tmp=Expand[exp]/.term:HoldPattern[Times[a__]]:>tuMetricContract[g][term]
];
MetricContractAll[g_][exp_]:=tuMetricContractAll[g][exp];

(*Adds contraction: gud[a_,a_] | gdu[a_,a_]-> dimension **May want to separate this function** 27Mar2012 *)
MetricContract[g_,trace\[Eta]_][exp_]:=Block[{tmp=Expand[exp]},
tmp=tmp//tuMetricContract[g];
tmp=tmp//.{T[g,"ud",{a_,a_}]->trace\[Eta],T[g,"du",{a_,a_}]->trace\[Eta]}
];
(**)
MetricContractAll[g_,trace\[Eta]_][exp_]:=Block[{tmp},
tmp=Expand[exp]/.term:HoldPattern[Times[a__]]:>MetricContract[g,trace\[Eta]][term]
];
(*Wick rotation of Vector contractions *)
VectorContractWickSub={Tensor[a_,{\[Mu]_},{Void}]Tensor[b_,{Void},{\[Mu]_}]:>-Tensor[a,{space@\[Mu]},{Void}]Tensor[b,{Void},{space@\[Mu]}]/;FreeQ[\[Mu],space],
Tensor[a_,{\[Mu]_},{Void}][c_]Tensor[b_,{Void},{\[Mu]_}]:>-Tensor[a,{space@\[Mu]},{Void}][TUc]Tensor[b,{Void},{space@\[Mu]}]/;FreeQ[\[Mu],space],
Tensor[a_,{\[Mu]_},{Void}]Tensor[b_,{Void},{\[Mu]_}][c_]:>-Tensor[a,{space@\[Mu]},{Void}]Tensor[b,{Void},{space@\[Mu]}][c]/;FreeQ[\[Mu],space],
Tensor[a_,{\[Mu]_},{Void}][c_]Tensor[b_,{Void},{\[Mu]_}][d_]:>-Tensor[a,{space@\[Mu]},{Void}][c]Tensor[b,{Void},{space@\[Mu]}][d]/;FreeQ[\[Mu],space]
};
(*ExpandSpaceTimeIndex Einstein expands exp_ each index_List over timespace@index_List.  This routine is to facilitate time and spatial vector notation.  Note the index arguement does not need timespace flavor. Added \[Delta]-functionexpansion.  BUG: does not accept indices in functional form. NOTE: Use EinsteinSum[] instead!! DO NOT USE PROBLEMS *14Dec2012*)
ExpandSpaceTimeIndex[index_List][exp_]:=Module[{tmp=exp,indexST,DEBUG=0,mname="ExpandSpaceTimeIndex"},
indexST=timespace/@index;
IfDEBUG[mname,DEBUG>0,{indexST,exp},"{indexST,exp}"];
(*\[Delta]-function need special treatment.  Only for Length[index_List]==1. .*)
tmp=Map[tmp/. ddd:\[Delta][a_]:>If[!FreeQ[Flatten[ExpressionIndices[a]],#] ,
IndexSwap[{#,timespace@0}][\[Delta][a]]IndexSwap[{#,timespace@1}][\[Delta][a]]  ,
ddd]&,index]  [[1]];
IfDEBUG[mname,DEBUG>0,{tmp},"{tmp\[Delta]}"];

tmp=IndexSwap[{#,timespace@#}][tmp]&/@index//First;
tmp=tmp//.timespace@timespace@i_->timespace@i;(*Eliminate doubles*)
IfDEBUG[mname,DEBUG>0,{tmp},"{tmp}"];
If[Head[tmp]===Rule,
tmp=Apply[Rule,SumExpansion[indexST][Apply[List,tmp]]],
tmp=tmp//SumExpansion[indexST]
];
tmp=tmp/.IndexChange->IndexChangeTU;(*In case IndexChange fails*)
IfDEBUG[mname,DEBUG>0,{tmp},"{tmp1}"];
tmp=tmp/.g->\[Eta]
];

(*
timespaceindex[index_List][exp_] replaces all indices \[Element] index_List in exp_ to timespace@indices.  *11Jul2013*)
timespaceindex[index_List][exp_]:=Module[{tmp,tmp0=exp,pos,sub,UDrules,$i,$in},
sub=Map[#->timespace@#&,DeleteDuplicates[index]];
pos=ExtractPositionPattern[tmp0,IndexVarPatterns];
For[$i=1,$i<=Length[pos],$i++,
xPrint[pos[[$i,2]],$in=Flatten[tuIndexParser[pos[[$i,2]]]]];
If[ListMemberQ[$in,index],pos[[$i,2]]= pos[[$i,2]]/.sub];
];
xPrint[pos];
ReplacePartTU[tmp0,pos]
];

(*
GroupTimeSpaceProducts[exp_] expands dummy indices into timespace@{0,1} grouping the paired result in xDot[] *12Oct2012*)
GroupTimeSpaceProducts[exp_]:=Module[{tmp,ExpandDummies,subgroup},
subgroup=(A:Tensor[a__])(B:Tensor[ b__]):>xDot[A,B]/;!FreeQ[tuIndexParser[A B][[1]],timespace]&&FreeQ[A B,xDot];
ExpandDummies[prod_]:=Module[{dummies,tmp1=prod},
dummies=tuIndexParser[prod][[1]];
tmp1=Fold[(ExpandSpaceTimeIndex[{#2}][#1]/.subgroup)&,tmp1,dummies];
tmp1
];
tmp=exp//Expand;
tmp=tmp/.HoldPattern[Times[a__]]:>ExpandDummies[Times[a]]
];
(*
UpDn2Cos is Rule for taking Einstein UpDn timespace indices of products and raising them to contravariant indices and applying Cos[] to timespace@1 components.   *30Nov2012*)
UpDn2Cos:={T[Subscript[k_, i_],"d"][timespace@1]T[Subscript[k_, j_],"u"][timespace@1]:>-T[ Subscript[k, i],"u"][timespace@1]T[ Subscript[k, j],"u"][timespace@1] Cos[Subscript[\[Theta], Sort[{i,j}]]],T[Subscript[k_, i_],"d"][timespace@0]T[Subscript[k_, j_],"u"][timespace@0]->T[Subscript[k, i],"u"][timespace@0]T[Subscript[k, j],"u"][timespace@0]}

(*Sums over indexRange, e.g., {i,1,3} in expression exp_.  Preprocesses with DotExpand and Expand.  Does not check proper reference to index. *)
SumIndex[indexRange_List][exp_]:=Module[{tmp,out=0,index=First[indexRange],DEBUG=0,mname="SumIndex"},
tmp=exp//.DotExpand//Expand;
IfDEBUG[mname,DEBUG>0,{index,tmp,Length[tmp]},"index,tmp,Length[tmp]"];
For[$i=1,$i<=Length[tmp],$i++,
$t=tmp[[$i]];
IfDEBUG[mname,DEBUG>0,{index,$t},"index,t"];
If[!FreeQ[$t,index],
$t=Sum[$t,indexRange];
IfDEBUG[mname,DEBUG>0,{$i,$t},"$i,$t"];
];
out+=$t;
];
out
];
(*
ExpandIndex[indexRange_List][exp_] sums exp_ for every term with Head in ops  containing index pair over range specified in indexRange_. *2Mar2013*)
ExpandIndex[indexRange_List][exp_]:=Module[{tmp=ExpandAll[exp],ops=Times|Dot|Wedge|xDot,$t,$ind,head,term},
$ind=Thread[indexRange[[1]]->Range[Apply[Sequence,Rest[indexRange]]]];
tmp=tmp//.(OP:ops)[a___,b_Plus,c___]:>Distribute[OP[a,b,c]]//ExpandAll;
tmp=tmp/.(OP:ops)[a__]:>If[MemberQ[PairedDummies[Times[a]],First[indexRange]],
Apply[Plus,Map[OP[a]/.#&,$ind]],OP[a]];
tmp
];

(*Rotates indices in index_List of exp_ n_ times. e.g., RotateIndex[{i,j,k},2][A[i,j,k]]->A[k,i,j].  n>0 Rotates left, n<0 Rotates right. *)
RotateIndex[index_List,n_Integer][exp_]:=Module[{tmp=exp,cycle,nindex=index,nn=Abs[n],sub},
cycle=Range[Length[index]];
If[n>0,cycle=Reverse[cycle]];
Do[  nindex=Permute[nindex,Cycles[{cycle}]],{nn}  ];
sub=MapThread[Rule,{index,nindex}];
tmp=tmp/.sub
];
(**)
tuIndexAdd::usage="tuIndexAdd[uploc_:Null,upvalue_:Null,dnloc_:Null,dnvalue_:Null][tensor_Tensor] adds indices to tensor_Tensor at uploc_ with upvalue_ and at dnloc_ with value dnvalue_.  Careful of the dnloc_ after specifying uploc_. *8Dec2015*";
tuIndexAdd[uploc_:Null,upvalue_:Null,dnloc_:Null,dnvalue_:Null][tensor_Tensor]:=Block[{uplist,dnlist},
uplist=tensor[[2]];
dnlist=tensor[[3]];
If[uploc>0,
uplist=Insert[uplist,upvalue,uploc];
dnlist=Insert[dnlist,Void,uploc]
];
If[dnloc>0,
uplist=Insert[uplist,Void,dnloc];
dnlist=Insert[dnlist,dnvalue,dnloc]
];
Tensor[tensor[[1]],uplist,dnlist]
];
PrependIndex[t_Tensor,du_,val_]:=If[du==="u",tuIndexAdd[1,val,Null,Null][t],tuIndexAdd[Null,Null,1,val][t]];(*Compatibility*)
AddUpIndex[uploc_,upvalue_][tensor_Tensor]:=tuIndexAdd[uploc,upvalue,Null,Null][tensor];(*Compatibility*)
AddDnIndex[dnloc_,dnvalue_][tensor_Tensor]:=tuIndexAdd[Null,Null,dnloc,dnvalue][tensor];(*Compatibility*)

(*Prepends index val_ in du_ position to Tensor t_.  3Apr2012 *)
(*PrependIndex[t_Tensor,du_,val_]:=Module[{},
tmp=Apply[List,t];
If[du==="d",tmp[[2]]=Prepend[tmp[[2]],Void];tmp[[3]]=Prepend[tmp[[3]],val]];
If[du==="u",tmp[[2]]=Prepend[tmp[[2]],val ];tmp[[3]]=Prepend[tmp[[3]],Void]];
Apply[Tensor,tmp]
];*)
(*AddUpIndex[uploc_,upvalue_][tensor_Tensor] add up index in tensor_ at location uploc_ with value upvalue_ .*)
(*AddUpIndex[uploc_,upvalue_][tensor_Tensor]:=Module[{uplist,dnlist},
uplist=tensor[[2]];
dnlist=tensor[[3]];
uplist=Insert[uplist,upvalue,uploc];
dnlist=Insert[dnlist,Void,uploc];
Tensor[tensor[[1]],uplist,dnlist]
];*)
(*AddDnIndex[dnloc_,dnvalue_][tensor_Tensor] add down index in tensor_ at location dnloc_ with value dnvalue_ .*)
(*AddDnIndex[dnloc_,dnvalue_][tensor_Tensor]:=Module[{uplist,dnlist},
uplist=tensor[[2]];
dnlist=tensor[[3]];
uplist=Insert[uplist,Void,dnloc];
dnlist=Insert[dnlist,dnvalue,dnloc];
Tensor[tensor[[1]],uplist,dnlist]
]*)
(*AddUpDnDum[tensor_Tensor] adds corresponding up,dn a_ index to dum[a_] indices*)
AddUpDnDum[tensor_Tensor]:=Module[{tmp=tensor,tmpc},
tmpc=Cases[tmp[[2]],dum[_]];
Do[tmp=AddDnIndex[-1,tmpc[[i]][[1]]][tmp],{i,Length[tmpc]}];
tmpc=Cases[tmp[[3]],dum[_]];
Do[tmp=AddUpIndex[-1,tmpc[[i]][[1]]][tmp],{i,Length[tmpc]}];
tmp
];
(**)
tuIndexDeleteAt::usage="tuIndexDeleteAt[loc_Integer][tensor_Tensor] remove index at location loc_Integer of tensor_Tensor. *23Jul2015*";
tuIndexDeleteAt[loc_Integer][tensor_Tensor]:=Block[{uplist,dnlist},
uplist=tensor[[2]];
dnlist=tensor[[3]];
uplist=Delete[uplist,loc];
dnlist=Delete[dnlist,loc];
Tensor[tensor[[1]],uplist,dnlist]
];
DeleteIndex[loc_Integer][tensor_Tensor]:=tuIndexDeleteAt[loc][tensor];(*Compatibility*)
(**)
tuIndexDelete::usage="tuIndexDelete[ind_][tensor_Tensor] removes index ind_ of tensor_Tensor. *23Jul2015*";
tuIndexDelete[ind_][tensor_Tensor]:=Block[{uplist,dnlist,uppos,dnpos,delete},
uplist=tensor[[2]];
dnlist=tensor[[3]];
uplist=Position[uplist,ind];
dnlist=Position[dnlist,ind];
delete={uplist,dnlist}//Flatten//DeleteDuplicates;
uplist=Delete[tensor[[2]],delete];
dnlist=Delete[tensor[[3]],delete];
Tensor[tensor[[1]],uplist,dnlist]
];
DeleteIndex[index_][tensor_Tensor]:=tuIndexDelete[index][tensor];(*Compatibility*)
(**)
tuIndexDeleteAll::usage="tuIndexDeleteAll[index_][exp_] applies tuIndexDelete on all Tensor[]s in exp_ over index_. index_ can be List[]. *17Nov2015*";
tuIndexDeleteAll[index_][exp_]:=Block[{$=exp,$index=Flatten[{index}],$s},
$s=Thread[tt:Tensor[_,_,_]:>tuIndexDelete[#][tt]&/@$index];xPrint[$s];
$=tuRepeat[$s][$]
];

(*DeleteIndexExcept[ind_][tensor_Tensor] deletes indices of tensor_ that match ind_ *)
DeleteIndexExcept[ind_][tensor_Tensor]:=Module[{uplist,dnlist,uppos,dnpos,delete},
uplist=tensor[[2]];
dnlist=tensor[[3]];
tmp=uplist=Map[If[!MemberQ[{#},ind]&&#=!=Void,delete[#],#]&,uplist];
uppos=Position[uplist,delete[_]];
uplist=Delete[uplist,uppos];
dnlist=Delete[dnlist,uppos];
dnlist=Map[If[!MemberQ[{#},ind]&&#=!=Void,delete[#],#]&,dnlist];
dnpos=Position[dnlist,delete[_]];
uplist=Delete[uplist,dnpos];
dnlist=Delete[dnlist,dnpos];
Tensor[tensor[[1]],uplist,dnlist]
];

(*TensorIndex\[Delta]{tensor_List}[exp_] changes Tensors, e.g., Auu[i,j,k], in tensor_List, e.g., {Auu[i,l_,m_]},  where the Patterns, {l_,m_}, indicates indices to act on, to form Auu[i,dum[j],dum[k]] . \[Delta]du[dum[j],j] . \[Delta]du[dum[k],k] where {dum[j],dum[k]} represent Einstein summed indices.  The purpose of this function is to transform exp_ to a form that allows EinsteinSum expressions to be functionally differentiated by Mathematica properly in Tensor expressions.  The action of \[Delta] will yield proper form.
*)
Tensor\[Delta]Index[tensor_List][exp_]:=Module[{tmp(*apply on each Times term*),
sub,sub1,sub0,f1,dd},
xPrint["tensor:",tensor];
(*change Tensor\[Rule] \[Delta].Tensor*)
tmp=Map[#/.Tensor[a_,b_,c_]:>Tensor[\[Delta],b,c].Tensor[a,b,c]&,tensor];
xPrint["tmp:",tmp];
tmp=tmp/.Pattern->xPattern/.xPattern[a_,Blank[]]->dum[a];
xPrint["tmp:",tmp];
tmp=tmp/.Tensor[\[Delta],a_,b_]:> SwapUpDownIndices[Flatten[{Cases[a,dum[_]],Cases[b,dum[_]]}]][Tensor[\[Delta],a,b]];
tmp=tmp/.Tensor[\[Delta],a_,b_]:>DeleteIndexExcept[dum[_]][Tensor[\[Delta],a,b]];
xPrint["tmp:",tmp];
tmp=tmp/.Tensor[\[Delta],a_,b_]:>AddUpDnDum[Tensor[\[Delta],a,b]];
sub=Thread[Rule[tensor,tmp]];
exp/.sub
];

(*Changes all indices of tensor_Tensor to Pattern.*)
TensorIndexPattern[tensor_Tensor]:=Module[{tmp,up,dn},
up=Map[If[Head[#]=!=Pattern&&#=!=Void,Pattern[#,Blank[]],#]&,tensor[[2]]];
dn=Map[If[Head[#]=!=Pattern&&#=!=Void,Pattern[#,Blank[]],#]&,tensor[[3]]];
Tensor[tensor[[1]],up,dn]
];
(**)
tuD2tuDOp::usage="tuD2tuDOp[tuDOp_,arg_List:{}][exp_] converts Derivative[] expressions into tuDOps_ expression.  Arguements to functions that are objects of Derivative[] can be added via arg_List. tuDOps_\[Rule]{xPartialD|xCovariantD|xD[_]|tuDPartial|tuDCovariant|tuDs[_]|tuDDown[_]|xPartialDu|xCovariantDu|xDu[_]|tuDPartialu|tuDCovariantu|tuDsu[_]|tuDUp[_]|tuDPartial|tuDCovariant|tuDs[_]|tuDDown[_]|tuDPartialu|tuDCovariantu|tuDsu[_]|tuDUp[_]|tuDLie}  *15Aug2015*";
tuD2tuDOp[tuDOp_,arg_List:{}][exp_]:=Block[{tmp=exp,makeVar},
makeVar[ndd_List,vars_List]:=Block[{out},
xPrint["<<",ndd,":",vars];
out=MapIndexed[ConstantArray[vars[[First[#2]]],#1]&,ndd]//Flatten;
out
];
tmp=tmp/.Derivative[nd__][fn_][ind__]:>Fold[tuDOp,
If[Length[arg]>0,fn[Apply[Sequence,arg]],fn[ind]],makeVar[{nd},{ind}]]
];
D2xPartialD[arg_List:{}][exp_]:=tuD2tuDOp[xPartialD,arg][exp];(*Compatibility*)

(*
Dupdn2xPartialD[exp_] Converts D[fn_[\[Mu][up],\[Nu][dn],...],\[Mu][up],\[Nu][dn],...] form to xPartialD[xPartialDu[fn,\[Mu]],\[Nu]] form.  Usage: D2xPartialD[exp]  *1Jan2014*)
Dupdn2xPartialD[exp_]:=exp//.{HoldPattern[Derivative[n__][A_][i__]]:>Dupdn2xPartialD1[{n},A,{i}]}
Dupdn2xPartialD1[dslot_List,var_,updn_List]:=Module[{tmp,Ds,updnseq},
xPrint[Length[dslot],": ",var,":",Length[updn],":",updn];
updnseq=Apply[Sequence,updn];
If[Length[dslot]===Length[updn],
tmp=Thread[List[dslot,updn]];xPrint[dslot,":",var,":",updn,":",tmp];
Ds=DeleteCases[tmp,List[0,_]];(*no derivative*)xPrint[var,", ",Ds];
tmp=Fold[If[FreeQ[#2,up],xPartialD[#1,Head[#2[[2]]]],xPartialDu[#1,Head[#2[[2]]]]]&,var,Ds];
tmp,
Derivative[Apply[Sequence,dslot]][var][updnseq]](*Do nothing return*)
];
(*Eliminate next arguement in exp_ 
Usage: EliminateArguments[{A[a_], B[a_]}][exp_ with A[a][b] B[d][e] ]->A[a]B[d]
Needs named patterns, e.g., a_   
 12Apr2012 *)
EliminateArguments[var_List][exp_]:=Module[{sub={},tmp=exp,XXX},
sub=MapIndexed[Append[sub,#1[arg__]->XXX[#2,RemovePatterns[#1]]]&,var]//Flatten;
tmp=exp//.sub;
tmp=tmp//.XXX[n_,A_]->A
];
(*
Hamiltonian[lagrangian_,partialD_List,constant_List] computes the Hamiltonian from a lagrangian_ given a partialD_List and constant_List.  The partialD_List are a list of xPartialD[_,t] variables to be used in the Lagrangian -> Hamiltonian equation and constant_List is a list of constants in lagrangian_.  NOTE: a Dot is introduced in computing the derivative term to allow for vector-like equations.  *25Jul2013*)
Hamiltonian[lagrangian_,partialD_List,constant_List]:=Module[{tmp,tmpL=lagrangian,partial,partialDt,i,accum=0},
For[i=1,i<=Length[partialD],i++,
partialDt=partialD[[i]];
tmp=xPartialD[lagrangian,partialDt]//DerivativeExpand[constant];
tmp=tmp/.xPartialD[a_,dd:xPartialD[b_,t]]:>0/;FreeQ[a,dd]//.simpleDot2[{constant}];
accum+=tmp. partialDt;
];
accum-lagrangian//.simpleDot2[{constant}]//Simplify(*add Dot for possible vector equation*)
];
(*
EulerLagrangeTensor[Lagrangian_,field_List,indexDeriv_List] compute Euler-Lagrange(EL) equations for Lagrangian_ for each Tensor field in field_List where its participanting index variables are indicated by Patterns. Builds arguements for EulerEquations[], but participating field indices are lowered for the calculation. (WARNING: The same variable with different indices are treated as different variables.  Convert these variables to same indices by using metric tensor.  The result has participating field indices in the lower position and there are multiples EL equations, one for each active index variable.  Need to specify all field_List that are functions of indexDeriv_List.  WARNING: This routine is not recognized via Initialization.  This block must be executed manually.   TODO: Convert these variables to have same index by using metric tensor. *2Jan2014*)
EulerLagrangeTensor[Lagrangian_,
field_List,(*field to evaluate in EL calculation. Pattern for indices indicates indexDeriv_List variable. *)
indexDeriv_List(*index variables taking part in EL calculation, includes xPartialD and xPartialDu indices. *)
]:=Module[{tmp,vars={},fields={},sub,subvar,subLower,xfield=field,xfieldLower,lagrangianLower,fieldVar,fieldLag,indexPattern,fieldLow},(*
Needs["VariationalMethods`"];*)
(*modified inputs(indices) to be compatible. Field index_List indices all lower.*)
xfield=field/.Pattern->xPattern;xPrint[xfield];
indexPattern=ExtractPattern[xPattern[i_,_]][xfield]//DeleteDuplicates;
fieldLow=Fold[LowerIndexTU[#2,#2][#1]&,xfield,indexPattern];
subLower=DeleteCases[Flatten[{Thread[xfield==fieldLow]}],True]/.Equal->Rule;xPrint[xfield,fieldLow,subLower];
subLower=Map[MapAt[#/.xPattern[i_,_]->i&,#,2]&,subLower]/.xPattern->Pattern;
fieldLow=fieldLow/.xPattern->Pattern;
xPrint["NEW subLower:",subLower];xReturn[];
fieldLag=Map[ExtractPattern[#][Lagrangian]&,field]/.subLower//Flatten//DeleteDuplicates;xPrint["fieldLag:",fieldLag];xReturn[];
(*build variables for functional: f\[Rule]f[vars]. up,dn indices are treated as independent index variables.*)
Map[AppendTo[vars,{#[up],#[dn]}]&,indexDeriv];
vars=Flatten[vars];xPrint["vars:",vars];xReturn[];
(*add vars to field\[Rule]field[vars] Rule.*)
fieldVar=Map[Apply[RemovePatterns[#],vars]&,fieldLag];xPrint[fieldVar];
subvar=Thread[Rule[fieldLag,fieldVar]];xPrint["subvar:",subvar];xReturn[];
lagrangianLower=Lagrangian/.subLower;xPrint["L: ",lagrangianLower];xReturn[];
tmp=lagrangianLower//xPartialD2Dupdn[indexDeriv,fieldLow];(*
xxtmp={xxPartialD2Dupdn[indexDeriv,fieldLow][lagrangianLower]};*)
(*Apply EulerEquations*)
xPrint[">>",tmp,";",indexDeriv,";",fieldLow];xReturn[];
fieldVar=DeleteDuplicates[fieldVar];
xPrint["EulerEquations[",tmp,",\n",fieldVar,",\n:",vars,"\n]"];xReturn[];
(*xxtmp=xEulerEquations[tmp,fieldVar,vars]*);
tmp=EulerEquations[tmp,fieldVar,vars];
xPrint[">>",tmp,"\n:",fieldVar,"\n:",vars];xReturn[];
(*Convert D to xPartialD*)
tmp=tmp//Dupdn2xPartialD;
xfield=xfield/.xPattern->Pattern;(*Is this compatible?*)
xPrint["xfield",xfield,", ",tmp];
tmp=xEliminateArguments[xfield][tmp];
tmp=tmp/.xEliminateArguments->EliminateArguments;
tmp
];

(*Test routine*)
testEulerLagrangeTensor:={
Block[{tmp,tmp0,var,$L,$tensorsymbol,$var,$dummy},
xPrint[
tmp0=tmp=Get[$HomeDirectory<>"/Mathematica/AZee/AZee.VI.1.out"]];
tmp=tmp[[2]]/.{\[Alpha]1->\[Lambda],\[Alpha]2->\[Nu],\[Alpha]3->\[Mu]};
{$L,$var,$dummy}=PrepareLagrangian[{a}][tmp];
AppendTo[$dummy,\[Lambda]];(*does not find \[Lambda]*)
Print["Arg:",tmp0,"\nvar: ",$var,"\ndummy: ",$dummy];
Print[{tmp\[LongRightArrow]((tmp0=EulerLagrangeTensor[$L,$var,$dummy]//Flatten)//Column)}];
(*Rearrange indices*)
tmp0=MapAt[IndexSwap[{\[Mu],\[Nu]}][#]&,tmp0,{{1},{3}}]//Expand;
tmp0=Map[If[!FreeQ[#,T[a,"u"][_]],#/.tt:b_ f_[T[a,"u"][i_],d_]|b_ g_ [f_[T[a,"u"][i_],d_],e_]:>UpDownIndexSwap[i][tt]]&,tmp0]/.orderxPartialD[{\[Mu],\[Nu]}]//LowerIndexTU[\[Nu],\[Nu]];
Print["Added together: ",Framed[tmp0/.OrderAll\[Epsilon]//AddRules//Expand]];
];

Block[{tmp,tmp0,p0,var,$L,$tensorsymbol,$var,$dummy},tmp=xPartialD[T[x,"d"][k],t]xPartialDu[T[x,"u"][k],t]/2-g T[x,"d"][k];
{$L,$var,$dummy}=PrepareLagrangian[{x}][tmp];
Print["Arg:",tmp,"\nvar: ",$var,"\ndummy: ",$dummy={t}];
Print[{tmp\[LongRightArrow]((tmp0=EulerLagrangeTensor[$L,$var,{t}]//Flatten)//Column)}];
Print["Added together: ",Framed[tmp0//AddRules//Expand//LowerIndexTU[k,k]]];
];
};

(*
PrepareLagrangian[tensorsymbol_List][lagrangian_] prepares lagrangian_ expression for use in EulerLagrangeTensor[]. tensorsymbol_List is a list of Tensor symbols to be evaluated in the EL equations.  Returns {modified Lagrangian, field_List, dummy_List} where field_List are the Tensors found in lagrangian_ and dummy_List is a list of indices that are extracted for EL variables.  One may need to modify dummy_List and field_List based upon particular needs. The lagrangian_ is modified by up/dn  symmetrizing the indices of tensorsymbol_List.  The result of EulerLagrangeTensor[] contains redundant solutions due to the symmetrization of the indices. *6Jan2014*)
PrepareLagrangian[tensorsymbol_List][lagrangian_]:=Module[{$L=lagrangian,$tensorsymbol=tensorsymbol,$var,$dummy,i},
$var=Map[{ExtractPattern[T[#,"u"][i_]][$L],ExtractPattern[T[#,"d"][i_]][$L]}&,$tensorsymbol]//Flatten//DeleteDuplicates//Sort;
$dummy=$var//tuIndexParser//First;
Do[$L=Expand[($L+(UpDownIndexSwap[$dummy[[i]]][$L]))/2];xPrint[$L],{i,Length[$dummy]}];
{$L,$var,$dummy}
]
(*testEulerLagrangeTensor*)
(*
LowerTensorIndexByG[tensor_List,G_][exp_] lower indices of Tensor variables in exp_ (by assuming the metric, G_, lowers indices) specified in tensor_List of only the indices specified as patterns. The result is the tensor_List variables Dotted with the metric, G_, and the specified indices lowered.  The summed indices are specified by dum[] indices.  The purpose of this routine is allow for the differential of expressions that have variables that differ by a metric index change.  eg., the TEST below generates
{Subsuperscript[A, a\[Mu]_, a\[Mu]_],Subsuperscript[B, fg_h_, fg_h_]}
Subscript[Underscript["\[PartialD]", _], e][(Underscript["\[PartialD]", _]^e)[Subsuperscript[A, ab, ab] Subsuperscript[A, cd, cd] Subsuperscript[B, fgh, fgh]]]
Subscript[Underscript["\[PartialD]", _], e][(Underscript["\[PartialD]", _]^e)[Subsuperscript[g, adum[\[Mu]], adum[\[Mu]]].Subsuperscript[A, adum[\[Mu]], adum[\[Mu]]] Subsuperscript[g, fdum[g]dum[h], fdum[g]dum[h]].Subsuperscript[B, fdum[g]dum[h], fdum[g]dum[h]] Subsuperscript[A, cd, cd]]]
*)
LowerTensorIndexByG[tensor_List,G_][exp_]:=Module[{tmp,
sub,sub1,sub0,f1,dd},
xPrint["tensor:",tensor];
(*change Tensor\[Rule] \[Delta].Tensor*)
tmp=Map[#/.Tensor[a_,b_,c_]:>Tensor[G,b,c].Tensor[a,b,c]&,tensor];
xPrint["tmp:",tmp];
tmp=tmp/.Pattern->xPattern/.xPattern[a_,Blank[]]->dum[a];
tmp=tmp/.Tensor[G,a_,b_]:>SwapUpDownIndices[Flatten[{Cases[a,dum[_]],Cases[b,dum[_]]}]][Tensor[G,a,b]];

xPrint["tmp:",tmp];
tmp=tmp/.Tensor[G,a_,b_]. Tensor[A_,c_,d_]:> SwapUpDownIndices[Flatten[{Cases[b,dum[_]]}]][Tensor[G,a,b].Tensor[A,c,d]];
xPrint["tmp:",tmp];
tmp=Thread[Rule[tensor,tmp]];
xPrint["tmp:",tmp];
exp/.tmp(*apply on each Times term*)
];
(* TEST
tmpf={A@ud[a,\[Mu]_],T[B,"uuu"][f, g_,h_]}
tmp=xPartialD[xPartialDu[ A@ud[a,b] Auu[c,d]T[B,"uuu"][f, g,h],e],e]
tmp//LowerTensorIndexByG[tmpf,g]
*)
(*
Counts the number of indices in exp_. Result is in ParseTermIndices format. *19July2012*)
ExpressionIndices[exp_]:=Module[{tmp=exp,indices={},tensors,xtmp},
tmp=tmp//.IndexParsingRules;
tensors=ExtractPattern[Tensor[a_,u_List,d_List]][tmp];
tmp=Map[ParseTermIndices[#]&,tensors];
tmp=Apply[Plus,tmp]/.Plus->List;
tmp=MapAt[Flatten[#]&,tmp,{{2,1},{2,2}}];
tmp
];
(*
returns list of paired dummy (up,down) indices in exp_. *19July2012*)
PairedDummies[exp_]:=Module[{tmp=exp,up,dn,xtmp},
tmp=ExpressionIndices[tmp];
tmp=Map[DeleteCases[#,Times[n_Integer,_]]&,tmp[[2]]];(*remove non singles*)
tmp=Intersection[tmp[[1]],tmp[[2]]];
tmp
];
(*
returns list of paired dummy (up,down) indices between term1_,term2_ . *19July2012*)
PairedDummies[term1_,term2_]:=Module[{tmp1=term1,tmp2=term2,up,dn,xtmp},
tmp1=ExpressionIndices[tmp1];
tmp1=Map[DeleteCases[#,Times[n_Integer,_]]&,tmp1[[2]]];(*remove non singles*)
tmp2=ExpressionIndices[tmp2];
tmp2=Map[DeleteCases[#,Times[n_Integer,_]]&,tmp2[[2]]];(*remove non singles*)
xtmp=Union[Intersection[tmp1[[1]],tmp2[[2]]],Intersection[tmp1[[2]],tmp2[[1]]]];
xtmp
];
(**)
tuIndexUniqueDummy::usage="tuIndexUniqueDummy[dummy_List][exp_] attempts to assign Unique labels to dummy indices (summed) designated by dummy_List to Tensor expressions.  *16Jan2016*";
tuIndexUniqueDummy[dummy_List][exp_]:=Block[{tmp=ExpandAll[exp],dum,head,isub,ops=Flatten[Times|Wedge|dotOps],oplist,distriOps={Rule,Equal,Plus},sub,xtmp  },
head=Head[tmp];
oplist=Apply[List,ops];
If[MemberQ[oplist,head]
&&Length[dum=Intersection[dummy,PairedDummies[tmp]]]>0,tmp=tmp//.(sub=Map[#->Unique[#]&,dum])];
If[MemberQ[Join[distriOps,oplist],head],
tmp=Apply[head,Map[tuIndexUniqueDummy[dummy][#]&,Apply[List,tmp]]]
];
tmp
];
UniqueDummyIndices[dummy_List][exp_]:=tuIndexUniqueDummy[dummy][exp];(*Compatibility*)

(*
removeUnique[symbol_List] returns Rules for removing tuIndexUniqueDummy extensions. *23Sep2014*)
removeUnique[dummy_List]:=Block[{sym},sym=ToString[#]<>"$*"->#&/@dummy//Flatten;
sym=MapAt[Names[#]&,#,1]&/@sym;
sym=Thread/@sym//Flatten;
Map[MapAt[Symbol[#]&,#,1]&,sym]
]
(**)
tuIndexParser::usage="tuIndexParser[term_] extends ParseTermIndices in Tensorial handle complex Tensor notation. Returns {dummy,{up,down},error} indices *11Sep2012";
tuIndexParser[term_]:=Module[{tmp,pos,up={},dn={},updup,dndup,dummy={},bad={}},
If[Head[term]=!=Plus,
tmp=term//.IndexParsingRules;
pos=ExtractPattern[Tensor[$A_,$u_,$d_]][tmp];
up=Map[#[[2]]&,pos]//Flatten//DeleteCases[#,Void]&;
dn=Map[#[[3]]&,pos]//Flatten//DeleteCases[#,Void]&;
updup=Tally[up];  dndup=Tally[dn];
bad=Map[#[[1]]&,
Join[Cases[updup,{_,n_/;n>1}],Cases[dndup,{_,n_/;n>1}]]];
dummy=Intersection[up,dn];
up=DeleteCases[up,Apply[Alternatives,Join[dummy,bad]]];
dn=DeleteCases[dn,Apply[Alternatives,Join[dummy,bad]]];
];
{dummy,{up,dn},bad}
];
ParseTermIndicesTU[term_]:=tuIndexParser[term];

tuIndexDummyOrdered::usage="tuIndexDummyOrdered[exp_] orders Dummy indices Plus[] terms in exp_ by tuIndexSwapUpDown[]. BEWARE ther are terms that produces unintended results. *2Jan2016*";
tuIndexDummyOrdered[exp_]:=Block[{tmp=exp,tmp1,dum,order,ops=Times|Dot|xDot|CenterDot,xOP},
order[term_]:=Block[{$t=term,$t1},
dum=$t//tuIndexParser//First;
Do[$t=If[OrderedQ[{$t1=tuIndexSwapUpDown [$$i][$t],$t}],$t1,$t],{$$i,dum}];
$t
];
tmp=tmp//Expand;
tmp=tmp/.Plus->xPlus/.pp:xPlus[a__]:>Map[order[#]&,pp]/.xPlus->Plus;
xPrint["tmp: ",tmp," : "dum];
Return[tmp];
];
OrderTensorDummyIndices[exp_]:=tuIndexDummyOrdered[exp];(*Compatibility*)

(*
changeDummyIndices[to_List,from_List][exp_] changes dummy indices to ones specified by the to_List from the lists of lists specified by the from_List.  e.g. changeDummyIndices[{i1,k[il,iv]},{{j1,k[iv,j1]},{i1,k[i1,iv]}}][exp_] changes to {i1,k[il,iv]} terms with either {{j1,k[iv,j1]},{i1,k[i1,iv]}} indices. It chooses the from_indices based upon the greatest number of match indices.
*22Oct2014*)
changeDummyIndices[from_List,to_List][exp_]:=Block[{tmp,indices,rules,in,replace,dummy},
tmp=ExpandAll[exp];
replace[term_]:=Block[{lin,out},(*xPrint["term:",term];*)
indices=tuIndexParser[term];
dummy=indices[[1]];
in={Length[in=Select[dummy,MemberQ[from,#]&]],in};(*
xPrint["indices:",dummy,":",from,":",in];*)
If[in[[1]]>0, rules=Thread[from->to];
(*TODO change to index specific*)(*
xPrint["rules",rules];*)
Return[term/.rules];];
term
];
tmp=If[Head[tmp]===Plus,
tmp=replace/@Apply[List,tmp];Apply[Plus,tmp],
replace[tmp]];(*xPrint[tmp];*)
tmp
];

(**)
tuIndexSumTerm::usage="tuIndexSumTerm[index_List,baseindices_List :{0,1,2,3}][exp_] Sum[]s dummy indices of exp_ that are Members of index_List. Indices are Sum[]d over baselindices. Recursively uses tuIndexSum. *22Sep2015* ";
tuIndexSumTerm[index_List,baseindices_List :{0,1,2,3}][exp_]:=Block[{tmp=exp,dummy,indices},
If[tuProductQ[tmp],
indices=tuIndexParser[tmp];
If[Length[dummy=Intersection[indices[[1]],index]]>0,(*dummies only*)
tmp=xSum[tmp,{dummy[[1]],baseindices}];
tmp=tmp/.xSum->Sum//Expand;
tmp=tuIndexSum[index,baseindices][tmp];
];
];
tmp
];
(**)
tuIndexSum::usage="tuIndexSum[index_List,baseindices_List :{0,1,2,3}][exp_] Expand[]s exp_ and Sum[]s dummy indices in index_List. Indices are Sum[]d over baselindices.  *22Sep2015*";
tuIndexSum[index_List,baseindices_List :{0,1,2,3}][exp_]:=Block[{$=exp},
$=$//Expand;
$=$//.Times->xTimes;
$=$//.xTimes[a__]:>Inactive[tuIndexSumTerm] [index,baseindices] [Inactive[Times][a]];
$=$//Activate;
$
];
(**)
tuSumIndexUnique::usage:="tuSumIndexUnique[exp_] replaces Sum|xSum|Inactive[Sum] indices in exp_ with Unique[] indices. *15Jan2016*";
tuSumIndexUnique[exp_]:=Block[{$=exp,indices={},sums},
sums=$//tuExtractPositionPattern[{(Sum|xSum|Inactive[Sum])[__]}];
indices=Map[#->Unique[i][#]&/@Apply[List,#[[2,2;;-1]]]&,sums];
sums=MapIndexed[First[#1/.indices[[#2]]]&,sums];
$=tuReplacePart[$,sums]
];
(**)
tuTensorSimplify::usage="tuTensorSimplify[exp_Plus] simplifies Plus[] Tensor expression, exp_, by reindexing Dummy indices.  Works with Tensor and tuDerivOps expressions. *11Sep2015*";
tuTensorSimplify[exp_Plus]:=Block[{$,$s,$s1,$1,$1c,$2,$2c,$2t,$2td,$2m,$match={},$matches={}},
$=List@@exp;
$s=tuIndexParser/@$;$s//Column;
$2t=Select[List@@#,tuTensorQ[#]&]&/@$;
$2t=Times@@#&/@$2t;(*Tensor portion*)
$2td=MapIndexed[tuIndicesLower[#1[[1]]] [$2t[[#2]]]&,$s]//Flatten;  (*Tensor portion Lowered indices*)
$2c=Select[List@@#,!tuTensorQ[#]&]&/@$;
$2c=Times@@#&/@$2c;(*non Tensor portion*)
Do[
$1=$[[$i]];
$1=List@@$1;
$1c=Select[$1,!tuTensorQ[#]&];
$1c=$2c[[$i]];
$1t=Select[$1,tuTensorQ[#]&];
$1t=Times@@$1t;
$s1=$1t//tuIndicesLower[$s[[$i,1]]];
$s1=$2td[[$i]];
$s1=tuAddPatternVariable[$s1->0,$s[[$i,1]]];xPrint["LL",$s1];
$2m=MatchQ[#,$s1[[1]]]&/@$2td;
If[Length[Cases[$2m,True]]>1,
$match=Flatten[Position[$2m,True]];
AppendTo[$matches,$match];
xPrint[Column[$2t[[$match]]]];
];
,{$i,Range[Length[$]]}
];
$matches=$matches//DeleteDuplicates;
Do[
$match=$matches[[ $i ]];  xPrint[$i,"::",$match];
($2t[[ # ]]=$2t[[ $match[[1]] ]])&/@$match,
{$i,Range[Length[$matches]]}
];
Inner[Times,$2c, $2t,Plus]
];


(*
Returns Abelian vector boson energy-momentum tensor as:
{-Fdd[\[Mu],\[Nu]].Fuu[\[Mu],\[Nu]]/4,derivative of A definition, Fourier transform of A } *21Dec2014*)
Fabelian:=Block[{tmp,subF,subFA,subA,F2,FA2,au,ad,i,k,a,b,c,\[Mu],\[Nu],DEBUG=0},
"Abelian case";
subF={
T[F,"dd"][\[Mu],\[Nu]]->xPartialD[T[A,"d"][\[Nu]],\[Mu]]-xPartialD[T[A,"d"][\[Mu]],\[Nu]],
T[F,"uu"][\[Mu],\[Nu]]->T[g,"uu"][\[Mu],\[Alpha]]xPartialD[T[A,"u"][\[Nu]],\[Alpha]]-xPartialD[T[A,"u"][\[Mu]],\[Alpha]]T[g,"uu"][\[Alpha],\[Nu]]
};
" and Fourier transform ";
subA={T[A,"d"][i_]->IntegralOp[{{k}},ad[i][k] Exp[I k.x]],T[A,"u"][i_]->IntegralOp[{{k}},au[i][k]Exp[-I k.x]]};

subFA=subF/.subA;
If[DEBUG>0,Print["Fabelian:subFA: ",subFA]];
subFA=subFA//ExchangexPartialDIntegralOp;
subFA=subFA/.xPartialD[a_ Exp[b_],c_]->I T[k,"d"][c] a Exp[b]/.GatherIntOpSubs;
subFA=subFA//MetricContractG;
If[DEBUG>0,Print["Fabelian:subFA: ",subFA]];
F2=-(1/4)T[F,"dd"][\[Mu],\[Nu]].T[F,"uu"][\[Mu],\[Nu]]; (* Abelian case *)
FA2=F2/.subF;
If[DEBUG>0,Print["Fabelian:FA2: ",FA2]];
tmp=F2/.subFA//ExpandAll;
If[DEBUG>0,Print["Fabelian:tmp: ",tmp]];
tmp=tmp/.Dot[a_,b_]:>Dot[a/.k->k[1]/.T[k,"d"][c_]->T[k,"d"][c][1],b/.k->k[2]/.T[k,"d"][c_]->T[k,"d"][c][2]];
tmp=tmp/.IntDotInt2Int2/.Dot->Times//.GatherIntOpSubs//Simplify;
If[DEBUG>0,Print["Fabelian:tmp: ",tmp]];
"This integrated over x producing a delta function in k1-k2: (Done by hand.)";
tmp=tmp/.k[2]->k[1]/.IntegralOp[{a_,b_},c_]->IntegralOp[{a},(c)];
tmp=tmp/.k[1]->k;
tmp=tmp/.IntegralOp[a_,b_]:>IntegralOp[a,b//Expand];
tmp=tmp/.IntegralOp[a_,b_]:>IntegralOp[a,MapAt[SwitchLabel[#,{\[Mu],\[Nu]}]&,b,{{1},{2}}]];
tmp=tmp/.{ad[c_]->T[A,"d"][c],au[c_]->T[A,"u"][c]};
{F2,FA2,tmp}//.simpleDot
];

(* 
Returns Abelian vector boson energy-momentum tensor as:
{-Fdd[\[Mu],\[Nu]].Fuu[\[Mu],\[Nu]]/4,derivative of A definition, Fourier transform of A } *21Dec2014 *)
Fabelian1:=Block[{tmp,subF,subFA,subA,F2,FA2,au,ad,i,k,a,b,c,\[Mu],\[Nu],DEBUG=0},
"Abelian case";
subF={
T[F,"dd"][\[Mu],\[Nu]]->xPartialD[T[A,"d"][\[Nu]],\[Mu]]-xPartialD[T[A,"d"][\[Mu]],\[Nu]],
T[F,"uu"][\[Mu],\[Nu]]->xPartialDu[T[A,"u"][\[Nu]],\[Mu]]-xPartialDu[T[A,"u"][\[Mu]],\[Nu]]
};
" and Fourier transform ";
subA={T[A,"d"][i_]->IntegralOp[{{k}},ad[i][k] Exp[I k.x]],T[A,"u"][i_]->IntegralOp[{{k}},au[i][k]Exp[-I k.x]]};

subFA=subF/.subA;
If[DEBUG>2,Print["Fabelian:subFA 0: ",subFA]];
subFA=subFA//ExchangexPartialDIntegralOp;
subFA=subFA/.{xPartialD[a_ Exp[b_],c_]->I T[k,"d"][c] a Exp[b],xPartialDu[a_ Exp[b_],c_]->I T[k,"u"][c] a Exp[b]}/.GatherIntOpSubs;
If[DEBUG>0,Print["Fabelian:subFA 1: ",subFA]];
(*subFA=subFA//MetricContractG;
If[DEBUG>0,Print["Fabelian:subFA: ",subFA]];
*)
F2=-(1/4)T[F,"dd"][\[Mu],\[Nu]].T[F,"uu"][\[Mu],\[Nu]]; (* Abelian case *)
FA2=F2/.subF;
If[DEBUG>0,Print["Fabelian:FA2: ",FA2]];
tmp=F2/.subFA//ExpandAll;
If[DEBUG>0,Print["Fabelian:tmp 0: ",tmp]];

tmp=tmp//ExchangexPartialDIntegralOp;
If[DEBUG>0,Print["Fabelian:tmp: ",tmp]];
tmp=tmp/.Dot[a_,b_]:>Dot[a/.k->k[1]/.{T[k,"d"][c_]->T[k,"d"][c][1],T[k,"u"][c_]->T[k,"u"][c][1]},b/.k->k[2]/.{T[k,"d"][c_]->T[k,"d"][c][2],T[k,"u"][c_]->T[k,"u"][c][2]}];
If[DEBUG>0,Print["Fabelian:tmp 1: ",tmp]];
tmp=tmp/.IntDotInt2Int2/.Dot->Times//.GatherIntOpSubs//Simplify;
If[DEBUG>0,Print["Fabelian:tmp: ",tmp]];
"This integrated over x producing a delta function in k1-k2: (Done by hand.)";
tmp=tmp/.k[2]->k[1]/.IntegralOp[{a_,b_},c_]->IntegralOp[{a},(c)];
tmp=tmp/.k[1]->k;
tmp=tmp/.IntegralOp[a_,b_]:>IntegralOp[a,b//Expand];
tmp=tmp/.IntegralOp[a_,b_]:>IntegralOp[a,MapAt[SwitchLabel[#,{\[Mu],\[Nu]}]&,b,{{1},{2}}]];
tmp=tmp/.{ad[c_]->T[A,"d"][c],au[c_]->T[A,"u"][c]};
{F2,FA2,tmp}//.simpleDot
]
Fabelian1(*TEST*)

DeclareIndexFlavor[{gaugeG,Blue}](*Placeholder*)
AddBaseIndex[{gaugeG,Range[8]}]
Clear[nonAbelianF,FFna]
(* 
Computes non-abelian gauge boson energy momentum tensor expressions. 
{F.F lagrangian term, 
F.F in terms of A's.
Resets BaseIndices with Length[ Flavor[gaugeG] ]->groupN
*)
nonAbelianF[gaugeN_]:=Module[{tmp,subF,subFA,subA,sF2,FA2,NgaugeR,list,DEBUG=0,mName="nonAbelianF"},
DefineTensor[A,F,f ];
tmp=CompleteBaseIndices/.{gaugeG,_}->{gaugeG,Range[gaugeN]};
DeclareBaseIndices[Apply[Sequence,tmp]];
(*** Define gauge field A *)
IfDEBUG[mName,DEBUG>0,A@ud[gaugeG@2,\[Mu]],"A@ud"];
(*** Define field strength F  *)
subFA={
F@udd[gaugeG@c_,\[Mu]_,\[Nu]_]->xPartialD[A@ud[gaugeG@c,\[Nu]],\[Mu]]-xPartialD[A@ud[gaugeG@c,\[Mu]],\[Nu]]+g f@uuu[gaugeG@a,gaugeG@b,gaugeG@c]A@ud[gaugeG@a,\[Mu]]A@ud[gaugeG@b,\[Nu]],
F@uuu[gaugeG@c_,\[Mu]_,\[Nu]_]->xPartialDu[A@uu[gaugeG@c,\[Nu]],\[Mu]]-xPartialDu[A@uu[gaugeG@c,\[Mu]],\[Nu]]+g f@uuu[gaugeG@a,gaugeG@b,gaugeG@c]A@uu[gaugeG@a,\[Mu]]A@uu[gaugeG@b,\[Nu]]
};
IfDEBUG[mName,DEBUG>0,{subFA},"subFA"];
(*** Define kinetic term  *)
sF2=FFna[gaugeG@a_,\[Mu]_,\[Nu]_]->-(1/4)F@udd[gaugeG@a,\[Mu],\[Nu]].F@uuu[gaugeG@a,\[Mu],\[Nu]]; 
IfDEBUG[mName,DEBUG>0,{sF2},"sF2"];

tmp=FFna[gaugeG@c,\[Mu],\[Nu]]/.sF2/.subFA[[1]];

tmp=tmp/.subFA[[2]];
DotExpandMode[True];
tmp=tmp/.simpleDot//Expand;
dclTensorSymmetry[f,3]=AntiSymmetric[1,2,3];
list=Apply[List,tmp];
list[[2]]=Swaps[{{\[Mu],\[Nu]},{a,b}}][list[[2]]]//SymmetrizeSlots[];
list[[4]]=Swaps[{{\[Mu],\[Nu]},{a,b}}][list[[4]]]//SymmetrizeSlots[];
list[[8]]=Swaps[{{\[Mu],\[Nu]},{a,b}}][list[[8]]]//SymmetrizeSlots[];
list[[9]]=Swaps[{{\[Mu],\[Nu]},{a,b}}][list[[9]]]//SymmetrizeSlots[];
list=list/.simpleDot;
list=Apply[Plus,list];
list=Apply[List,list]/.commuteDot;
list[[2]]=list[[2]]//SwapUpDownIndices[{\[Mu],\[Nu]}];
list[[1]]=list[[1]]/.Dot[A_,B_]:>Dot[A/.gaugeG@a_->gaugeG@a[1],B/.gaugeG@a_->gaugeG@a[2]]/.gaugeG@c[_]->gaugeG@c;
IfDEBUG[mName,DEBUG>0,{list},"list"];
list=Apply[Plus,list]/.Dot->Times;
DotExpandMode[False];
{sF2,subFA,list}
];

Column[
sNAFF=nonAbelianF[3]];



(* Simplifies xPartialD in exp_ based upon list of constants_ .  Only extracts multiplicative constants.
NOT FINISHED -> use /.xPartialDExpand[]
*)
PartialDSimplify[exp_,constants_]:=Module[{tmp=exp,tmp0=Null,pos,xpart,arg,dx,i},
While[tmp=!=tmp0,
tmp0=tmp;
tmp=tmp//.xPartialDExpand[constants];
tmp=tmp/.(OP:xPartialD|xPartialDu)[a_,b_]:>0/;MemberQ[constants,a](*;
tmp=tmp/.xPartialD[a_,b_]:>0/;MemberQ[constants,a];  (*XXX*)
tmp=tmp/.xPartialDu[a_,b_]:>0/;MemberQ[constants,a]  (*XXX*)
*)
];
tmp
];

(*Rules for applying D[,] instead of xPartialD[,].  Usage: exp/.xPartialD2D[1,x]
*)
xPartialD2D[mu_,x_][exp_]:=Module[{$=Hold[exp]},
$=$//.xPartialD|xPartialDu->D;
$//ReleaseHold
];

(**)
tuDerivOps2D::usage="tuDerivOps2D[exp_] simply converts DerivOps into D expressions. *9Sep2015*";
tuDerivOps2D[exp_]:=Block[{$=Hold[exp]},
$=$//.DerivOps->D;
$//ReleaseHold
];
(* 
Rules that transform {xPartialD,xPartialDu} to Tensorial \[PartialD]:
{xPartialD[a_,b_]->T["\[PartialD]","d"][b][a],xPartialDu[a_,b_]->T["\[PartialD]","u"][b][a]}
 7Apr2012 *)
(*
xPartialD2Dupdn[var_List,field_List][exp_] converts Tensor exp_ indices into functional[var_[up|dn]] where {up,dn} indicates the position of the indices.  The field_List (Patterns OK) contains the Tensor fields that are functions of var_List[up|dn].  The fields can have Patterns as indices to encompass a more general set of fields.  This is useful when we want to use the D operation in exp_ where the notation is in xPartialD & xPartialDu, Tensor.  Used to compute EulerEquation in Tensor notation, 
e.g.,
tmp=xPartialD[xPartialDu[ A@ud[a,b] A@uu[c,d], e],e]
xPartialD2Dupdn[{e,\[Nu]},{A@ud[a,\[Mu]_],A@uu[\[Nu]_,a_]}][ tmp ]
=>
((Subsuperscript[A, ce, ce])^(0,1,0,0))[e[up],e[dn],c[up],c[dn]] ((Subsuperscript[A, ab, ab])^(1,0,0,0))[e[up],e[dn],\[Nu][up],\[Nu][dn]]+((Subsuperscript[A, ab, ab])^(0,1,0,0))[e[up],e[dn],\[Nu][up],\[Nu][dn]] ((Subsuperscript[A, ce, ce])^(1,0,0,0))[e[up],e[dn],c[up],c[dn]]+Subsuperscript[A, ce, ce][e[up],e[dn],c[up],c[dn]] ((Subsuperscript[A, ab, ab])^(1,1,0,0))[e[up],e[dn],\[Nu][up],\[Nu][dn]]+Subsuperscript[A, ab, ab][e[up],e[dn],\[Nu][up],\[Nu][dn]] ((Subsuperscript[A, ce, ce])^(1,1,0,0))[e[up],e[dn],c[up],c[dn]]


*2Jan2014*)
xPartialD2Dupdn[var_List,field_List][exp_]:=Module[{sub,tmp=exp,vars={}},
vars=Flatten[Map[Append[vars,{#[up],#[dn]}]&,var]];
sub=Map[{#->Apply[RemovePatterns[#],vars]}&,DeleteDuplicates[field]]//Flatten;
xPrint["sub:",sub];
tmp=tmp/.sub;
xPrint["tmp:",tmp];
sub={xPartialD[a_,b_]:>xD[a,b[dn]]/;!FreeQ[a,up|dn],xPartialDu[a_,b_]:>xD[a,b[up]]/;!FreeQ[a,up|dn]};
xPrint["sub:",sub];
tmp=tmp//.sub;
xPrint["tmp:",tmp];
tmp=tmp//.xD->D;
tmp
];

(*
CombineDeriv Rules for combining sum and differences of Deriv s*31August2012*)
CombineDeriv:={(op:DerivOps)[a_,b_]+(op:DerivOps)[c_,b_]->op[a+c,b],(op:DerivOps)[a_,b_]-(op:DerivOps)[c_,b_]->op[a-c,b],
(op:DerivOps)[a_,b_]c_+(op:DerivOps)[c_,b_]a_->op[a c,b](*inverse chain rule*)
}
(*
lagrangexPartialD Rules[]s simplify expressions that often occur in derivation using Lagrangians.  *22Apr2014*)
lagrangexPartialD={xPartialD[(xPartialDu|xPartialD)[a_,b_],(xPartialDu|xPartialD)[c_,d_]]:>0/;a=!=c,
xPartialD[xPartialDu[a_,b_],xPartialDu[a_,d_]]:>T[\[Delta],"ud"][b,d],
xPartialD[xPartialDu[a_,b_],xPartialD[a_,d_]]:>T[\[Delta],"uu"][b,d],
xPartialD[xPartialD[a_,b_],xPartialDu[a_,d_]]:>T[\[Delta],"dd"][b,d],
xPartialD[a_,(xPartialDu|xPartialD)[b_,d_]]:>0/;FreeQ[a,(xPartialDu|xPartialD)]
};


(*Function to generate IntegralOp variables for F[n_] in e1410.*)
xF[n_]:=Module[{out,i},For[out={{x[1],0,1}};i=2,i<=n,i++,AppendTo[out,{x[i],0,1}]];
out
];
Fn[n_]:=Module[{out,i,j},For[out={{x[1],0,1}};i=2,i<=n,i++,AppendTo[out,{x[i],0,1-Sum[x[j-1],{j,2,i}]}]];
out
];
DefPrint["e1410",IntegralOp[{{F[n_]}},a__]:>IntegralOp[xF[n],a (n-1)! DiracDelta[Sum[x[i],{i,1,n}]-1]]]
DefPrint["e1427",IntegralOp[{{q}},1/(2 \[Pi])^d (q^2)^a/(q^2+D)^b]->(Gamma[b-a-d/2]Gamma[a+d/2])/((4 \[Pi])^(d/2) Gamma[b]Gamma[d/2]) D^-(b-a-d/2)]
DefPrint["e1427s",IntegralOp[{{q}},(q^2)^a/(q^2+D)^b]->((2 \[Pi])^d Gamma[b-a-d/2]Gamma[a+d/2])/((4 \[Pi])^(d/2) Gamma[b]Gamma[d/2]) D^-(b-a-d/2)]
DefPrint["e1427hitoshi",IntegralOp[{{q}},(q^2)^a/(q^2-D-I \[CurlyEpsilon])^b]->(I (-1)^(b+a) (2 \[Pi])^d Gamma[b-a-d/2]Gamma[a+d/2])/((4 \[Pi])^(d/2) Gamma[b]Gamma[d/2]) D^-(b-a-d/2)]
DefPrint["e1426",Gamma[-n+\[CurlyEpsilon]]:>(-1)^n/(n)! (1/\[CurlyEpsilon]-\[Gamma]+Sum[k^-1,{k,1,n}])]

CompleteSquare1[denomlist_,var_]:=
(*Finds square of quadradic polynomial, a x x + b x + c -> f( x + d )^2 + e, with var_ as the x_variable.  Returns {Complete quadratic, Shifted quadratic term, Offset, variable shift factor}.  *BUG*)
Module[{factor,coef,denom,n,tmp,tmp1,tmp2,tmp3,sub1,a,b,c,f,d,e,x,sub,sube,subfD2,subfD2e,subshift},
"Generate substitution Rule[] for quadratic polynomial of form.";
Clear[fD2,fD2e,fD2off,varshift];
tmp=a x x + b x + c;(* General quadratic equation*)
tmp1=f*(x+d)^2+e; (* Solution form *)
tmp=tmp-tmp1//Expand//CoefficientList[#,x]&; (* Difference in form. *)
tmp1=Solve[tmp[[3]]==0,f]//First;
tmp=tmp/.tmp1;
tmp2=Solve[tmp[[2]]==0,d]//First;
tmp=tmp/.tmp2;
tmp3=Solve[tmp[[1]]==0,e]//First;
sub1={tmp1,tmp2,tmp3}//Flatten;(* Solutions for {f,d,e} *)
subfD2=fD2->f*(x+d)^2/.sub1; (* f(x + d)^2 part *)
sube=fD2offset->(e/.sub1); (* e part *)
subfD2e=fD2all->f*(x+d)^2+e/.sub1; (* f(x+d)^2+e *)
subshift=varshift->var->var-d/.sub1;(* var-d so that x-d->x  *)
{factor,denom,n}=denomlist[[1;;3]];
coef=CoefficientList[denom,var];
sub=MapThread[#1->#2&,{{c,b,a},coef}];
{subfD2e,subfD2,sube,subshift}/.sub/.x->var
]

(*Factors exp_ in form (1/A1).(1/A2).(1/A3)... into Feynman form, (x[1] A1+...+x[n] An)^n.  Returns {coef, denom, exponent of denom,sum of x[n]}.*)
FactorDotFeynman[exp_]:=Module[{i,n,square,tmp,xs,numer,denom,DEBUG=0},
tmp=Apply[List,exp];
n=Length[tmp];
numer=Thread[Numerator,tmp];
xs=Thread[x[Range[n]]];
numer=Thread[Numerator[tmp]];
tmp=MapThread[#3 #1/#2&,{xs,tmp,numer}];
IfDEBUG["FactorDotFeynman",DEBUG,tmp,"tmp"];
denom=Apply[Plus,tmp]/.Dot->Times;
denom=denom//Expand//SimplifyTensorSum//UpDownAdjust//Simplify;
denom=denom/.x[n]->1-Apply[Plus,Most[xs]]//Expand;
tmp=Apply[Times,numer]/denom^n;
{Apply[Times,numer],denom,n,Apply[Plus,xs]}
]; 
(*
simpleVertex[scalars_List][exp_Vertex] removes all scalars_List from Vertex[]. Only terms retained in Vertex[] are dotOps.  Usage: tmp/.v:Vertex[a__]:> simpleVertex[{e,q}][v] *11Sep2012*)
simpleVertex[scalars_List][exp_Vertex]:=Module[{tmp=exp},
tmp=tmp/.Vertex[a__]:>Vertex[simpleDot1a[scalars][a]];
tmp=tmp/.Vertex[a___ (op:dotOps)[b__]]->a Vertex[op[b]]
];
(*
CollectDotNumerator[exp_Dot|xDot] takes exp_Dot|xDot where each dotted term may be a fraction and converts into a dotted Numerator and Times Denominator.  Assumes that the Denominators of the terms are scalar. *10Nov2012*)
CollectDotNumerator[exp_Dot|xDot]:=Module[{tmp=exp,head,tmpn,tmpd},
head=Head[exp];
tmp=Apply[List,tmp];
tmpn=Map[Numerator[#]&,tmp];
tmpd=Map[Denominator[#]&,tmp];
Apply[head,tmpn]/Apply[Times,tmpd]
];
(*
Peskin-Schroeder 6.42 *10Nov2012*)
PS642[n_]:=1/Product[Subscript[A, i]^Subscript[m, i],{i,n}]->IntegralOp[Table[{Subscript[x, i],0,1},{i,n}],\[Delta][Sum[Subscript[x, i],{i,n}]-1] Product[Subscript[x, i]^(Subscript[m, i]-1),{i,n}]/Sum[Subscript[x, i] Subscript[A, i],{i,n}]^Sum[Subscript[m, i],{i,n}] \[CapitalGamma][Sum[Subscript[m, i],{i,n}]]/Product[\[CapitalGamma][Subscript[m, i]],{i,n}]
];
(*
egRule: Conjugate of bi-spinor product PS.5.2: conjugateUgU=Conjugate[Overscript[u_, _][pu_]].Conjugate[tt:Tensor[\[Gamma],a_,b_]].Conjugate[v_[pv_]]->Overscript[v, _] [pv]. tt.u[pu]
*1Dec2014*)
(*
groupUUpp[p_] Rule that connect Dot[] expressions that end and begin with p_. 1Dec2014*)
groupUUpp[p_]:=(aa:Dot[b__,a_[p]])(bb:Dot[a1_[p],b1__])->aa.bb
(*
FeynmannParameterization[exp_Dot|xDot] takes exp_Dot|xDot which is the result of evaluating vertices and propagators of a Feynmann diagram and converts into an expression using Feynmann parameterization.  *10Nov2012*)
FeynmannParameterization[exp_Dot|xDot]:=Module[{tmp=exp,head,tmpn,tmpd,tmpdconstant,tmpdpow,$n,pow,subA,subm,out},
head=Head[exp];
tmp=Apply[List,tmp];
tmpn=Apply[head,Map[Numerator[#]&,tmp]];
tmpd=Map[Denominator[#]&,tmp];
tmpd=Apply[List,Apply[Times,tmpd]];
tmpdconstant=Join[{1},DeleteCases[tmpd,Except[_NumberQ]]];
tmpd=DeleteCases[tmpd,_NumberQ];
$n=Length[tmpd];
tmpdpow=tmpd/.b_^(pow:c_):>pow;
tmpdpow=Map[If[NumberQ[#],#,1]&,tmpdpow];
subA=MapIndexed[Subscript[A, #2[[1]]]->#1&,tmpd];
subm=MapIndexed[Subscript[m, #2[[1]]]->#1&,tmpdpow];
out=PS642[$n]/.subA/.subm;
Map[tmpn #/tmpdconstant[[1]]&,out]/.\[CapitalGamma]->Gamma
];

(**)
tuCompleteSquareUpDn::usage="tuCompleteSquareUpDn[var_][exp_] converts exp_ of form \[IndentingNewLine]$generalForm=$a xu xd + bu xd + $c \[Rule] $targetForm=$d ((xu+yu)(xd+yd)+$e) . \[IndentingNewLine]It assumes that the $generalForm is a proper Tensor expression and assumes that var_ in a Lower indexed Tensor variable.  Returns {$targetForm, $d, yd, $e} *19Dec2014*";
tuCompleteSquareUpDn[var_][exp_]:=Block[{$generalForm,$targetForm,xu,xd,yu,yd,bu,bd,eyd,tmp,sub1,tmpeL,abc,$a,$b,$c,$d,$e,$x,$y},
(*Build template for converting quadratic to CompleteSquare.*)
xu=T[$x,"u"][\[Mu]]; xd=T[$x,"d"][\[Mu]];
yu=T[$y,"u"][\[Mu]]; yd=T[$y,"d"][\[Mu]];
bu=T[$b,"u"][\[Mu]]; bd=T[$b,"d"][\[Mu]];
$generalForm=$a xu xd + bu xd + $c;(* General quadratic equation*)
$targetForm=$d (xu+yu)(xd+yd)+$e; (* Target form. Find {y's,$d,$e}? *)
tmp=$generalForm-$targetForm/.sLowerAllIndices//CoefficientList[#,xd]&; (*Coefficients must be 0.*)
tmp=Map[#==0&,tmp];
tmp=Solve[tmp,{$e,yd,$d}]//Flatten;
eyd=Append[tmp,tmp[[2]]/.sRaiseAllIndices[{}]]/.bd^2->bd bu;
(*Note $b is a Tensor and figure out what the UpDn indices are assuming that their values is the same.*)
xPrint[tmpeL=exp/.sLowerAllIndices];
xPrint[abc=CoefficientList[tmpeL,var]/.sRaiseAllIndices[{}]];
If[Length[abc]!=3,Print[CR["CompleteSquareUpDn expects 3 coefficients from exp_:",exp]]];
xPrint[abc=Thread[{$c,bu,$a}->abc]];
xPrint[abc=Append[abc,abc[[2]]/.sLowerAllIndices]];
eyd=eyd/.abc;
{$targetForm,$d,yd,$e}/.eyd/.xd->var/.{xu:>var/.sRaiseAllIndices[{}]}
];
CompleteSquareUpDn[exp_,var_]:=tuCompleteSquareUpDn[var][exp];


(*define dotted/undotted indices for spinor/twistor representations*)
DefineDottedIndices:=Module[{},
DeclareIndexFlavor[{twistor,Orange}];
DeclareBaseIndices[{twistor,{0,1}}];
d0[a_]:=twistor@a;
d1[a_]:=twistor@
\!\(\*OverscriptBox[\(a\), \(.\)]\);
(*OverBar Tensor definitions*)
OBu[a_,\[Mu]_]:=Tensor[OverBar[a],{\[Mu]},{Void}];
OBd[a_,\[Mu]_]:=Tensor[OverBar[a],{Void},{\[Mu]}];
OBuu[a_,\[Mu]_,\[Nu]_]:=Tensor[OverBar[a],{\[Mu],\[Nu]},{Void,Void}];
OBud[a_,\[Mu]_,\[Nu]_]:=Tensor[OverBar[a],{\[Mu],Void},{Void,\[Nu]}];
OBdd[a_,\[Mu]_,\[Nu]_]:=Tensor[OverBar[a],{Void,Void},{\[Mu],\[Nu]}];
OBuuu[a_,\[Mu]_,\[Nu]_,\[Alpha]_]:=Tensor[OverBar[a],{\[Mu],\[Nu],\[Alpha]},{Void,Void,Void}];
OBduu[a_,\[Mu]_,\[Nu]_,\[Alpha]_]:=Tensor[OverBar[a],{Void,\[Nu],\[Alpha]},{\[Mu],Void,Void}];
OBudd[a_,\[Mu]_,\[Nu]_,\[Alpha]_]:=Tensor[OverBar[a],{\[Mu],Void,Void},{Void,\[Nu],\[Alpha]}];
OBuud[a_,\[Mu]_,\[Nu]_,\[Alpha]_]:=Tensor[OverBar[a],{\[Mu],\[Nu],Void},{Void,Void,\[Alpha]}];
OBuuud[a_,\[Mu]_,\[Nu]_,\[Alpha]_,\[Beta]_]:=Tensor[OverBar[a],{\[Mu],\[Nu],\[Alpha],Void},{Void,Void,Void,\[Beta]}];
OBuudu[a_,\[Mu]_,\[Nu]_,\[Alpha]_,\[Beta]_]:=Tensor[OverBar[a],{\[Mu],\[Nu],Void,\[Beta]},{Void,Void,\[Alpha],Void}];
(*Default \[Sigma] index expansion*)
\[Sigma]@u[\[Mu]]->\[Sigma]@udd[\[Mu],d0@\[Alpha],d1@\[Beta]];
OBu[\[Sigma],\[Mu]]->OBuuu[\[Sigma],\[Mu],d1@\[Beta],d0@\[Alpha]];
subsigbar={OBu[\[Sigma],a_]:>If[a=!=0,-\[Sigma]@u[a],\[Sigma]@u[a]],OBd[\[Sigma],a_]:>If[a=!=0,-\[Sigma]@d[a],\[Sigma]@d[a]]};
(*Default dotted/undotted expansion function*)
AddDotIndex\[Sigma][a_,b_]:={OBu[\[Sigma],\[Mu]_]:>OBuuu[\[Sigma],\[Mu],d1@a,d0@b]/;\[Mu]=!=0,\[Sigma]@u[\[Mu]_]->\[Sigma]@udd[\[Mu],d0@b,d1@a]};
AddDotIndex\[Sigma]\[Sigma][a_,b_,c_]:={OBu[\[Sigma],\[Mu]_].\[Sigma]@u[\[Nu]_]:>OBuuu[\[Sigma],\[Mu],d1@a,d0@b].\[Sigma]@udd[\[Nu],d0@b,d1@c],
\[Sigma]@u[\[Mu]_].OBu[\[Sigma],\[Nu]_]:>\[Sigma]@udd[\[Mu],d0@a,d1@b].OBuuu[\[Sigma],\[Nu],d1@b,d0@c]};
(*additional OverBar and Dotted routines*)
OBCu[a_,\[Mu]_]:=Tensor[Conjugate[OverBar[a]],{\[Mu]},{Void}];
AddOB[a_Tensor]:=Module[{tmp=a},
tmp[[1]]=OverBar[tmp[[1]]];
tmp];
(* AddDotted adds proper dotted indices to \[Sigma]@u[] and \[Sigma]@uu[]. *)
AddDotted[a_Tensor]:=Module[{tmp=a,nindex=Length[a[[2]]]},
If[a[[1]]=!=\[Sigma]&&Head[a[[1]]]=!=OverBar,
tmp[[2]]=Join[tmp[[2]],{Void}];
tmp[[3]]=Join[tmp[[3]],{d0@$\[Alpha]}]
];
If[a[[1]]=!=
\!\(\*OverscriptBox[\(\[Sigma]\), \(_\)]\)&&Head[a[[1]]]===OverBar,
tmp[[2]]=Join[tmp[[2]],{d1@$\[Alpha]}];
tmp[[3]]=Join[tmp[[3]],{Void}]
];
If[nindex===1&&a[[1]]===\[Sigma],(*for \[Sigma]@u[\[Mu]]*)
tmp[[2]]=Join[tmp[[2]],{Void,Void}];
tmp[[3]]=Join[tmp[[3]],{d0@$\[Alpha],d1@$\[Beta]}]
];
If[nindex===1&&a[[1]]===
\!\(\*OverscriptBox[\(\[Sigma]\), \(_\)]\),
tmp[[3]]=Join[tmp[[3]],{Void,Void}];
tmp[[2]]=Join[tmp[[2]],{d1@$\[Beta],d0@$\[Alpha]}]
];
If[nindex===2&&a[[1]]===\[Sigma],(*for \[Sigma]@uu[\[Mu],\[Nu]]*)
tmp[[2]]=Join[tmp[[2]],{Void,d0@$\[Beta]}];
tmp[[3]]=Join[tmp[[3]],{d0@$\[Alpha],Void}]
];
If[nindex===2&&a[[1]]===
\!\(\*OverscriptBox[\(\[Sigma]\), \(_\)]\),
tmp[[2]]=Join[tmp[[2]],{d1@$\[Alpha],Void}];
tmp[[3]]=Join[tmp[[3]],{Void,d1@$\[Beta]}]
];
tmp
];
AddDottedRule=Tensor[a_,b_,c_]:>AddDotted[Tensor[a,b,c]];
(*AddDotted1 adds dotted indices Tensors (via AddDotted) and nonTensor variables. Correct indices in following step.*)
AddDotted1[a_]:=Module[{tmp=a},
If[Head[tmp]===Tensor,
tmp=AddDotted[tmp],
If[!NumericQ[tmp],
If[Head[tmp]=!=OverBar,
tmp=Tensor[tmp,{Void},{d0@$a}],
tmp=Tensor[tmp,{d1@$b},{Void}]
]
]
];
tmp
];

(*RemoveDotted remove Dotted indices from Tensor.  Assumes Dotted indices are at the end.*)
RemoveDotted[a_Tensor]:=Module[{tmp=a,l2a,length0,l2,l3,remove,list2,list3},
length0=Length[tmp[[2]]];
list2=Position[tmp[[2]],d0@_|d1@_];
list3=Position[tmp[[3]],d0@_|d1@_];
remove= Join[list2,list3];
tmp[[2]]=Delete[tmp[[2]],remove];
tmp[[3]]=Delete[tmp[[3]],remove];
tmp
];
RemoveDottedAll[exp_]:=Module[{tmp=exp},
tmp=tmp/.Tensor[a_,b_,c_]:>RemoveDotted[Tensor[a,b,c]]
];
RemoveDottedRule=Tensor[a_,b_,c_]:>RemoveDotted[Tensor[a,b,c]];
(*Some SUSY identities with Weyl spinors*)
subWeyl={Transpose[\[Alpha]].A.\[Beta]->-Transpose[\[Beta]].Transpose[A].\[Alpha]
};
];
(********)
T::usage="T[A_,up_List,down_List] produces any Tensor[A_,up_List,down_list]. Checks for proper indices. \[IndentingNewLine]A_ can be functional labels. Uses Null List item to hold slot in index list, e.g., T[A,{,i},{j,}\[Rule]\!\(\*SuperscriptBox[SubscriptBox[\(T\), \(j\)], \(i\)]\).";
T[A_,up_List,down_List]:=Module[{tmp,u=up/.Null->Void,d=down/.Null->Void,return},
If[up=={}&&down=={},Return[Tensor[A,up,down]]];(*Scalar Tensor with no indices*)
(*{} index case -> entirely other index *)
If[up=={},u=Table[Void,{Length[d]}]];
If[down=={},d=Table[Void,{Length[u]}]];
If[Length[d]==Length[u]&&
(!Inner[#1=!=Void&&#2=!=Void||#1===Void&&#2===Void&,u,d,Or]),(*index check*)
Tensor[A,u,d],
Style[Tensor[A,up,down],FontColor->Red](*Error condition*)
]
];

T::usage="T[A_,uds_String,index_List] produces any Tensor where uds_String specifies up/down position of index_, e.g., T[Symbol\"udd\",{i,j,k}]->((\!\(\*SuperscriptBox[\(Symbol\), \(i\)]\)\!\(\*SubscriptBox[\()\), \(jk\)]\))";
T[A_,uds_String,index_List]:=Module[{tmp,ud=Characters[uds]},
If[Cases[ud,Except["u"|"d"]]==={}&&(*only u and d allowed*)
(tmp=Which[Head[index]===List&&Length[ud]==Length[index],(*check list parameter compatibility*)
Tensor[A,MapThread[(If[#1==="u",#2,Void])&,{ud,index}],MapThread[(If[#1==="d",#2,Void])&,{ud,index}]],
ud==={"u"},
Tensor[A,{index},{Void}],
ud==={"d"},
Tensor[A,{Void},{index}],
(*no list index*)
True,(*error*)
-1])=!=-1,tmp,
Style[Tensor[A,uds,index],FontColor->Red]]
];

OnlyudQ[string_]:=StringCases[string,Except[{"d","u"}] ]=={};(* Alternate format for T:= T[symbol,"UpDownString"][indices] 7Apr2012 *)
T::usage="T[A_,uds_String][index0__] produces any Tensor where uds_String specifies up/down position of index_, e.g.,T[Symbol,\"udd\"][i,j,k]->((\!\(\*SuperscriptBox[\(Symbol\), \(i\)]\)\!\(\*SubscriptBox[\()\), \(jk\)]\))";
T[A_,uds_String][index0__]:=Module[{tmp,ud=Characters[uds],index={index0}},
If[Cases[ud,Except["u"|"d"]]==={}&&(*only u and d allowed*)
(tmp=Which[Head[index]===List&&Length[ud]==Length[index],(*check list parameter compatibility*)
Tensor[A,MapThread[(If[#1==="u",#2,Void])&,{ud,index}],MapThread[(If[#1==="d",#2,Void])&,{ud,index}]],
ud==={"u"},
Tensor[A,{index},{Void}],
ud==={"d"},
Tensor[A,{Void},{index}],
(*no list index*)
True,(*error*)
-1])=!=-1,tmp,
Style[Tensor[A,uds,index],FontColor->Red]]
];


MassUnits={length->1/m,Subscript[m, planck]->1/Sqrt[G],Lagrangian->m^dim,CrossSection[\[Sigma]]->m^2,ScatteringAmplitude[\[ScriptCapitalM]]->1}


IncludeUnits[]:=Module[{},
PR[CG["eV units conversion:"],
NL,"Rule[Kilogram -> ElectronVolt]",NL,
Kg2eV={Newton->(Kilogram Meter/Second^2),Kilogram->Convert[Kilogram,Joule/SpeedOfLight^2]SpeedOfLight^2,Joule->Convert[Joule, ElectronVolt]},NL,
"Example of the conversion of gravitational constant to Planck mass starting with ",
tmpMpl2=tmp=HoldForm[Subscript[m, pl]^2->PlanckConstantReduced SpeedOfLight /GravitationalConstant],yield,
tmpMpl=tmp=ReleaseHold[tmp],yield,
tmp=(tmpMpl//.Kg2eV),yield,tmp=Map[Sqrt[# ]&,tmp],yield,
tmp=MapAt[# SpeedOfLight&,tmp,{2}]//PowerExpand,NL,
CG["Convert2eVRule"],NL,
Convert2eVRule=Kg2eV;
sub=HoldForm[Solve[PlanckConstant==1,{Second}]/.Kg2eV],yield,AppendTo[Convert2eVRule,ReleaseHold[sub]],NL,
tmp=HoldForm[Solve[SpeedOfLight==1,{Meter}]],yield,
AppendTo[Convert2eVRule,ReleaseHold[tmp]],NL,
tmp={Barn->Convert[Barn,Meter^2],
TeV->Tera ElectronVolt,
GeV->Giga ElectronVolt,
MeV->Mega ElectronVolt,
KeV->Kilo ElectronVolt,
Sec->Second,
Giga->Convert[Giga,1],
Mega->Convert[Mega,1],
Tera->Convert[Tera,1],
Kilo->Convert[Kilo,1],
Kelvin->Kelvin BoltzmannConstant
},yield,
AppendTo[Convert2eVRule,tmp],
NL,
Imply,
Convert2eVRule=Convert2eVRule//Flatten
];
(*Function definitions*)
Convert2eV[exp_]:=Module[{},MKS[exp]//.Convert2eVRule];
(*Converts exp_ in ElectronVolt to Meters (simple case).  *)
Convert2Meter[exp_]:=Module[{tmp=Convert2eV[exp]},
tmp=tmp/.a_ ElectronVolt->(ElectronVolt/(PlanckConstant SpeedOfLight a) //MKS);
tmp=tmp/.(a_ /ElectronVolt)->((a PlanckConstant SpeedOfLight)/ElectronVolt//MKS)
];
(*Approximate conversion from Exp[a_] to Power[10,b] *)
E2Base10Approximate=E^b_:>(10^(b/Log[10]//N//Expand)/.a_Real:>Round[a]);
(*Approximates Times exp with Power[10,] *)
ApproximateExp10[exp__]:=Module[{tmp=exp},
tmp=tmp/.Times->xTimes;
tmp=tmp/.xTimes[a__]:>Exp[PowerExpand[Log[Times[a]]]]/.xTimes->Times//PowerExpand//ExpandAll;
tmp/.E2Base10Approximate
];
];

IncludeUnitsExamples[]:=Module[{},
IncludeUnits[];
PR["Sometimes difficult to use Units, e.g. Coulomb force between 2 charges in terms of Newtons: ",
tmp= qd[1]qd[2]/(4\[Pi] \[Epsilon]d[0]r^2),yield,
tmp=tmp/.qd[_]->ElectronCharge/.\[Epsilon]d[0]->VacuumPermittivity,NL,
"Using MKS does not change expression: ",yield,
tmp=tmp//MKS,NL,
"But must substitute for MKS units: ",
sub={Ampere ->Coulomb/Second,Coulomb->Newton Meter/Volt},Imply,
tmp=tmp//.sub,NL,
tmp=Hold[Convert2eV[Gram]],yield,
ReleaseHold[tmp],NL,
"Example of approximately converting Power[E,b_]->Power[10,b]: ",
tmp=(E^(17+58/(2+n)) ElectronVolt Tera)/1000000000000,yield,
tmp/.E^b_:>10^(b/Log[10]//N//Expand)/.a_Real:>Round[a],yield,
tmp/.E2Base10Approximate,NL,

"Example of the conversion of gravitational constant to Planck mass starting with ",
tmpMpl2=tmp=HoldForm[Md[pl]^2->PlanckConstantReduced SpeedOfLight /GravitationalConstant],yield,
subMpl=Map[Sqrt[#]&,ReleaseHold[tmp]//Convert2eV]//PowerExpand
];
];


(*
Gamma matrix identities*)
(*
\[Gamma]dot[indices_List] returns Dot'ed \[Gamma]'s with indices_List.  *18Jan2013*)
\[Gamma]dot[indices_List]:=Table[\[Gamma]@u[i],{i,indices}]//Apply[Dot,#]&
(*
Generate Tr[\[Gamma]^i] Rules for {i,{2,4,n}} *18Jan2013*)
generateTr\[Gamma][n_]:=Module[{sub,tmp,tmp0,indices,test,nlim,n0,collection={},char,char0,ii},
char=CharacterRange["a","z"]//ToExpression;
sub=\[Gamma]@u[a].\[Gamma]@u[b_]->-\[Gamma]@u[b].\[Gamma]@u[a]+2 g@uu[a,b];(*a is marker index*)
Do[char0=char[[1;;n0]];
indices=Table[ii,{ii,char0}];
tmp0=tmp=Tr[\[Gamma]dot[indices]];
nlim=1;
While[nlim<20&&test=!=tmp,
test=tmp;
tmp=tmp/.sub//.simpleTr2[{g@uu[_,_]}];
nlim++
];
tmp=tmp0->(tmp/.Dot[b_,\[Gamma]@u[a]]->Dot[\[Gamma]@u[a],b]);
tmp=(RuleX[tmp,tmp0]/.Tr[]->4)//First//RuleVarPattern[char0];
AppendTo[collection,tmp];
,{n0,2,n,2}];
tmp=Map[MapAt[#//.collection&,#,2]&,collection]//Simplify;
tmp0=tmp/.sLowerAllIndices;
Join[tmp,tmp0]
];
(*
PeskinSchroeder \[Gamma] Rules.*)
psa16={(ACommutator[T[\[Gamma],"u"][\[Mu]_],T[\[Gamma],"u"][\[Nu]_]]/.Dot->dotOps)->2 T[g,"uu"][\[Mu],\[Nu]],
(ACommutator[T[\[Gamma],"d"][\[Mu]_],T[\[Gamma],"d"][\[Nu]_]]/.Dot->dotOps)->2 T[g,"dd"][\[Mu],\[Nu]]
};
psa16a={\[Gamma]@u[\[Mu]_].\[Gamma]@u[\[Nu]_]->2 g@uu[\[Mu],\[Nu]]-\[Gamma]@u[\[Nu]].\[Gamma]@u[\[Mu]],
\[Gamma]@d[\[Mu]_].\[Gamma]@d[\[Nu]_]->2 g@dd[\[Mu],\[Nu]]-\[Gamma]@d[\[Nu]].\[Gamma]@d[\[Mu]]};
ps368=\[Gamma]@u[5]->I \[Gamma]@u[0].\[Gamma]@u[1].\[Gamma]@u[2].\[Gamma]@u[3];
ps369={
ConjugateTranspose[\[Gamma]@u[5]]->\[Gamma]@u[5] ,
\[Gamma]@u[0].\[Gamma]@u[5].\[Gamma]@u[0]->\[Gamma]@u[5]};
wiki1={ConjugateTranspose[\[Gamma]@u[\[Mu]_]]->\[Gamma]@u[0].\[Gamma]@u[\[Mu]].\[Gamma]@u[0],ConjugateTranspose[\[Gamma]@d[\[Mu]_]]->\[Gamma]@u[0].\[Gamma]@d[\[Mu]].\[Gamma]@u[0]};

ps370=\[Gamma]@u[5].\[Gamma]@u[5]->1;
ps371=ACommutator[\[Gamma]@u[\[Mu]],\[Gamma]@u[5]]->0;
ps55a=Tr[Id]->4;
ps55b={Tr[\[Gamma]@u[a_]]:>0/;MemberQ[{0,1,2,3},a],
Tr[\[Gamma]@u[a_].\[Gamma]@u[b_].\[Gamma]@u[c_]]:>0/;FreeQ[{a,b,c},5],
Tr[\[Gamma]@u[a_].\[Gamma]@u[b_].\[Gamma]@u[c_].\[Gamma]@u[d_].\[Gamma]@u[e_]]:>0/;FreeQ[{a,b,c,d,e},5]
};
ps55c={
Tr[\[Gamma]@u[\[Mu]_].\[Gamma]@u[\[Nu]_]]:>4 g@uu[\[Mu],\[Nu]]/;FreeQ[{\[Mu],\[Nu]},5],
Tr[\[Gamma]@d[\[Mu]_].\[Gamma]@d[\[Nu]_]]:>4 g@dd[\[Mu],\[Nu]]/;FreeQ[{\[Mu],\[Nu]},5],
Tr[\[Gamma]@u[\[Mu]_].\[Gamma]@u[\[Nu]_]]:>0/;(\[Mu]===5&&\[Nu]=!=5)||(\[Mu]=!=5&&\[Nu]===5)};
ps55d={Tr[\[Gamma]@u[a_].\[Gamma]@u[b_].\[Gamma]@u[c_].\[Gamma]@u[d_]]:>4(g@uu[a,b]g@uu[c,d]-g@uu[a,c]g@uu[b,d]+g@uu[a,d]g@uu[b,c])/;FreeQ[{a,b,c,d},5],
Tr[\[Gamma]@d[a_].\[Gamma]@d[b_].\[Gamma]@d[c_].\[Gamma]@d[d_]]:>4(g@dd[a,b]g@dd[c,d]-g@dd[a,c]g@dd[b,d]+g@dd[a,d]g@dd[b,c])/;FreeQ[{a,b,c,d},5],
Tr[\[Gamma]@u[a_].\[Gamma]@u[b_].\[Gamma]@u[c_].\[Gamma]@u[d_]]:>0/;Count[{a,b,c,d},5]===1
};
ps55e={
Tr[\[Gamma]@u[5]]->0,
Tr[\[Gamma]@u[a_].\[Gamma]@u[b_]]:>0/;Count[{a,b},5]===1,
Tr[\[Gamma]@u[a_].\[Gamma]@u[b_].\[Gamma]@u[c_]]:>0/;Count[{a,b,c},5]===1
};
psA27g={
Tr[\[Gamma]@u[a_].\[Gamma]@u[b_].\[Gamma]@u[c_].\[Gamma]@u[d_].\[Gamma]@u[5]]->-4 I \[Epsilon]@uuuu[a,b,c,d],
Tr[\[Gamma]@u[5].\[Gamma]@u[a_].\[Gamma]@u[b_].\[Gamma]@u[c_].\[Gamma]@u[d_]]->-4 I \[Epsilon]@uuuu[a,b,c,d]};
psA29={(*Einstein summed. sLowerAllIndices NEEDS to be handled seperately. TODO: generalize to make this independent of up-down indices of uncontracted \[Gamma]'s *)
\[Gamma]@u[a_].\[Gamma]@d[a_]->4,
\[Gamma]@u[a_].\[Gamma]@u[b_].\[Gamma]@d[a_]->-2 \[Gamma]@u[b],
\[Gamma]@u[a_].\[Gamma]@u[b_].\[Gamma]@u[c_].\[Gamma]@d[a_]->4 g@uu[b,c],
\[Gamma]@u[a_].\[Gamma]@u[b_].\[Gamma]@u[c_].\[Gamma]@u[d_].\[Gamma]@d[a_]->-2 \[Gamma]@u[d].\[Gamma]@u[c].\[Gamma]@u[b],
\[Gamma]@u[a_].\[Gamma]@d[b_].\[Gamma]@d[a_]->-2 \[Gamma]@d[b],
\[Gamma]@u[a_].\[Gamma]@d[b_].\[Gamma]@d[c_].\[Gamma]@d[a_]->4 g@dd[b,c],
\[Gamma]@u[a_].\[Gamma]@d[b_].\[Gamma]@d[c_].\[Gamma]@d[d_].\[Gamma]@d[a_]->-2 \[Gamma]@d[d].\[Gamma]@d[c].\[Gamma]@d[b],
\[Gamma]@d[a_].\[Gamma]@u[a_]->4,
\[Gamma]@d[a_].\[Gamma]@u[b_].\[Gamma]@u[a_]->-2 \[Gamma]@u[b],
\[Gamma]@d[a_].\[Gamma]@u[b_].\[Gamma]@u[c_].\[Gamma]@u[a_]->4 g@uu[b,c],
\[Gamma]@d[a_].\[Gamma]@u[b_].\[Gamma]@u[c_].\[Gamma]@u[d_].\[Gamma]@u[a_]->-2 \[Gamma]@u[d].\[Gamma]@u[c].\[Gamma]@u[b],
\[Gamma]@d[a_].\[Gamma]@d[b_].\[Gamma]@u[a_]->-2 \[Gamma]@d[b],
\[Gamma]@d[a_].\[Gamma]@d[b_].\[Gamma]@d[c_].\[Gamma]@u[a_]->4 g@dd[b,c],
\[Gamma]@d[a_].\[Gamma]@d[b_].\[Gamma]@d[c_].\[Gamma]@d[d_].\[Gamma]@u[a_]->-2 \[Gamma]@d[d].\[Gamma]@d[c].\[Gamma]@d[b]
};

(*Review for accuracy and consistency*)
simpleGammau={
ps370,ps369,wiki1,
\[Gamma]@u[i_].\[Gamma]@u[i_]->g@uu[i,i],
ps55a,ps55b,ps55b,ps55c,ps55e,ps55d,
psA27g,psA29
}//DeleteDuplicates;
simpleGamma=Append[simpleGammau,{(simpleGammau//.{sLowerAllIndices,T[g,"uu"][i_,j_]->T[g,"dd"][i,j]}),simpleDot}]//Flatten//DeleteDuplicates;

(*Pauli matrices. NOTE: substituting into function arguement generates errors. *)
sPauli=
{\[Sigma]@u[1|space@1]->{{0,1},{1,0}},
\[Sigma]@u[2|space@2]->{{0,-I},{I,0}},
\[Sigma]@u[3|space@3]->{{1,0},{0,-1}},
\[Sigma]@d[1|space@1]->{{0,1},{1,0}},
\[Sigma]@d[2|space@2]->{{0,-I},{I,0}},
\[Sigma]@d[3|space@3]->{{1,0},{0,-1}},
\[Sigma]@u[0]->{{1,0},{0,1}},(*this may cause problems*)
\[Sigma]@d[0]->{{1,0},{0,1}},
Id[\[Sigma]]->{{1,0},{0,1}},
0[\[Sigma]]->{{0,0},{0,0}}
};
(**) 
sPauliFlatten::usage:="sPauliFlatten[exp_] changes exp_ with Pauli matrices with standard representation. Applies ArrayFlatten to List's in exp_ to convert to matrix form. *24Apr2015*";
sPauliFlatten[exp_]:=Block[{$=exp},
$=$//.sPauli;
$=$/.ll:List[__]:>ArrayFlatten[ll]
];

(* SU[2] \[Sigma] commutation relationship *)
su2commutation[lab_,a_,b_,c_]:={MCommutator[Tensor[lab,{a},{Void}],Tensor[lab,{b},{Void}]]->I \[Epsilon]uuu[a,b,c]Tensor[lab,{c},{Void}]}
(*
Rules that simplifies Dot[\[Sigma]@u[n]] expressions *22Jul2013*)
simplePauli={
(*0[\[Sigma]] rules*)
dotOps[b___,0[\[Sigma]] ,  a___]->0[\[Sigma]],(*dotOps[a_ ,  0[\[Sigma]]]->0[\[Sigma]],*)
0[\[Sigma]]^n_->0[\[Sigma]],
a__  0[\[Sigma]]->0[\[Sigma]],
dotOps[a___,0[\[Sigma]],b___]->0[\[Sigma]],
Plus[a___,0[\[Sigma]],b___]:>a+b,
(*Id[\[Sigma]] rules*)
\[Sigma]@u[0]|\[Sigma]@d[0]->Id[\[Sigma]],

\!\(\*OverscriptBox[\(Id[\[Sigma]]\), \(_\)]\)|Conjugate[Id[\[Sigma]]]|Transpose[Id[\[Sigma]]]->Id[\[Sigma]],
dotOps[Id[\[Sigma]],Id[\[Sigma]]]->Id[\[Sigma]],
(dd:dotOps)[a___,Id[\[Sigma]],b___]->dd[a,b],
Id[\[Sigma]]^n_->Id[\[Sigma]],

ConjugateTranspose[\[Sigma]@u[a_]]->\[Sigma]@u[a],
ConjugateTranspose[\[Sigma]@d[a_]]->\[Sigma]@d[a],
Transpose[\[Sigma]@d[a_]]:>\[Sigma]@d[a]/;MemberQ[Flatten[{0,1,3,space/@{1,3}}],a],
Transpose[\[Sigma]@u[a_]]:>\[Sigma]@u[a]/;MemberQ[Flatten[{0,1,3,space/@{1,3}}],a],
Transpose[\[Sigma]@d[a_]]:>-\[Sigma]@d[a]/;MemberQ[{2,space@2},a],
Transpose[\[Sigma]@u[a_]]:>-\[Sigma]@u[a]/;MemberQ[{2,space@2},a],

Conjugate[\[Sigma]@d[a_]]:>\[Sigma]@d[a]/;MemberQ[Flatten[{0,1,3,space/@{1,3}}],a],
Conjugate[\[Sigma]@u[a_]]:>\[Sigma]@u[a]/;MemberQ[Flatten[{0,1,3,space/@{1,3}}],a],
Conjugate[\[Sigma]@d[a_]]:>-\[Sigma]@d[a]/;MemberQ[Flatten[{2,space/@2}],a],
Conjugate[\[Sigma]@u[a_]]:>-\[Sigma]@u[a]/;MemberQ[Flatten[{2,space/@2}],a],

dotOps[\[Sigma]@d[a_],\[Sigma]@d[b_]]:>(KroneckerDelta[a,b] Id[\[Sigma]]+I  Sum[LeviCivitaTensor[3][[a,b,i$]].\[Sigma]@d[i$],{i$,3}]//.simpleDot)/;MemberQ[Flatten[{1,2,3,space/@{1,2,3}}],a]&&MemberQ[Flatten[{1,2,3,space/@{1,2,3}}],b],
dotOps[\[Sigma]@u[a_],\[Sigma]@u[b_]]:>(KroneckerDelta[a,b]Id[\[Sigma]]+I  Sum[LeviCivitaTensor[3][[a,b,i$]].\[Sigma]@u[i$],{i$,3}]//.simpleDot)/;(MemberQ[Flatten[{1,2,3,space/@{1,2,3}}],a]&&MemberQ[Flatten[{1,2,3,space/@{1,2,3}}],b]),

\!\(\*OverscriptBox[\(\[Sigma]@d[a_]\), \(_\)]\):>-\[Sigma]@d[a]/;MemberQ[{2,space@2},a],

\!\(\*OverscriptBox[\(\[Sigma]@u[a_]\), \(_\)]\):>-\[Sigma]@u[a]/;MemberQ[{2,space@2},a]
};

(* Applies simplePauli and simpleDot repeatedly *)
simplePauli1[exp_,scalar_List]:=Module[{tmp=exp,tmp1},
tmp=tmp/.xDot->Dot;
While[tmp=!=tmp1,
tmp1=tmp;
tmp=tmp//.simplePauli//.simpleDot2[scalar]
];
tmp
];
simplePauli1[scalar_List][exp_]:=simplePauli1[exp,scalar]
(*
subPauli[pattern_List:{}] putputs a list of common Rule[]s for Pauli spin matrices.  pattern_List are variables used to apply RuleVarPattern[pattern]. *27Oct2014*)
subPauli[pattern_List:{}]:=Block[{sub,$\[Sigma]},
$\[Sigma][i_]:=T[\[Sigma],"u"][i];
sub={
MCommutator[$\[Sigma][i],$\[Sigma][j]]:>2 I T[\[Epsilon],"uuu"][i,j,k]$\[Sigma][k]/;FreeQ[{i,j,k},0],
ACommutator[$\[Sigma][i],$\[Sigma][j]]:>2 T[\[Delta],"uu"][i,j]/;FreeQ[{i,j},0],
Dot[$\[Sigma][i],$\[Sigma][j]]:>I  T[\[Epsilon],"uuu"][i,j,k]$\[Sigma][k]+T[\[Delta],"uu"][i,j]/;FreeQ[{i,j,k},0],
$\[Sigma][i].$\[Sigma][0]->$\[Sigma][i],
$\[Sigma][0].$\[Sigma][i]->$\[Sigma][i]
};
RuleVarPattern[pattern]/@sub
]

(*
Rules for \[Gamma][\[Sigma] Pauli spin matrices in Dirac basis.*22Jul2013*)
sub\[Gamma]Pauli=
{(*Dirac basis for \[Gamma]'s.*)
(*raise all \[Gamma] indices*)
Dot->xDot,(*Needed for subMatrix operations.*)
\[Gamma]@d[a_]:>If[MemberQ[{1,2,3},a],-\[Gamma]@u[a],\[Gamma]@u[a]],(*Raise indices g[+---]*)
\[Gamma]@u[a:(1|2|3)]->{{0[\[Sigma]],\[Sigma]@u[a]},{-\[Sigma]@u[a],0[\[Sigma]]}},
\[Gamma]@u[0]->{{\[Sigma]@u[0],0[\[Sigma]]},{0[\[Sigma]],-\[Sigma]@u[0]}},
\[Gamma]@u[5]->{{0[\[Sigma]],\[Sigma]@u[0]},{\[Sigma]@u[0],0[\[Sigma]]}},
\[Sigma]@u[0]->Id[\[Sigma]],
simpleDot2[{}]
}//Flatten;
(*
\[Gamma] matrices in standard representation*)
sub\[Gamma]Matrices:=Flatten[{Map[#->ArrayFlatten[#//.sub\[Gamma]Pauli//.sPauli]&,Table[\[Gamma]@d[\[Mu]],{\[Mu],{0,1,2,3,5}}]],Map[#->ArrayFlatten[#//.sub\[Gamma]Pauli//.sPauli]&,Table[\[Gamma]@u[\[Mu]],{\[Mu],{0,1,2,3,5}}]],Id[4]->DiagonalMatrix[{1,1,1,1}]}]

(*Evaluates xDot expression using Dot for actual matrix multiply but maintaining order of xDot terms.  Used in EvalVia\[Sigma]Matrices*)
AxDot2Dot[xDotexp_]:=Module[{tmp,a,A$},
tmp=MapIndexed[Map[A$[#2],#1,{2}]&,xDotexp,1];(*Mark for order*)
tmp=tmp/.xDot->Dot;(*Do Dot[]*)
Off[Dot::dotsh];
tmp=tmp/.Times->Dot;(*fix ordering. This step cause error messages.*)
On[Dot::dotsh];
tmp=tmp/.A$[_][a_]->a;(*remove ordering parameter*)
tmp=tmp/.simpleDot;(*simplify*)
tmp=tmp//.sub\[Gamma]Pauli/.xDot->Dot;(*simplify \[Sigma]*)
tmp=tmp/.sPauli;(*expand \[Sigma] for each element in Dot[]*)
tmp=Map[ArrayFlatten[#]&,tmp](**)
];
(*Evaluates matrix exp_ with \[Gamma] matrices to pure matrix expression via \[Sigma] matrices *)
EvalVia\[Sigma]Matrices[exp_]:=Module[{tmp=exp,a},
tmp=tmp//.sub\[Gamma]Pauli;
tmp=tmp/.xDot[a___]:>AxDot2Dot[xDot[a]]
];

Clear[tuMatrixOrderedMultiply];
tuMatrixOrderedMultiply::usage="tuMatrixOrderedMultiply[exp_] evaluates top Level matrix expressions (Head->dotOps) using Dot for actual matrix multiply but maintaining order of elements from each matrix.  The matrix inputs must have the same proper form and sizes. This routine is useful when matrix elements are noncommuting matrices. *18Feb2016*";
tuMatrixOrderedMultiply[exp_]:=Block[{tmp,A$,head,pos,$p,i,$n,$},
pos=tuExtractPositionPattern[dotOps][exp];xPrint[">>",pos];
pos=tuPositionNestDelete[pos];xPrint[">>",pos];
(*extract top level dotOps terms*)
Do[
$p=pos[[i,1]]; xPrint[$p,"<<"];
$p=If[$p[[-1]]==0,Delete[$p,-1]];(*delete Head index*)
$=Part[exp,Apply[Sequence,$p]];xPrint["===",$];
pos[[i,1]]=$p;
If[MatchQ[head=Head[$],dotOps],
(*Matrix multiply only first level*)
tmp=MapIndexed[Map[A$[#2],#1,{2}]&,$];
tmp=tmp/.head->Dot;(*rely on lexiconical ordering of Times NOTE: may not properly handle mixed dotOps in expression. *)
tmp=tmp/.Times->head;(*fix ordering within matrix elements.*)
tmp=tmp/.A$[_][a_]->a  (*remove ordering header*)
];
pos[[i,2]]=tmp
,
{i,Length[pos]}];
tuReplacePart [exp,pos]
];

OrderedxDotMultiply[exp_xDot]:=tuMatrixOrderedMultiply[exp];(*Compatibility*)
OrderedxDotMultiplySimpleDot[scalar_List][exp_xDot]:=Module[{tmp},
tmp=OrderedxDotMultiply[exp];
tmp//.tuOpSimplify[dotOps,scalar]
];
OrderedxDotMultiplyAll[scalar_List:{}][exp_]:=Module[{tmp=exp},
tmp=tmp//.xDot[a__]:>OrderedxDotMultiplySimpleDot[scalar][xDot[a]]
];

(*Defines SU3 representations, n->1: PS.20.38 *)
DefSU3rep[n_]:=Module[
{},
Switch[n,1,
DefineTensor[D,\[Tau],T,t];
SU3rep={
t@u[4]->{{0,0,1},{0,0,0},{1,0,0}}/2,
t@u[5]->{{0,0,-I},{0,0,0},{I,0,0}}/2,
t@u[6]->{{0,0,0},{0,0,1},{0,1,0}}/2,
t@u[7]->{{0,0,0},{0,0,-I},{0,I,0}}/2,
t@u[8]->{{1,0,0},{0,1,0},{0,0,-2}}/(2Sqrt[3])
};
For[i$=1,i$<=3,i$++,
tmp=\[Sigma]@u[i$]/2/.sPauli;
tmp=ArrayPad[tmp,{{0,1},{0,1}}];
AppendTo[SU3rep,t@u[i$]->tmp];
];
SU3rep=Sort[SU3rep];
Column[
SU3rep];
];
];
(* 
Test if exp_ is Listable list of all \[Gamma]@u[]||\[Gamma]@d[] *12Oct2012*)
allGammaQ[exp_]:=Apply[And,Map[MemberQ[{#},T[\[Gamma],"u"][_]]||MemberQ[{#},T[\[Gamma],"d"][_]]&,Apply[List,exp]]];
(* Extracts list of indices from dot product of \[Gamma]@u[]s. *)
Extract\[Gamma]Indices[exp_]:=Flatten[Apply[List,exp]/.Tensor[\[Gamma],a_,b_]->a];
(* 
Rules to simplify Tr[\[Gamma]@u[]s]. Accounts for \[Gamma] up-down indices.  *2Dec2014*)
subTraceGamma0:={Tr[]->1,
Tr[0]->0,
Tr[Id]->4,
Tr[Tensor[\[Gamma],{u_},{d_}]]->0,
Tr[Tensor[\[Gamma],{u1_},{d1_}].Tensor[\[Gamma],{u2_},{d2_}]]:>4 Tensor[g,Flatten[{u1,u2}],Flatten[{d1,d2}]]/;!MemberQ[Flatten[{u1,d1,u2,d2}],5],
Tr[Tensor[\[Gamma],{u1_},{d1_}].Tensor[\[Gamma],{u2_},{d2_}]]:>0/;Count[Flatten[{u1,d1,u2,d2}],5]==1,
Tr[dd:HoldPattern[Dot[a__]]]:>0/;allGammaQ[dd]&&((EvenQ[Length[dd]]&&Count[dd,Tensor[\[Gamma],{Void|5},{Void|5}]]==1)||
OddQ[Length[dd]]&&Count[dd,Tensor[\[Gamma],{Void|5},{Void|5}]]==0
),
Tr[dd:HoldPattern[Dot[a__]]]:>0/;allGammaQ[dd]&&((Length[dd]==3&&Count[dd,Tensor[\[Gamma],{Void|5},{Void|5}]]==1)
),
Tr[Tensor[\[Gamma],a1_,b1_].Tensor[\[Gamma],a2_,b2_].Tensor[\[Gamma],a3_,b3_].Tensor[\[Gamma],a4_,b4_]]:>4((Tensor[g,Flatten[{a1,a2}],Flatten[{b1,b2}]]Tensor[g,Flatten[{a3,a4}],Flatten[{b3,b4}]])
-(Tensor[g,Flatten[{a1,a3}],Flatten[{b1,b3}]]Tensor[g,Flatten[{a2,a4}],Flatten[{b2,b4}]])
+(Tensor[g,Flatten[{a1,a4}],Flatten[{b1,b4}]]Tensor[g,Flatten[{a2,a3}],Flatten[{b2,b3}]])
)/;!MemberQ[{a1,a2,a3,a4,b1,b2,b3,b4},5],
Tr[Tensor[\[Gamma],a1_,b1_].Tensor[\[Gamma],a2_,b2_].Tensor[\[Gamma],a3_,b3_].Tensor[\[Gamma],a4_,b4_].Tensor[\[Gamma],a5_,b5_]]:>-4I Tensor[\[Epsilon],
Flatten[{a1,a2,a3,a4}],Flatten[{b1,b2,b3,b4}]]/;MemberQ[Flatten[{a5,b5}],5],
(*In case \[Gamma]^5 is not at end.*)
Tr[(dd:dotOps)[a_,b__]]:>-4I \[Epsilon]@uuuu[ Apply[Sequence,Extract\[Gamma]Indices[DeleteCases[dd[a,b],\[Gamma]@u[5]]]]]/;(allGammaQ[dd[a,b]]&&Length[dd[a,b]]==5&&Count[dd[a,b],\[Gamma]@u[5]]==1)
};
(* Test of subTraceGamma0.
tmp={Tr[Id],Tr[\[Gamma]@u[5]],Tr[\[Gamma]@u[a]],Tr[\[Gamma]@u[a].\[Gamma]@u[b]],Tr[\[Gamma]@u[a].\[Gamma]@u[5]],Tr[\[Gamma]@u[a].\[Gamma]@u[d].\[Gamma]@u[c]],Tr[\[Gamma]@u[a].\[Gamma]@u[d].\[Gamma]@u[5]],Tr[\[Gamma]@u[a].\[Gamma]@u[b].\[Gamma]@u[c].\[Gamma]@u[d]],Tr[\[Gamma]@u[a].\[Gamma]@u[b].\[Gamma]@u[c].\[Gamma]@u[5]],Tr[\[Gamma]@u[a].\[Gamma]@u[b].\[Gamma]@u[c].\[Gamma]@u[d].\[Gamma]@u[e]],Tr[\[Gamma]@u[a].\[Gamma]@u[b].\[Gamma]@u[c].\[Gamma]@u[d].\[Gamma]@u[5]]}
TableForm[
Map[{#,#/.subTraceGamma0}&,tmp]
];     *)
(*
simpleTrGamma1[scalar_List][exp_] simplifies Tr[\[Gamma]'s] terms in exp_. Assumes NDim. *7Dec2015*)
simpleTrGamma1[scalar_List:{}][exp_]:=Block[{$tmp=exp,test},
While[test=!=$tmp,
test=$tmp;
$tmp=$tmp//.simpleTr2[scalar]//simpleDot3[scalar];
$tmp=$tmp//GammaLeft[\[Gamma]@d[5]]//GammaLeft[\[Gamma]@u[5]];
$tmp=$tmp//.subTraceGamma0//.simpleGamma
];
$tmp
]
(*
simpleTrGamma[exp_] simplifies Tr[Dot[\[Gamma]'s] terms in exp_.  Implements all of the relations in PS.A.27. OBSOLETE: use simpleTrGamma1 *24Sep2012*)
simpleTrGamma[exp_]:=Module[{tmp,sub,subu,subd},
sub={Tr[]->1,Tr[0]->0,
Tr[Id|Id[__]]:>NDim,(*assume 4-dim.*)
Tr[\[Gamma]@d[_]]->0,
Tr[\[Gamma]@u[_]]->0,
Tr[-a_]->-Tr[a],
(*Even and Odd number of \[Gamma]'s. *)
Tr[(op:dotOps)[a__]]:>0/;(allGammaQ[{a}]&&EvenQ[Length[{a}]]&&OddQ[Count[{a},\[Gamma]@u[5]]+Count[{a},\[Gamma]@d[5]]]),
Tr[(op:dotOps)[a__]]:>0/;(allGammaQ[{a}]&&OddQ[Length[{a}]]&&EvenQ[Count[{a},\[Gamma]@u[5]]+Count[{a},\[Gamma]@d[5]]])
};
subd={
Tr[\[Gamma]@d[a_].\[Gamma]@d[b_]]:>If[MemberQ[{a},5],0,4 T[g,"dd"][a,b]],
Tr[\[Gamma]@d[a_].\[Gamma]@d[b_].\[Gamma]@d[c_]]:>0,
Tr[\[Gamma]@d[a_].\[Gamma]@d[b_].\[Gamma]@d[c_].\[Gamma]@d[d_]]:>4 (T[g,"dd"][a,b]T[g,"dd"][ c,d]-T[g,"dd"][a,c]T[g,"dd"][ b,d]+T[g,"dd"][a,d]T[g,"dd"][b,c])/;(!MemberQ[{a,b,c,d},5]),
Tr[\[Gamma]@d[a_].\[Gamma]@d[b_].\[Gamma]@d[c_].\[Gamma]@d[e_]]:>0/;MemberQ[{a},5],
Tr[\[Gamma]@d[a_].\[Gamma]@d[b_].\[Gamma]@d[c_].\[Gamma]@d[d_].\[Gamma]@d[e_]]:>-4 I T[\[Epsilon],"dddd"][b,c,d,e]/;MemberQ[{a},5]
};
subu={
Tr[\[Gamma]@u[a_].\[Gamma]@u[b_]]:>If[MemberQ[{a},5],0,4 T[g,"uu"][a,b]],
Tr[\[Gamma]@u[a_].\[Gamma]@u[b_].\[Gamma]@u[c_]]:>0,
Tr[\[Gamma]@u[a_].\[Gamma]@u[b_].\[Gamma]@u[c_].\[Gamma]@u[d_]]:>4 (T[g,"uu"][a,b]T[g,"uu"][ c,d]-T[g,"uu"][a,c]T[g,"uu"][ b,d]+T[g,"uu"][a,d]T[g,"uu"][b,c])/;(!MemberQ[{a,b,c,d},5]),
Tr[\[Gamma]@u[a_].\[Gamma]@u[b_].\[Gamma]@u[c_].\[Gamma]@u[e_]]:>0/;MemberQ[{a},5],
Tr[\[Gamma]@u[a_].\[Gamma]@u[b_].\[Gamma]@u[c_].\[Gamma]@u[d_].\[Gamma]@u[e_]]:>-4 I T[\[Epsilon],"uuuu"][b,c,d,e]/;MemberQ[{a},5]
};
tmp=exp//GammaLeft[\[Gamma]@d[5]]//GammaLeft[\[Gamma]@u[5]];
tmp//.Join[sub,subd,subu]
];
(*
RaiseTr\[Gamma]Indices[exp_Tr] raises the index of all \[Gamma]@d[] Tensors in exp_Tr using metric Tensor g@dd[].  The purpose of this Module is so we can apply simpleTrGamma. NOTE: Might want to incorporate into simpleTrGamma. *14Oct2012*)
RaiseTr\[Gamma]Indices[exp_Tr]:=Module[{tmp,glist,tmpi},
glist=Apply[List,exp];
glist=Cases[glist[[1]],T[\[Gamma],"d"][x_]];
tmp=exp//.T[\[Gamma],"d"][x_]:>T[\[Gamma],"u"][(tmpi=Unique[])]g@dd[x,tmpi];
tmp=tmp//.simpleDot2[{g@dd[_,_]}]//.simpleTr2[{g@dd[_,_]}]
];
(*Rule generator for expanding spinorBar, Overscript[u, _], expressions->u^\[Dagger].\[Gamma]0->\[Gamma]0.u .*)
spinorBarExpand[\[Psi]_]:=Module[{sub,tmpu=\[Psi]},
sub=
\!\(\*OverscriptBox[\(\[Psi]\), \(_\)]\)->ConjugateTranspose[RemovePatterns[\[Psi]]].\[Gamma]@u[0];
{Map[ConjugateTranspose[#]&,sub]/.simpleHermitian[{\[Gamma]@u[_]}],sub}
];
(*
Example of how to form Rules*)
spinorBarExpandRule[spinor_List]:=Module[{tmp},
tmp=Map[spinorBarExpand[#]&,spinor]//Flatten;
Map[MapAt[(*Pattern confuses match.*)RemovePatterns[#]&,#,{2}]&,tmp]
];
(*
Templates Rules for evaluating scattering amplitutes. *14Jan2014*)
scatteringAmplitudeRules:=
{Abs[\[ScriptCapitalM][_]]^2:>SuperDagger[\[ScriptCapitalM]].\[ScriptCapitalM],
a___ 
\!\(\*OverscriptBox[\(u_\), \(_\)]\)[pu_].T[\[Gamma],"u"][\[Mu]_].v_[pv_]->a Conjugate[ 
\!\(\*OverscriptBox[\(v\), \(_\)]\)[pv].T[\[Gamma],"u"][\[Mu]].u[pu]],(*Use carefully-loops*)
ConjugateTranspose[(U:u_)[a_]].\[Gamma]@u[0]->
\!\(\*OverscriptBox[\(U\), \(_\)]\)[a],(*PS.3.55*)\[Gamma]@u[0].ConjugateTranspose[
\!\(\*OverscriptBox[\((U : u_)\), \(_\)]\)[a_]]->U[a],
ConjugateTranspose[
\!\(\*OverscriptBox[\((U : u_)\), \(_\)]\)[a_]]. 
\!\(\*OverscriptBox[\(u_\), \(_\)]\)[a_]->\[Gamma]@u[0]. U[a].
\!\(\*OverscriptBox[\(U\), \(_\)]\)[a],
(*Sum fermion spins *PS.5.3*)
(op:dotOps)[a___,(V:v_)[p_],
\!\(\*OverscriptBox[\(v_\), \(_\)]\)[p_],b___]:>op[a,Slash[p]+Subscript[m, p[[2]]],b]/;!FreeQ[V,u],
(op:dotOps)[
\!\(\*OverscriptBox[\(v_\), \(_\)]\)[p_],a___,(V:v_)[p_],b___]:>op[Slash[p]+Subscript[m, p[[2]]],a]/;!FreeQ[V,u],
(op:dotOps)[a___,(V:u_)[p_],
\!\(\*OverscriptBox[\(u_\), \(_\)]\)[p_],b___]:>op[a,Slash[p]-Subscript[m, p[[2]]],b]/;!FreeQ[V,v],
(op:dotOps)[
\!\(\*OverscriptBox[\(u_\), \(_\)]\)[p_],a___,(V:u_)[p_],b___]:>op[Slash[p]-Subscript[m, p[[2]]],a]/;!FreeQ[V,v],
(*Other forms of fermion spin sum*)
(op:dotOps)[a___,V:v_[p_],
\!\(\*OverscriptBox[\(v_\), \(_\)]\)[p_],b___]->op[a,Slash[p]-Subscript[m, V],b],
xDot[V:
\!\(\*OverscriptBox[\(u\), \(_\)]\)[p_],a__,u[p_]]->a.Slash[p]+Subscript[m, V],
HoldPattern[Dot[V:
\!\(\*OverscriptBox[\(u\), \(_\)]\)[p_],a__,u[p_]]]->a.Slash[p]+Subscript[m, V],
(V:v[p_]).
\!\(\*OverscriptBox[\(v\), \(_\)]\)[p_]->Slash[p]-Subscript[m, V],
(V:u[p_]).
\!\(\*OverscriptBox[\(u\), \(_\)]\)[p_]->Slash[p]+Subscript[m, V],
v_[p_].
\!\(\*OverscriptBox[\(v_\), \(_\)]\)[p_]->Slash[p]-Subscript[m, p],
HoldPattern[Dot[(
\!\(\*OverscriptBox[\(u_\), \(_\)]\))[p_],a__,u_[p_]]]->a.(Slash[p]+Subscript[m, p]),
HoldPattern[
\!\(\*OverscriptBox[\(u\), \(_\)]\)[p_].a__ .  (V:u[p_])]->a .  (Slash[p]+Subscript[m, V]),
HoldPattern[
\!\(\*OverscriptBox[\(v\), \(_\)]\)[p_].a__ .  (V:v[p_])]->a .  (Slash[p]-Subscript[m, V]),
Slash[p_]:>\[Gamma]@u[i$=Unique[]]T[p,"d"][i$],
(Times|Dot)[Slash[a_],Slash[b_]]->T[a,"u"][i$=Unique[]]T[b,"d"][i$],
(*Must apply first if Slash already in expression.*)
(*Conjuation of vertex terms.*)
Conjugate[
\!\(\*OverscriptBox[\(v_\), \(_\)]\)[pv_]. FN[\[Gamma]] . (u_[pu_])]->
\!\(\*OverscriptBox[\(u\), \(_\)]\)[pu].FN[\[Gamma]].v[pv],
HoldPattern[Conjugate[
\!\(\*OverscriptBox[\(v_\), \(_\)]\)[pv_]]. a___ . Conjugate[u_[pu_]]]:>
\!\(\*OverscriptBox[\(u\), \(_\)]\)[pu].Conjugate[Dot[a]].v[pv],
HoldPattern[(op:dotOps)[Conjugate[
\!\(\*OverscriptBox[\(v_\), \(_\)]\)[pv_]], a___ , Conjugate[u_[pu_]]]]:>op[
\!\(\*OverscriptBox[\(u\), \(_\)]\)[pu],Conjugate[Dot[a]],v[pv]]
};


DotExpandMode[False];


Clear[OPEContract]
OPEContract::usage="OPEContract[e1_,e2_] performs OPE contraction product of two NormalOrder[]d operators. BraKet indicates contraction. *30Oct2015*";
OPEContract[e1_,e2_]:=Block[{$,$1=List@@e1,$2=List@@e2},
$=Map[(BraKet@@# )NormalOrder[Complement[$1,#]]\[CenterDot]NormalOrder[Complement[$2,#]]&,Tuples[{$1,$2}]];
Apply[Plus,$]
];
tuOPEWick::usage="tuOPEWick[exp_] applies Wick's Theorem for OPE on exp_.  Only does 2 levels of nesting *30Oct2015*";
tuOPEWick[exp_]:=Block[{$=exp,$sNO},
$sNO=NormalOrder[a_List]\[CenterDot]NormalOrder[b_List]:>NormalOrder[Join[a,b]]+xOPEContract[a,b];
$=$/.$sNO;
$=$/.xOPEContract->OPEContract;xPrint[$];
$=$/.$sNO;
$=$/.xOPEContract[a__]->(1/2)OPEContract[a]/.NormalOrder[{}]->1//Expand//(#//.tuOpSimplify[CenterDot])&;
$
];




