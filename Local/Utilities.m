(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(*Example of simple graphic aids to draw figures on a rectangle.  Define vertices and lines;
vx=Tuples[{{0,1,2,3,4},{1,0,-1}}];
Graphics[MapIndexed[Text[#2,#1]&,vx]];
line={{vx[[1]],vx[[4]]},{vx[[4]],vx[[6]]},{vx[[6]],vx[[3]]},
{vx[[4]],vx[[7]]},{vx[[6]],vx[[9]]},{vx[[7]],vx[[9]]},
{vx[[9]],vx[[12]]},{vx[[7]],vx[[10]]},{vx[[12]],vx[[10]]},
{vx[[13]],vx[[10]]},{vx[[12]],vx[[15]]}
};
Graphics[{Thin,Black,Map[Line[#]&,line],MapIndexed[Text[#2,(#1[[1]]+#1[[2]])/2]&,line]}]
*)

(*  MidArrow[{{x1,y1},{x2,y2}}] draws arrow with symbol in middle  *)
MidArrow[xy_List]:={Arrowheads[Medium],Arrow[{xy[[1]],(xy[[1]]+xy[[2]])/2}],Line[{(xy[[1]]+xy[[2]])/2,xy[[2]]}]}
(*Draws text at mid line.*)
MidLineText[text_,line_List,style_List]:={Text[Style[text,style],(line[[1]]+line[[2]])/2]}
MidLineTextOffset[text_,line_List,style_List,Offset_List]:={Text[Style[text,style],((line[[1]]+Offset)+(line[[2]]+Offset))/2]}

TextOver[text_,xy_List]:={White,Disk[xy,0.2],
Text[Style[text,FontSize->16,Red],xy]};
TextOver[text_,xy_List,font_]:={White,Disk[xy,0.2],
Text[Style[text,FontSize->font,Red],xy]}

(*Contruct array of points and lines to be reference by array indices.*)
GraphicPointLines[
nx_(*Number of points X*),
ny_(*Number of points Y*),
linepoints_List(*indices that define lines*),
displayTemplate_:True]:=
Module[{vx,line,vxline},
vx=Tuples[{Range[nx]-1,Range[ny]-1}];
If[Depth[linepoints]==4,
line=linepoints,(*endpoints specified by x,y offset from LowerLeft*)
(*else by vx index*)
line=Map[{vx[[#[[1]]]],vx[[#[[2]]]]}&,linepoints]];
If[displayTemplate,
Print["General graphic definitions for array points and lines."];
Print[
Graphics[{Thick,RGBColor[1,0,1,.7],Map[Line[#]&,line],MapIndexed[Text[Style[#2[[1]],FontSize->30],(#1[[1]]+#1[[2]])/2]&,line],
RGBColor[.66,0,0,.5],MapIndexed[Text[Style[#2[[1]],FontSize->16 ],#1]&,vx]}]]];
{vx,line}(*returns point_List and line_List corresponding to graph numbers*)
];

(**)
(*Examples of H and X plot.*)
Graphics2H2[c1_,c2_,x_,c3_,c4_]:=Graphics[{Thick,Black,
MidArrow[{{0,-1},{1,0}}],
MidArrow[{{1,0},{0,1}}],
MidArrow[{{3,-1},{2 ,0}}],
MidArrow[{{2 ,0},{3 ,1}}],
Dotted,Line[{{1,0},{2 ,0}}],
TextOver[x,{1.5,0 }],
TextOver[c1,{0,-1}],
TextOver[c2,{3 ,-1}],
TextOver[c3,{0,1}],
TextOver[c4,{3 ,1}]
},ImageSize->Small
];
Graphics2X2[c1_,c2_,x_,c3_,c4_]:=Graphics[{Thick,Black,
MidArrow[{{-1,-1},{0,0}}],
MidArrow[{{1,-1},{0,0}}],
MidArrow[{{0,2},{-1 ,3}}],
MidArrow[{{0,2},{1 ,3}}],
Dotted,Line[{{0,0},{0 ,2}}],
TextOver[x,{0,1 }],
TextOver[c1,{-1,-1}],
TextOver[c2,{1 ,-1}],
TextOver[c3,{-1,3}],
TextOver[c4,{ 1,3}]
},ImageSize->Small
];


(*
Creates file with filename in SaveFile for saving variable expressions
SaveFile="$HomeDirectory<>"/Mathematica/PeskinSchroeder/NBname["stub"].out"]
*)
tuSaveFile:=Put[SaveFile=NBname["stub"]<>".out"] ;
(*
To save variables:
Put[variable_List,SaveFile];
or Save[SaveFile,variable_List];

To retrieve output definitions from file in current directory.
	Get[NotebookDirectory[]<>"LectureB2011.10.10.out"]
or   Get[$HomeDirectory<>"/Mathematica/PeskinSchroeder/FinalProject1.out"]*)
tuSaveAllVariables::usage="tuSaveAllVariables[file_:toSaveFile] saves all Context[Global'] variables to file_ ";
tuSaveAllVariables[file_:SaveFile]:=Block[{$},
$=Names["$*"];
$=Select[$,Context[#]=="Global`"&];
Inactive[Save][file,$ ]//Activate
];


(*variables inbedded in any one of tuRuleIndependentVarPattern are considered independent from the variable for the purpose of tuRule[]s. *)tuRuleIndependentVarPattern:={SubPlus[_],SubMinus[_],SuperPlus[_],SuperMinus[_],Subscript[_,_],Superscript[_,_],OverBar[_],UnderBar[_],OverTilde[_],OverHat[_],SuperStar[_]};
(**)
tuRule::usage="tuRule[rules_List] produces a List of valid Rule[]s from rules_List and forms a Flatten[]d list of Rules. Deletes imbedded comments and other non-Rule forms. Reforms Rule so -a\[Rule]b -> a\[Rule]-b . *7Aug2015*";
tuRule[rules_List]:=(Cases[DeleteCases[Flatten[rules],CO[__]|CG[__]],HoldPattern[_->_]|HoldPattern[_:>_]]/. {HoldPattern[-a_->b_]->a->-b,HoldPattern[-a_:>b_]->a:>-b});
(**)
Clear[tuRuleSelect];
tuRuleSelect::usage="tuRuleSelect[list_List][key_] selects all Rule[]s from list_List with the lhs equal to key_.  key_ may be a List of key_s. *5Sep2015*";
tuRuleSelect[list_List][key_]:=Block[{$keys,$rules},
$rules=tuExtractPattern[(Rule|RuleDelayed)[__]][list];
$keys=Flatten[{key}/.{}->\[EmptySet]]/.\[EmptySet]->{};
Cases[$rules,(Rule|RuleDelayed)[#,_]]&/@$keys//Flatten
];

(**)
tuRuleApply::usage="tuRuleApply[rules_,nosubFn_List:{}][exp_] applies rules_ via ReplaceRepeated on exp_.  The optional protected_List protects these variables/Patterns from subcomponent replacements. i.e, \!\(\*SubscriptBox[\(A\), \(0\)]\)/.A->aa is not replaced if Subscript[_,_] is a member of nosubFn_List Default nosubFn_List:tuRuleIndependentVarPattern *21Jan2016*";
tuRuleApply[rule_,nosubFn_List:tuRuleIndependentVarPattern][exp_]:=Block[{$=exp,$p,$pvar,$rhead,pvar1,$rule},
$rule=tuRule[rule];
(*possible protected variables*)
$p=$//tuExtractPositionPattern[nosubFn];xPrint[$p];
(*protected variables in rule_List*)
$rhead=#[[1]]&/@$rule;xPrint[$rhead];
$pvar=#[[2]]&/@$p;xPrint[$pvar];
$pvar=Select[$pvar,!tuMemberQ[#,$rhead]&];xPrint[$pvar];
(*replace protected variables in exp_*)
$pvar1=MapIndexed[#1->pvar[#2[[1]]]&,$pvar];xPrint[{$pvar1}];
$p=$p/.$pvar1;xPrint[$p];
$=tuReplacePart[$,$p];xPrint[$,"<<",$rule];
$=$/.$rule;xPrint[$];(*Repeated??*)
(*replacement Rule for pvar*)
$pvar1=Reverse[#]&/@($pvar1);xPrint[$pvar1];
$/.$pvar1
];
(*C[Rule]*)
tuRuleSolve::usage="tuRuleSolve[rules_,vars_,independentVars_List:tuRuleIndependentVarPattern] Solve[]s rules_ (singly or List[]) for vars_ (Singly or List[] of Pattern[]s) and returns Rules for vars_.  independentVars_Alternatives:{} can be set to indicate independent variables that are Mathematica functions such as OverBar[a]. *23May2014*";
tuRuleSolve[rules_,vars_,independentVars_List:tuRuleIndependentVarPattern,maxExtraCondition_:0]:=Block[{tmp,XXXX,varlist,Xs,subX,varPat,xrules,xvars=DeleteDuplicates[Flatten[{vars}]] ,independentPos,independents,independentLab,Is,IIII,subIIII,SolveArgs},
(**********)
{varlist,xrules}=ExtractPatternXpat[xvars][tuRule[{rules/.Equal->Rule}]];
varlist=DeleteDuplicates[varlist];(*OK?*)
subX=Thread[Rule[varlist,(Xs=Array[XXXX,Length[varlist]])]];
(*Substitute vars_ for Solve variables*)
tmp=xrules//.subX;xPrint[">",tmp];
tmp=Select[tmp,!tuFreeQ[#,Xs]&];(*Remove irrelevant Rules*)
SolveArgs={tmp,Xs};xPrint[">",SolveArgs,":",tmp,":",Xs];
(*independentVars need dummy labels incase unclothed independentVars is in vars_ *)
independentPos=ExtractPositionPattern[SolveArgs,independentVars];
independents=#[[2]]&/@independentPos//DeleteDuplicates;
independentLab=MapIndexed[#1->IIII[First[#2]]&,independents];
subIIII=independentPos//.independentLab;
SolveArgs=ReplacePart[SolveArgs,subIIII];xPrint[SolveArgs,":",subIIII];
SolveArgs=SolveArgs/.Rule->Equal;
tmp=Solve[Apply[Sequence,SolveArgs],MaxExtraConditions->maxExtraCondition];(*TEST*)
(*tmp=Solve[SolveArgs[[1]],SolveArgs[[2]]];*)
xPrint[SolveArgs,":",tmp];
(*Replace independentLab *)
tmp=tmp//RemovePatterns;xPrint[tmp];
tmp=tmp//.Reverse/@independentLab;
tmp=tmp//.Reverse/@subX//.Xpat[a_]->a;
tmp//Flatten
];
xRuleX[rules_,vars_,independentVars_List:{Subscript[_,_],Superscript[_,_],OverBar[_],OverTilde[_],OverHat[_],SuperStar[_]}]:=tuRuleSolve[rules,vars,independentVars];(*Compatibility*)
InvertRules[rules_List,vars_List]:=tuRuleSolve[rules,vars];(*Compatibility*)

Clear[tuRuleEliminate];
tuRuleEliminate::usage:="tuRuleEliminate[pattern_List][rules_List] composes rules from rules_List of form Map[Rule[tuRuleSolve[{rule_[#]},#],pattern_]. Works for Dot[] patterns.  WARNING: The order of rules_List determines the order in which patterns are substituted back into rules_.  *18Jun2015*";
tuRuleEliminate[pattern_List][rules_]:=Block[{$r=tuRule[{rules}],$rp={},$p=pattern},
(*Apply simple pattern_ rules first.*)
xPrint[">",$r];
$rp=Map[tuExtractPositionPattern[{#->_,_->#}][$r]&,$p];xPrint[">",$rp];
If[$rp!={{}}&&$rp!={},
$rp=Map[#[[1,1]]&,$rp]//DeleteDuplicates;xPrint[">",$p," ",$rp," ",$r,"<"];
$rp=Map[tuRuleSolve[$r[[#]],$p]&,$rp];
$rp=DeleteCases[$rp,HoldPattern[Solve[_,_]]]//Flatten;
If[Length[$r]>1,
$r=$r//.$rp,
$r=$rp];
];
(*Inspect each rule for possible pattern rule.*)
$rp=tuExtractPositionPattern[$p][$r];xPrint[">",$p," ",$rp," ",$r,"<"];
$rp=Map[#[[1,1]]&,$rp]//DeleteDuplicates;xPrint[$p," ",$rp];
$rp=Map[tuRuleSolve[$r[[#]],$p]&,$rp];xPrint[$p," ",$rp];
$rp=DeleteCases[$rp,HoldPattern[Solve[_,_]]]//Flatten;xPrint[">",$r," ",$rp];
If[Length[$r]>1,
$r=$r//.$rp,
$r=$rp
];
$r=DeleteCases[$r,a_->a_]//tuRule
];

(**)
tuEliminate::usage="tuEliminate[rules_,vars_,independentVars_List:tuRuleIndependentVarPattern] applies Eliminate[] to a list of rules_ eliminating vars_. Recognizes negative powers of vars_.  Variables Matching independentVars_ are treated independent variables. *23May2014";
tuEliminate[rules_,vars_,independentVars_List:tuRuleIndependentVarPattern]:=Block[{tmp,XXXX,varlist,Xs,subX,varPat,xrules,xvars=DeleteDuplicates[Flatten[{vars}]] ,independentPos,independents,independentLab,Is,IIII,subIIII,SolveArgs,ivars,xpower},
xpower[rule_Rule]:=Block[{pow,tmp=rule},(*eliminate negative powers in rule*)
tmp=tmp/.Power[a,n_]:>power[a,n]/;n<0;
pow=tmp//tuExtractPattern[power[a,_]];
tmp=If[pow=!={},
pow[[1,2]]=-pow[[1,2]];pow= pow[[1]]#&/@tmp;pow/.power->Power,
tmp];
tmp
];
(**********)
xrules=tuRule[{rules}/.{Equal->Rule,And->List}];
(*Eliminate 1/(vars_)^n from denominator in rules_ *)
ivars=1/#&/@xvars;
xrules=xpower/@xrules;
(**)
{varlist,xrules}=ExtractPatternXpat[xvars][xrules];
xPrint["VV",{varlist,xrules}];
varlist=DeleteDuplicates[varlist];(*OK?*)
subX=Thread[Rule[varlist,(Xs=Array[XXXX,Length[varlist]])]];xPrint[subX];
(*Substitute vars_ for Solve variables*)
tmp=xrules//.subX;
SolveArgs={tmp,Xs};
(*independentVars need dummy labels incase unclothed independentVars is in vars_ *)
independentPos=ExtractPositionPattern[SolveArgs,independentVars];
independents=#[[2]]&/@independentPos//DeleteDuplicates;
independentLab=MapIndexed[#1->IIII[First[#2]]&,independents];
subIIII=independentPos//.independentLab;
SolveArgs=ReplacePart[SolveArgs,subIIII];
SolveArgs=SolveArgs/.Rule->Equal;
tmp=Eliminate[Apply[Sequence,SolveArgs]];
(*Replace independentLab *)
tmp=tmp//RemovePatterns;
tmp=tmp//.Reverse/@independentLab;
tmp=tmp//.Reverse/@subX//.Xpat[a_]->a;
tmp//Flatten
];
xEliminate[rules_,vars_,independentVars_List:tuRuleIndependentVarPattern]:=
tuEliminate[rules,vars,independentVars];

(*Rewrites (simple) rule_ in form  var_\[Rule] ..  .  var_ may be a pattern but must only match one item in rule.  var_ needs to be a variable that can be Solved for in rule_.  
This Module does not work with Power or Sqrt[ ] .  Only uses first solution of Solve  *13Dec2012*)
RuleX[rule_Rule,var_]:=Module[{tmp=Apply[Equal,rule],XXXXX,list},
list=DeleteDuplicates[First[ExtractPatternXpat[var][rule]]];
If[list=!={},
tmp=tmp//.var->XXXXX;
tmp=Solve[tmp,XXXXX]//First;
If[Length[list]==1,
tmp=tmp//.XXXXX->list[[1]],
tmp=tmp//.XXXXX->var
];
tmp[[1,2]]=tmp[[1,2]]/.Pattern->xPattern/.xPattern[x_,b_]->x;
tmp/.Xpat[a_]->a,
{}(*Return {} if var_ \[Element] rule_Rule *)
]
];
(*
As RuleX but returns all solutions of Solve. *10Jan2013*)
RuleXall[rule_Rule,var_]:=Module[{tmp=Apply[Equal,rule],XXXXX,list},
list=DeleteDuplicates[ExtractPattern[rule,var]];
tmp=tmp//.var->XXXXX;
tmp=Solve[tmp,XXXXX];
If[Length[list]==1,(*In general only one var_*)
tmp=tmp//.XXXXX->list[[1]],
tmp=tmp//.XXXXX->var(*For cases where there may be a choice.*)
];
tmp//RemovePatterns
];
(* Applies RuleX[rule_,var_] to a list of Rules *13Dec2013*)
RuleX[rules_List,var_List]:=Module[{pos,sub,tmp=rules //Flatten },
tmp=tmp/.Rule->Equal;
tmp=Solve[tmp,var]//Flatten
];
(* Applies RuleX[rule_,var_] to a list of Rules *13Dec2013*)
RuleX[rules_List,var_]:=Module[{pos,sub,tmp={rules} //Flatten },
tmp=RuleX[#,var]&/@tmp//Flatten
];
RuleX2[rules_List,var_]:=RuleX[rules,var];(*Backward compatibility*)
(*Rewrites (simple) rule_ in form  var_\[Rule] ..   var_ may be a pattern but must only match one item in rule.  Returns all possible Solutions. *)RuleX1[rule_Rule,var_]:=Module[{tmp=Apply[Equal,rule],XXXXX,list,tmpx},
list=DeleteDuplicates[ExtractPattern[rule,var]];(*list of var*)
tmpx=tmp//.var->XXXXX;
tmpx=Solve[tmpx,XXXXX];
If[Length[list]==1(*one var*)&&Length[tmpx]>0,
(*\[Exists] some solution, replace*)
tmpx=tmpx/.XXXXX->list[[1]];
,
tmpx={Apply[Rule,tmp]}(*no solution*);
];
tmp=tmpx/.Pattern->xPattern/.xPattern[x_,b_]->x;
tmp//Flatten
];
(*
Applies RuleX converting patternvar_ on LHS to Pattern. *13Dec2012*)
RuleX[rules_, var_,patternvar_]:=Module[{},
RuleX2PatternVar[   RuleX[{rules},var],  patternvar  ]//Flatten
];
RuleX1[rules_, var_,patternvar_]:=Module[{},
RuleX2PatternVar[   RuleX[{rules},var],  patternvar  ]//Flatten
];
(* Changes straight variables in left-hand part of rules_ to Pattern as specified by patternvars_  *)
tuAddPatternVariable::usage="tuAddPatternVariable[variables_,Btype_:Blank][rules_] Converts variables_ on LHS of rules_ into Patterns (Btype_ option is available.). Syntax option: tuAddPatternVariable[rules_,variables_].  Rules/Variables may be a Lists. (*24Dec2014*)";
tuAddPatternVariable[ variables_ , Btype_ : Blank  ] [rules_]:=Block[{tmp=rules,pvar,sub},
pvar=Flatten[{variables}];
sub=Map[#->Pattern[#,Btype[]] &,pvar];
tmp=tmp/.Rule[a_,b_]:>xRule[a/.sub,b];
tmp=tmp//.xRule->Rule
];
RuleX2PatternVar[rules_,variables_]:=tuAddPatternVariable[variables][rules];(*Compatibility*)

(*Make Rule[]s from a 2-D table where the first row defines column parameter labels and the first column defines variables referenced by var_.  The result is a set of Rule[]s for each column parameter of the var_ specified.*)
TableRules[table_][var_]:=Module[{head=table[[1]],tmp=table,pattern,row},
pattern=Table[_,{Length[head]}];
pattern[[1]]=var;
tmp=Drop[tmp,1];
row=Cases[tmp,pattern]//First;
Drop[Thread[Rule[head,row]],1]
];
(**)
tuRuleSubtract::usage="tuRuleSubtract[rules_List] list of Rules and output a Rule which the first Rule minus the subsequent Rules for the right and left Rule terms. *21Jun2015*";
tuRuleSubtract[rules_List]:=Block[{tmp,head,first,rest},
head=Head[first=First[rules]];
rest=Rest[rules];
first=Apply[List,first];
rest=-Map[Apply[List,#]&,rest];
tmp=Flatten[{{first},rest},1];
tmp=MapThread[Plus,tmp];
Apply[head,tmp]
];
SubtractRules[rules_List]:=tuRuleSubtract[rules];(*Compatibility*)

tuRuleAdd::usage="tuRuleAdd[rules_List] returns a sum of Left Hand Side \[Rule] sum of Right Hand Side of rules_List *13Sep2015*";
tuRuleAdd[rules_List]:=
Apply[Plus,Map[First[#]&,rules]]->Apply[Plus,Map[Last[#]&,rules]];
AddRules[rules_List]:=tuRuleAdd[rules]; (*Compatibility*)

(*TimesRules take a list of Rules and output a Rule which is a product of right-hand terms to a product of left-hand terms.  *)
TimesRules[rules_List]:=Module[{tmp},
tmp=Map[Apply[List,#]&,rules];
tmp=MapThread[Times,tmp];
Apply[Rule,tmp]
];

(**)
tuRuleDivide::usage="tuRuleDivide[rules_List] forms ratio of first two Rules in rules_List. ";
tuRuleDivide[rules_List]:=Block[{tmp},
tmp=Map[Apply[List,#]&,rules];
tmp=MapThread[#1/#2&,tmp];
Apply[Rule,tmp]
];
DivideRules[rules_List]:=tuRuleDivide[rules];(*Compatibility*)

(*OpRules take a list of Rules and output a Rule which is a Op combination of right-hand terms to a Op combination of left-hand terms. Work with single item Rule_List *12Mar2014*)
OpRules[rules_List,operator_]:=Module[{tmp},
tmp=Map[Apply[List,#]&,rules];
tmp=MapThread[operator,tmp];
Apply[Rule,tmp]
];

(*OpRules take a list of Rules and output a Rule which is a Op combination of right-hand terms to a Op combination of left-hand terms. *)
OpRules[operator_,rules_List]:=Module[{tmp,head},
head=Head[First[rules]];
tmp=Map[Apply[List,#]&,rules];
tmp=MapThread[operator,tmp];
Apply[head,tmp]
];

(*Solves vars_ for a set of rules_ *)
SolveRules[rules_,vars_]:=Solve[(rules//.Rule->Equal),vars];

(**)
tuPatternRemove::usage="tuPatternRemove[exp_] removes Pattern[a_,Blank[]|BlankSequence[]]:>a in all of exp_ *24Nov2013*)";
tuPatternRemove[exp_]:=Block[{tmp=exp,xPattern},
tmp=tmp//.Pattern->xPattern//.xPattern[a_,Blank[]|BlankSequence[]]:>a/.xPattern->Pattern
];
RemovePatterns[exp_]:=tuPatternRemove[exp];(*Compatibility*)

(*
RuleVarPattern[var_List][rule_Rule] converts var in Rule to Pattern[var,Blank[]]*)
RuleVarPattern[var_List][rule_Rule|rule_RuleDelayed]:=Module[{tmp=rule[[1]]},
tmp=tmp/.Map[#->Pattern[#,Blank[]]&,var];
tmp=tmp->rule[[2]]
];
(*
RulesVarPatterns[var_List][exp_] converts var_List in exp_ containing Rule to Pattern[var,Blank[]] DOES NOT RECOGNIZE ALTERNATIVE exp ARGUEMENTS *7Dec2014*)
RulesVarPattern[var_List][exp_List|exp_Rule|exp_RuleDelayed]:=Module[{rulepos,tmp=exp},
If[Head[exp]===List,
rulepos=ExtractPositionPattern[{tmp},Rule[a_,b_]];
rulepos=Map[#[[1]]->RuleVarPattern[var][#[[2]]]&,rulepos];
tmp=ReplacePart[{tmp},rulepos][[1]]
,
tmp=exp[[1]];
tmp=tmp/.Map[#->Pattern[#,Blank[]]&,var];
tmp=tmp->exp[[2]]
];
tmp
];
(*
RulePatternCondition[rule_Rule|rule_RuleDelayed,pvars_List,condition_Hold] converts Rule into RuleDelayed with condition_Hold *24Nov2014*)
RulePatternCondition[rule_Rule|rule_RuleDelayed,pvars_List,condition_Hold]:=Module[{tmp=rule},
tmp=tmp//RuleX2PatternVar[pvars];
tmp[[2]]=tmp[[2]]/;condition;
tmp/.Rule->RuleDelayed//ReleaseHold
];
(*
RuleAddCondtion[condition_][rule_] adds condition_ to rule_.  *13Dec2013*)
RuleAddCondtion[cond_][rule_]:=Module[{tmp=rule},
tmp=tmp/.Rule[a_,b_]->xRule[a,xCondition[b,cond]];
tmp/.xCondition->Condition/.xRule->RuleDelayed//ReleaseHold];

tuSimplifyRules::usage="tuSimplifyRules[exp_] Simplify[]s Rules in exp_ *11Jan2015*";
tuSimplifyRules[exp_]:=Block[{$=exp},
$=$/.Rule->Equal//Simplify;
$=$/.Equal->Rule
];


(*
moveOut[term_] and moveIn[term_] are examples of moving term_ outside and inside op[_ term_,_] DOESN'T match NumberQ[_].  *14Mar2014*)
moveOut[term_]:=(op:xProduct|xSum)[a_  b_,i_]:>a op[b,i]/;ListMemberQ[a,Flatten[{term,1/#&/@{term}}]];
moveIn[term_]:=a_ (op:xProduct|xSum)[b_,i_]:>op[a b,i]/;ListMemberQ[a,Flatten[{term,1/#&/@{term}}]];

(*
independentOf[pattern_List][exp_] Removes elements dependent of pattern_List in the FreeQ sense.*3Mar2013*)
independentOf::usage=
"independentOf[pattern_List][exp_] removes elements dependent on pattern_List in the FreeQ sense. *3Mar2013*";
independentOf[pattern_List][exp_]:=Module[{head,tmp,TF},
head=Head[exp];
If[head =!= Symbol,
tmp=Apply[List,exp];
TF=Map[ListFreeQ[#,pattern]&,tmp];
TF=Map[If[!TF[[#]],{#}]&,Range[Length[TF]]];
TF=DeleteCases[TF,Null];
TF=Delete[tmp,TF];
If[Length[TF]>0,Apply[head,TF],If[head ===Plus,0,1]],
(*else*)
If[ListFreeQ[exp,pattern],exp,1]
]
];
(*
dependentOn[pattern_List][exp_] Removes Level 0 terms that are independent (in the FreeQ sense) of elements in pattern_List. *3Mar2013*)
dependentOn::usage=
"dependentOn[pattern_List][exp_] removes elements independent of pattern_List in the FreeQ sense. *3Mar2013*";
dependentOn[pattern_List][exp_]:=Module[{head,tmp,TF},
head=Head[exp];
If[head =!= Symbol,
tmp=Apply[List,exp];
TF=Map[ListFreeQ[#,pattern]&,tmp];
TF=Map[If[TF[[#]],{#}]&,Range[Length[TF]]];
TF=DeleteCases[TF,Null];
TF=Delete[tmp,TF];
If[Length[TF]>0,Apply[head,TF],If[head ===Plus,0,1]],
(*else*)
If[ListFreeQ[exp,pattern],1,exp]
]
];
(**)
tuSumSimplify::usage="tuSumSimplify[independent_List][exp_] move terms within xSum[] of exp_ independent of dependent_List to outside xSum[].  *20Oct2013*";
tuSumSimplify[independent_List:{}][exp_]:=Block[{tmp},
tmp=exp//DistributeSum;
tmp=tmp//.xSum[a_ c___,b__]:>a  xSum[Times[c],b]/;NumericQ[a];
tmp=tmp/.xSum[0,b__]->0;
tmp=tmp/.xSum[a_,b__]:>dependentOn[independent][a]xSum[ independentOf[independent][a],b]
];
simpleSum[independent_List]:=tuSumSimplify[independent];

(*Distribute xSum over ExpandAll[sumand] of Sum[].  Returns xSum[]. 
3.1.2010*)
DistributeSum[exp_]:=Module[{tmp,tmp1=NULL,DEBUG=0},
tmp=exp/.Sum->xSum;
While[tmp=!=tmp1,
If[DEBUG>0,Print["DistributeSum: ",tmp]];
tmp1=tmp;
tmp=tmp/.xSum[a_,c__]:>xSum[ExpandAll[a],c];
tmp=tmp/.xSum[a_,b__]:>Map[xSum[#,b]&,a]/;Head[a]===Plus;
];
tmp
];
(**)
tuDistributeOp::usage="tuDistributeOp[Op_,func_:Plus][exp_] applies Distribute[Op_[],func_] on every Pattern matched by Op_[__]. EG:DistributeOp[IntegralOp[_,_]][IntegralOp[{{x}},a+b]]->IntegralOp[{{x}},a]+IntegralOp[{{x}},b] *29Jan2014*";
tuDistributeOp[Op_,func_:Plus][exp_]:=Module[{tmp=exp,pos,i},
pos=ExtractPositionPattern[tmp,Op];
For[i=1,i<=Length[pos],i++,
pos[[i,2]]=Distribute[pos[[i,2]],func]
];
ReplacePartTU[tmp,pos]
];
DistributeOp[Op_][exp_]:=tuDistributeOp[Op][exp];

(*
ThreadOp[Op_][exp_] applies Thread on pattern Op_[_] in exp_.  Accomodates variation for IntegralOp. Must indicate arguements as Op_[_,_]. *5Sep2014*)
ThreadOp[Op_][exp_]:=Module[{tmp={exp},pos,i,xInt,xOp},
pos=ExtractPositionPattern[tmp,Op];
xOp=Op;
If[Head[Op]===IntegralOp,pos=pos/.IntegralOp[a_,b_]->xInt[a][b];xOp=xInt[_][_]];
For[i=1,i<=Length[pos],i++,
pos[[i,2]]=pos[[i,2]]//.ii:xOp:>Thread[ii];
];
If[Head[Op]===IntegralOp,pos=pos/.xInt[a_][b_]->IntegralOp[a,b]];
ReplacePartTU[tmp,pos]//First
];

(**)
tuArgSimplify::usage="tuArgSimplify[OP_,constants_List][exp_] simplifies arg_ in OP_[arg_] functional expressions in exp_ by first DistributeOp[OP_][exp_] and removing constants_List and NumericQ[] elements in arg_ outside of OP_.  OP_ must be specified as fn[_].\[IndentingNewLine]Usage:  xOp[f+g,c+d e]//simpleOp[xOp[__],{d}] -> \[IndentingNewLine]{xOp[f,c]+d xOp[f,e]+xOp[g,c]+d xOp[g,e]}   *2Jul2014*";
tuArgSimplify[OP_,constants_List:{}][exp_]:=Block[{tmp=exp,headOp=Head[OP],xop,sub,one},
tmp=tmp//.tuOpDistribute[OP];xPrint[tmp,":",headOp];
tmp=tmp/.headOp->xop;
(*Op with multiple arguements*)
sub=xop[b1___,c_^(n_:1)  a_,b___]:>c xop[b1,a,b]/;ListMemberQ[c,constants]||ListMemberQ[c,constants]||NumericQ[c];
tmp=tmp//.sub;
(*Op with multiple arguements but single arguement as constant*)
sub=xop[b1___,c_^(n_:1) ,b___]:>c xop[b1,1,b]/;ListMemberQ[c,constants]||ListMemberQ[c,constants]||NumericQ[c];
tmp=tmp//.sub;
(*Op with single arguement*)
sub=xop[c_^(n_:1)]:>c/;ListMemberQ[c,constants]||ListMemberQ[c,constants]||NumericQ[c];
tmp=tmp//.sub;
tmp=tmp/.xop->headOp;xPrint[tmp];
tmp
];
simpleOp[OP_,constants_List:{}][exp_]:=tuArgSimplify[OP,constants][exp];
tuSimpleOp[OP_,constants_List:{}][exp_]:=tuArgSimplify[OP,constants][exp];
(*Adds columns of tablex_ to the right of table.*)
TableAddColumn[table_][tablex_]:=Module[{head=table[[1]],tmp=table,pattern,row,mname="TableAddColumn",DEBUG=1},
tmp=MapThread[Join,{tmp,tablex}];
tmp
];
(**)tuReplacePart::usage="tuReplacePart[exp_,pos_List] like ReplacePart[] except replaces whole exp_ when pos contains {{}->replacement} in which case ReplacePart does nothing. *5Sep2015*";
tuReplacePart[exp_,pos_List]:=Block[{$},
If[Length[($=tuRuleSelect[pos][{}])]>0,$[[1,2]],
ReplacePart[exp,pos]]
];
ReplacePartTU[exp_,pos_List]:=tuReplacePart[exp,pos];(*Compatibility*)

(**)tuFreeQ::usage="tuFreeQ[exp_,items_] tests exp_ as FreeQ of all items in items_List. *18Jun2015*";
tuFreeQ[exp_,items_]:=Apply[And,Map[FreeQ[exp,#]&,Flatten[{items}]]];
ListFreeQ[exp_,items_List]:=tuFreeQ[exp,items];(*Compatibility*)

(**)tuHasAnyQ::usage="tuHasAnyQ[exp_,items_List] returns True if exp_ has any item in items_List. *18Jul2015*";
tuHasAnyQ[exp_,items_]:=Apply[Or,!FreeQ[exp,#]&/@Flatten[{items}]];
(**)tuHasAllQ::usage="tuHasAllQ[exp_,items_List] returns True if exp_ has all items in items_List. *18Jul2015*";
tuHasAllQ[exp_,items_]:=Apply[And,!FreeQ[exp,#]&/@Flatten[{items}]];
(**)tuHasNoneQ::usage="tuHasNoneQ[exp_,items_List] returns True if exp_ has none of the items in items_List. *18Jul2015*";
tuHasNoneQ[exp_,items_]:=Not[tuHasAnyQ[exp,items]];
(**)tuProductQ::usage="tuProductQ[exp_] returns True if exp_ is a product(Times,xTimes) of simple variables. *8Aug2015*";
tuProductQ[exp_]:=Block[{tmp},
tmp={tuHasNoneQ[exp,{Plus}],tuHasAnyQ[Head[exp],{Times,xTimes}]};
Apply[And,tmp]
];

(**)tuMemberQ::usage="tuMemberQ[variable_,patterns_List] True if variable_ matches any in patterns_List. *16May2015*";
tuMemberQ[variable_,patterns_]:=
Apply[Or,Map[MemberQ[Flatten[{variable}],#]&,Flatten[{patterns}]]];
ListMemberQ[variable_,patterns_List]:=tuMemberQ[variable,patterns];(*Compatibility*)

(*
allMemberQ[variables_,patterns_List] True if all variables_ match any in patterns_List.  *16Aug2013*)
allMemberQ[variables_,patterns_List]:=Module[{tmp},
tmp=Map[ListMemberQ[#,Flatten[patterns]]&,Flatten[{variables}]];
Apply[And,tmp]
];
allMemberQ::usage="allMemberQ[variables_,patterns_List] True if all variables_  match any in patterns_List.";

(*
combineElements[elements_List,to_][exp_List] replaces elements_List items of exp_List and Append[]s to_.  *22Nov2014*)
combineElements[elements_List,to_][exp_List]:=Block[{tmp=exp},
tmp=Select[tmp,!MemberQ[elements,#]&];
tmp=Append[tmp,to]
];
(*
gatherLog[exp_] gathers first level sums of Logs, e.g. a Log[b]+c Log[d]\[Rule]Log[b^ad^b]*)
gatherLog[exp_]:=Module[{tmp=exp,DEBUG=0},
If[DEBUG>0,Print["gatherLog:",tmp]];
tmp=tmp//.a_ Log[b_]->Log[b^a];
tmp=tmp//.Log[a_]+Log[b_]->Log[a b];
tmp
];
(*
gatherSqrt[exp_] Gathers multiplied Sqrt[_]'s *)
gatherSqrt[exp_]:=Module[{tmp=exp},
tmp=tmp//.Sqrt[a_] Sqrt[b_]->Sqrt[a b];
tmp
];
(**)
tuVarGather::usage="tuVarGather[var_,op_:dotOps] Rules[] for gathering var_ at end of op_ terms distributed over Plus expressions. *9Feb2016*";
tuVarGather[var_,op_:dotOps]:={(oo:op)[b_,var]+ (sign_:1)(oo:op)[c_,var]->oo[(b+sign c),var],(oo:op)[var,b_]+ (sign_:1)(oo:op)[var,  c_]->oo[var,(b+sign c)]};

tuSeries::usage="tuSeries[f_,var_List] generates symbolic Series expansion of f_ given var_ parameters of Series[] function *1Nov2015*";tuSeries[f_,var_List]:=Block[{tmp,dif},
tmp=f/.var[[1]]->var[[2]];
dif=tuDPartial[tmp,var[[1]]];
Do[tmp=tmp+(dif/.var[[1]]->var[[2]])(var[[1]]-var[[2]])^(i)/i!;
dif=tuDPartial[dif,var[[1]]],
{i,1,var[[3]]}
];
tmp
];

(*
xSeries[f_,var_List] produces a symbolic Series expansion of f_.  var_List is the variable arguement as in Series.
EG: xSeries[f[x],{x,1,2}] -> xLimit[f[x]+(-1+x) Subscript[Underscript["\[PartialD]", _], x][f[x]]+1/2 (-1+x)^2 Subscript[Underscript["\[PartialD]", _], x][Subscript[Underscript["\[PartialD]", _], x][f[x]]],x\[Rule]1]
*28Jul2014*)
xSeries[f_,var_List]:=Module[{tmp,dif},
tmp=f;
dif=xPartialD[tmp,var[[1]]];
Do[tmp=tmp+dif (var[[1]]-var[[2]])^(i)/i!;
dif=xPartialD[dif,var[[1]]],{i,1,var[[3]]}
];
xLimit[tmp,var[[1]]->var[[2]]]
];
(*
Generates a Series to order_ in pattern_ from exp_. NOT USED?*)
SeriesByPattern[exp_,pattern_,order_]:=Module[{pos,tmp,xpos,XXXX,DEBUG=0,mname="SeriesPattern"},
pos=ExtractPositionPattern[exp,pattern];
IfDEBUG[mname,DEBUG>0,{exp,pattern,pos},"{exp,pattern,pos}"];
xpos=pos/.pattern->XXXX;
tmp=ReplacePart[exp,xpos];
IfDEBUG[mname,DEBUG>0,{xpos,tmp},"{xpos,tmp}"];
tmp[[2]]=Series[tmp[[2]],{XXXX,0,order}]//Normal;
IfDEBUG[mname,DEBUG>0,{tmp},"{tmp}"];
tmp=tmp/.XXXX->pos[[1,2]];
tmp
];
(*
tuSeriesApproximation[exp_,varOrder_List,pattern_List] generates a Rule that is a Series[] approximation to exp_.  varOrder_List is the same as Series[] variable arguement and pattern_List specifies labels to turn into Patterns on the LHS. *19Dec2014*)
tuSeriesApproximation[exp_,varOrder_List,pattern_List]:=exp->Series[exp,varOrder]//Normal//RulesVarPattern[pattern]

(**)
Clear[tuRepeat]
tuRepeat::usage="tuRepeat[rules_List:{},operations_:{}][exp_] applies rules_List and operations_ (may be List) repeatedly until exp_ does not change. *22Feb2016*" 
tuRepeat[rules_List:{},operations_:{}][exp_]:= Block [{$IterationLimit=20,xrule,xop,tmp=exp,tmp0,icnt=0},
xrule=Flatten[{rules}];
xop=Flatten[{operations}];
xPrint[xrule,xop,$IterationLimit];
While[tmp0=!=tmp,tmp0=tmp;xPrint[icnt,tmp];icnt++;
If[xop=!={},tmp=Fold[#2 [#1]&,tmp,xop] ];
If[xrule=!={},tmp=Fold[ReplaceRepeated[#1,#2,MaxIterations->100]&,tmp,xrule]];(*Position of this statement affects result.*)
xPrint[operation=!=Null];
If[icnt>$IterationLimit,Return[tmp]];xPrint[$IterationLimit];
];
tmp
];
(*
*)
Clear[tuAppendUniq];
tuAppendUniq::usage="tuAppendUniq[item_][list_] combines item_ and list_, Flatten, and DeleteDuplicates";
tuAppendUniq[item_][list_]:=Block[{$},
$=Append[{list},{item}]//Flatten//DeleteDuplicates
];
(**)
Clear[tuProductExpand]
tuProductExpand::usage="tuProductExpand[op_:Times][exp_] expands Product|xProduct operations in exp_ with op_ as product operator. This routine needs Numerical range of productOp[_,{i,9}]. *30Oct2015*";
tuProductExpand[op_:Times][exp_]:=Block[{$=exp,productOp=Product|xProduct},
$=$/.(pp:productOp)[a_,b__]:>op@@Table[a,b]
];
(**)
tuTermSelect::usage="tuTermSelect[patterns_][exp_] extracts terms which match all patterns_(List) in a Plus expression *7Mar2016*";
tuTermSelect[patterns_][exp_]:=Block[{$,$s},
$=Inactivate[Expand[exp],Plus];
$=$//tuExtractPattern[Inactive[Plus][__]]//First//(#/.Inactive[Plus]->List&);
$=Select[$,tuHasAllQ[#,Flatten[{patterns}]]&];
$
];
