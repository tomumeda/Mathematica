(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(*External packages*)
Needs["Combinatorica`"]
Needs["TensorCalculus4V6`Tensorial`"]
<<Local`LocalFunctions`
DotFunctions
IntegralFunctions
IntegrateSumFunctions

(*Area for specific assignments of variables for all problems.*)
Indices4D={0,1,2,3};
DeclareIndexFlavor[{field,Green}]
DeclareIndexFlavor[{space,Red}]
DefineTensorShortcuts[
{{\[CurlyPhi],\[Psi],m,k},0},{{x,y,dx,\[Xi],b,c,r,zero,\[CurlyPhi],\[Psi],\[Psi]c,J,K,P,a,k,e,p,q,dp,dq,j,A,B,\[Gamma]},1},{{x,k,g,\[Delta] ,\[Sigma],zero,\[Omega],\[Omega]1,\[Omega]2,\[Omega]s,\[Omega]a,\[Eta],\[CapitalLambda],A,B,M,\[Delta]\[Omega],\[Delta]\[Alpha],q,p,R,T,\[Theta],S,F},2},{{\[CapitalGamma],\[Epsilon]},3}
]
labels = {x,\[Delta],g, \[CapitalGamma]};

(*Notation in QFT has too many requirements and often needs to be problem specific.
*)
(*GammaSlash display definition.  May want to redefine it as g[a_]:=GammaSlash[a].  Perhaps the Bold is enough.
*)
MakeBoxes[GammaSlash[a_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@
    {ToBoxes[Overscript[Style[a,Bold],"/"]], GammaSlash[a]}

(*IntegralOp display definition.
*)
MakeBoxes[IntegralOp[v_,a_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Subscript["\[Integral]",Column[v]][a]], IntegralOp[v,a]}

(*Transpose display definition.
*)
MakeBoxes[Transpose[a_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Superscript[a,T]], Transpose[a]}

(*Transpose display definition.
*)
MakeBoxes[ConjugateTranspose[a_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Superscript[a,\[Dagger]]], ConjugateTranspose[a]}

(*xPartialD display definition.
*)
MakeBoxes[xPartialD[a_,b_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Subscript[
\!\(\*UnderscriptBox["\"\<\[PartialD]\>\"", "_"]\),b][a]], xPartialD[a,b]}

(*xDiscreteDelta display definition.
*)
MakeBoxes[xDiscreteDelta[a_,b_],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[
\!\(\*UnderscriptBox["\"\<\[Delta]\>\"", "_"]\)[a,b]], xDiscreteDelta[a,b]}

(*xSum display definition.
*)
MakeBoxes[xSum[a_,b__],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Underscript[
\!\(\*UnderscriptBox[
RowBox[{" ", "\"\<\[Sum]\>\""}], "_"]\),Column[{b}]][a]], xSum[a,b]}

(*xProduct display definition.
*)
MakeBoxes[xProduct[a_,b__],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,
SyntaxForm->Automatic,
Editable->False]& @@{ToBoxes[Underscript[
\!\(\*UnderscriptBox[
RowBox[{" ", "\"\<\[Product]\>\""}], "_"]\),Column[{b}]][a]], xProduct[a,b]}

(* Commutation and Anti-commutation definitions.*)
MCommutator::usage = "MCommutator[A,B] calculates the commutator of matrices A and B";
MCommutator[A_,B_]:=A.B-B.A;

ACommutator::usage = "ACommutator[A,B] calculates the commutator of matrices A and B";
ACommutator[A_,B_]:=A.B+B.A;



"PR[] annotations:"
Imply="\n\[DoubleRightArrow] ";
imply=" \[DoubleRightArrow] ";
Yield="\n\[RightArrow] ";
yield=" \[LongRightArrow] ";
back=" \[LongLeftArrow]";
and=" and ";
check=CR["\[LongLeftArrow]CHECK"];
New="\n\[FilledCircle] ";


psa16=ACommutator[\[Gamma]u[\[Mu]],\[Gamma]u[\[Nu]]]->2 guu[\[Mu],\[Nu]]
psa16a=Map[#-psa16[[1,1]]&,psa16]

ps368=\[Gamma]u[5]->I \[Gamma]u[0].\[Gamma]u[1].\[Gamma]u[2].\[Gamma]u[3]

ps370=\[Gamma]u[5].\[Gamma]u[5]->1
ps371=ACommutator[\[Gamma]u[\[Mu]],\[Gamma]u[5]]->0
ps55a=Tr[Id]->4
ps55c=Tr[\[Gamma]u[\[Mu]].\[Gamma]u[\[Nu]]]->4 guu[\[Mu],\[Nu]]
ps55e=Tr[\[Gamma]u[5]]->0;

g[a_]:=GammaSlash[a];
subTraceGamma={Tr[g[a_].g[b_]]->4 a.b,
Tr[g[a_].g[b_].g[c_].g[d_]]->4 (a.b c.d-a.c b.d+a.d b.c),
Tr[g[a_]]->0,
Tr[g[a_].g[b_].g[c_]]->0,
Tr[a_ b__]:>a Tr[b]/;Head[a]=!=GammaSlash,
Tr[0]->0
};



"e[] == unit vector.";
DotExpand=Dot[a___,d___ Dot[b__],c__]:>d Dot[a,b,c];(**)

(* Newer version. 2010.2.16 *)
DotKeep1[clist_,seq_]:=
(*Keeps under Dot items in clist. Usage  expression/.Dot[a___]:>dotKeep[{ keep_list }]  [a].  Returns  nokeep_list Dot[ keep_list ]*)
Module[{tmp=seq,i,j,member,dot={},times={1},test,DEBUG=0},
tmp=tmp/.Times->Dot/.simpleDot;
If[DEBUG>0,Print["DotKeep< ",clist," : ",tmp," ",Length[tmp]]];
For[i=1,i<=Length[tmp],i++,
test=tmp[[i]];
If[DEBUG>1,Print["DotKeep: ",test," : ",clist]];
member=False;
If[MemberQ[clist,test],member=True];
For[j=1,j<=Length[clist],j++,
If[! FreeQ[test,clist[[j]]],member=True]
];
If[ member,
AppendTo[ dot,test],
AppendTo[ times,test]
];
If[DEBUG>1,Print["DotKeep: ",dot,times]];
];
tmp=1;
If[Length[times]>0,
tmp=Apply[Times,times]];
If[Length[dot]>0,
tmp=tmp Apply[Dot,dot]];
If[DEBUG>0,Print["DotKeep>> ",tmp]];
tmp
];

GammaRight[exp_,gamma_]:=(* Moves gamma_ in Dot[] expression to the right until the end or the term disappears.  Usage: expression/.Dot[a__]:> GammaRight[a].  Returns replacement for Dot[]. *)
Module[{ tmp=exp,tmp1,out,gpos,Ngpos,igpos,indu=Null,indd=Null,pair,DEBUG=0},
If[DEBUG>0,Print["GammaRight: ",tmp," : ",gamma]];
While[tmp1=!=tmp,
tmp1=tmp;
indu=gamma/.\[Gamma]u[a_]->a;
indd=gamma/.\[Gamma]d[a_]->a;
tmp=tmp/.Dot[a___,gamma,b_,c___]:>Dot[a,CommuteG[gamma,b],c]/;(MemberQ[{b},\[Gamma]u[_]||MemberQ[{b},\[Gamma]d[_]]]);
tmp=Expand[tmp]/.simpleDot//Expand;

If[DEBUG>0,Print["GammaRight>  ",tmp]];
tmp=tmp/.Dot->xDot;
tmp=tmp//.xDot[a__]:>DotKeep1[{\[Gamma]d[_],\[Gamma]u[_]},{a}];
tmp=Expand[tmp]/.simpleDot;
tmp=tmp//.{Dot[a___,\[Gamma]d[b_],\[Gamma]u[b_],c___]:>dim[x]Dot[a,c],Dot[a___,\[Gamma]u[b_],\[Gamma]d[b_],c___]:>dim[x] Dot[a,c]};

If[DEBUG>0,Print["GammaRight>> ",tmp]];
];
tmp
];

GammaLeft[exp_,gamma_]:=(* Moves gamma_ in Dot[] expression to the left until the end or the term disappears.  Usage: expression/.Dot[a__]:> GammaLeft[a].  Returns replacement for Dot[]. *)
Module[{ tmp=exp,tmp1,out,gpos,Ngpos,igpos,indu=Null,indd=Null,pair,DEBUG=0},
If[DEBUG>0,Print["GammaLeft: ",tmp," : ",gamma]];
While[tmp1=!=tmp,
tmp1=tmp;
indu=gamma/.\[Gamma]u[a_]->a;
indd=gamma/.\[Gamma]d[a_]->a;
tmp=tmp/.Dot[a___,b_,gamma,c___]:>Dot[a,CommuteG[b,gamma],c]/;(MemberQ[{b},\[Gamma]u[_]||MemberQ[{b},\[Gamma]d[_]]]);
tmp=Expand[tmp]/.simpleDot//Expand;

If[DEBUG>0,Print["GammaLeft>  ",tmp]];
tmp=tmp/.Dot->xDot;
tmp=tmp//.xDot[a__]:>DotKeep1[{\[Gamma]d[_],\[Gamma]u[_]},{a}];
tmp=Expand[tmp]/.simpleDot;
tmp=tmp//.{Dot[a___,\[Gamma]d[b_],\[Gamma]u[b_],c___]:>dim[x]Dot[a,c],Dot[a___,\[Gamma]u[b_],\[Gamma]d[b_],c___]:>dim[x] Dot[a,c]};

If[DEBUG>0,Print["GammaLeft>> ",tmp]];
];
tmp
];

CommuteG[g1_,g2_]:=(* Commute \[Gamma] matrices. \[Gamma]*)
Module[{tmp,ind1u=Null,ind1d=Null,ind2u=Null,ind2d=Null,gtmp=1,out,DEBUG=0},
If[DEBUG>0,Print["CommuteG: ",g1," : ",g2]];
If[(FreeQ[{g1},\[Gamma]d[_] ]&&FreeQ[{g1},\[Gamma]u[_] ])||(FreeQ[{g2},\[Gamma]d[_] ]&&FreeQ[{g2},\[Gamma]u[_] ]),
g1.g2,
ind1u=g1/.\[Gamma]u[a_]->a;If[g1===ind1u,ind1u=Null];
ind1d=g1/.\[Gamma]d[a_]->a;If[g1===ind1d,ind1d=Null];
ind2u=g2/.\[Gamma]u[a_]->a;If[g2===ind2u,ind2u=Null];
ind2d=g2/.\[Gamma]d[a_]->a;If[g2===ind2d,ind2d=Null];
If[ind1u=!=Null&&ind2u=!=Null,gtmp=guu[ind1u,ind2u]];
If[ind1d=!=Null&&ind2d=!=Null,gtmp=gdd[ind1d,ind2d]];
If[ind1u=!=Null&&ind2d=!=Null,gtmp=gud[ind1u,ind2d]];
If[ind1d=!=Null&&ind2u=!=Null,gtmp=gdu[ind1d,ind2u]];
out=-g2.g1+2gtmp;
If[DEBUG>0,Print["CommuteG: ",ind1u," ",ind1d," ",ind2u," ",ind2d,">>",out]];
out
]
];


(*Returns Rule[First[mn_]->_] for exp_==0 for pair mn_. e.g., ZeroNM[I 2 \[Pi] m t/\[Beta],{m,n}]*)
ZeroMN[exp_,mn_]:=Module[{tmp},
tmp=Solve[exp==0,First[mn]];
If[Length[First[tmp]]>0,
tmp=First[First[tmp]],
tmp=Solve[exp==0,Last[mn]];
If[Length[First[tmp]]>0,
tmp=First[First[tmp]],
tmp=exp;
];
];
tmp
];
(* Returns xDiscreteDelta[First[mn_,_] for exp_== 0 for pair mn_. e.g., ZeroNM[I 2 \[Pi] (m-n) t/\[Beta],{m,n}]->xDiscreteDelta[First[m,n]  *)
ZeroMNDiscreteDelta[exp_,mn_]:=Module[{tmp,DEBUG=0},
tmp=ZeroMN[exp,mn];
If[DEBUG>0,Print["ZeroMNDiscreteDelta: ",{exp,mn,tmp,Head[tmp]}]];
If[Head[tmp]===Rule,
tmp=tmp/.Rule->xDiscreteDelta,
tmp=exp
];
tmp
];

(*Returns \[Delta]uu[First[mn_,_], DiscreteDelta[] for exp_== 0 for pair mn_. e.g., ZeroNM[I 2 \[Pi] (m-n) t/\[Beta],{m,n}] *)
ZeroMN\[Delta][exp_,mn_]:=Module[{tmp,DEBUG=0},
tmp=ZeroMN[exp,mn];
If[DEBUG>0,Print["ZeroMNDiscreteDelta: ",{exp,mn,tmp,Head[tmp]}]];
If[Head[tmp]===Rule,
tmp=tmp/.Rule->\[Delta]uu,
tmp=exp
];
tmp
];
(*Consolidation Rule[]'s for Sum|xSum *)
GatherSumSubs={Sum->xSum,
xSum[xSum[a_,b__],c__]:>xSum[a,b,c],
d_ xSum[a_,b_]:>xSum[Expand[d a],b],
xSum[a_,b_]+xSum[c_,b_]->xSum[a+c,b]
};
(*Consolidation Rule[]'s for IntegralOp *)
GatherIntOpSubs={IntegralOp[a_List,IntegralOp[b_List,c_]]:>IntegralOp[{a, b},c],d_ IntegralOp[a_,b_]:>IntegralOp[a,Expand[d b]],
IntegralOp[a_,b_]+IntegralOp[a_,c_]->IntegralOp[a,c+b]
};
(*Changes PartialD[Sum[a,b],c]->Sum[a,PartialD[b,c]]*)
(* 2.28.2010*)
ExchangexPartialDSum[exp_]:=Module[{tmp=exp,tmp1,DEBUG=0},
If[DEBUG>0,Print["ExchangePartialDSum: ",tmp]];
(*Partiald does not substitute, change to xPartialD *)
tmp=tmp/.distributePartialD;
tmp=tmp//.xPartialD[Sum[a_,c__],b_]:>Sum[xPartialD[a,b],c];
tmp=tmp/.xPartialD[xSum[a_,c__],b_]:>xSum[xPartialD[a,b],c];
tmp
];

(*Distribute xSum over ExpandAll[sumand] of Sum[].  Returns xSum[]. 
3.1.2010*)
DistributeSum[exp_]:=Module[{tmp,tmp1=NULL,DEBUG=0},
tmp=exp/.Sum->xSum;
While[tmp=!=tmp1,
If[DEBUG>0,Print["DistributeSum: ",tmp]];
tmp1=tmp;
tmp=tmp/.xSum[a_,c__]:>xSum[ExpandAll[a],c];
tmp=tmp/.xSum[a_,b__]:>Map[xSum[#,b]&,a]/;Head[a]===Plus;
];
tmp
];

(*Contracts xDiscreteDelta[n_,m_] in xSum.  Eliminates on xSum[]. 
3.1.2010*)
SumDiscreteDelta[exp_]:=Module[{tmp,tmp1=Null,pos,arg,index,sumvar,xsum,xdelta,posd,n,m,repl={},sub,i,DEBUG=0},
tmp=exp//DistributeSum;
While[tmp=!=tmp1,
If[DEBUG>0,Print["SumDiscreteDelta: ",tmp]];
tmp1=tmp;
pos=Position[tmp,xSum[__]];
For[i=1,i<=Length[pos],i++,
xsum=Extract[tmp,pos[[i]]];
{arg,index}=Apply[List,xsum];
If[Head[index]===List,
sumvar=First[index],sumvar=index];

If[DEBUG>0,Print["SumDiscreteDelta{arg,index}: ",{arg,index}]];

xdelta=Extract[arg,posd=Position[arg,xDiscreteDelta[__]]]//First;
sub=Null;
If[!FreeQ[xdelta,sumvar],
If[Length[xdelta]==2,
sub=Solve[Apply[Equal,xdelta],sumvar][[1]];
];
If[Length[xdelta]==1,
sub=Solve[First[xdelta]==0,sumvar][[1]];
];
];

If[DEBUG>0,Print["SumDiscreteDelta{Length[xdelta],xdelta,sub}: ",{Length[xdelta],xdelta,sub}]];
If[DEBUG>0,Print["SumDiscreteDelta{sub,arg}: ",{sub,arg}]];

If[sub=!=Null,arg=arg/.sub/.xDiscreteDelta[__]->1;AppendTo[repl,pos[[i]]->arg]];

If[DEBUG>0,Print["SumDiscreteDelta{index,sub,repl}: ",{index,sub,repl}]];

];
];
tmp=ReplacePart[tmp,repl]
];

(*Applies Integrate[] to one IntegralOp[ integration_parameter ]*)
IntegrateOne[parm_,exp_]:=Module[{tmp=exp,DEBUG=0},
tmp=tmp/.IntegralOp->IntegralOp;
If[DEBUG>0,Print["IntegrateOne{parm,tmp}: ",{parm,tmp}]];

If[DEBUG>0,Print["IntegrateOne{DeleteCases[a,parm]}: ",{DeleteCases[a,parm]}]];

tmp=tmp/.IntegralOp[a_,b_]:>IntegralOp[DeleteCases[a,parm],Integrate[b,parm]]/;MemberQ[a,parm];
tmp
];

(*Generate the complement t1_ t2_ expression relative to total differential.  t1_ is the xPartialD[_,x] term which has variable used for differentiating. The total differential term is specified by DD[_,x].*)
TotalDiffByParts[t1_,t2_]:=Module[{tmp,var,f1,DEBUG=0},
{f1,var}=Apply[List,t1];
If[DEBUG>0,Print["TotalDiffByParts: ",{f1,var}]];
tmp=DD[f1 t2,var]-f1 xPartialD[t2,var];
tmp
];




