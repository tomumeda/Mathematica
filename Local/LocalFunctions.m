(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Plain:: *)
SetDirectory[$UserBaseDirectory~~"/Applications/Definition"];
IntegrateSumFunctions:=Module[{},
SumIntsFront[exp_]:=Module[{a,b,c,d,tmp,tmp1=Null},
tmp=HoldPattern[exp];
tmp=tmp/.Integrate->xIntegrate;
tmp=tmp/.Sum->xSum;
List[tmp];
While[tmp =!= tmp1, 
tmp1=tmp;
List[tmp];
tmp=tmp/.a_ (xSum[b__,c__List]+d_)->xSum[a b,c]+a d;
tmp=tmp/.a_ xSum[b__,c__List]->xSum[a b,c];
tmp=tmp/.a_ xIntegrate[b__,c:_List..]->xIntegrate[a b,c];
tmp=tmp/.a_ xIntegrate[b__,c__]->xIntegrate[a b,c];(*for indefinites*)
tmp=tmp/.xIntegrate[xSum[a__,b__List],c:_List..]->xSum[xIntegrate[a,c],b];
tmp=tmp/.xIntegrate[xSum[a__,b__List],c__]->xSum[xIntegrate[a,c],b];(*for indefinite integral*)
];
tmp=tmp/.xSum:>Sum/.xIntegrate:>Integrate;
tmp
];

IntSumsFront[exp_]:=Module[{a,b,c,tmp,tmp1=Null},
tmp=HoldPattern[exp];
tmp=tmp/.Integrate->xIntegrate;
tmp=tmp/.Sum->xSum;
List[tmp];
While[tmp =!= tmp1, 
tmp1=tmp;
List[tmp];
tmp=tmp/.a_ xSum[b__,c__List]->xSum[a b,c];
tmp=tmp/.a_ xIntegrate[b__,c:_List..]->xIntegrate[a b,c];
tmp=tmp/.a_ xIntegrate[b__,c__]->xIntegrate[a b,c];(*for indefinites*)
tmp=tmp/.xSum[xIntegrate[a__,c:_List..],b__List]->xIntegrate[xSum[a,b],c];
tmp=tmp/.xSum[xIntegrate[a__,c__],b__List]->xIntegrate[xSum[a,b],c];(*for indefinites*)
];
tmp=tmp/.xSum:>Sum/.xIntegrate:>Integrate;
tmp
];

ConjIntegralSum[exp_]:=Module[{a,b,c,tmp,tmp1=Null},
tmp=exp/.Integrate->xIntegrate/.Sum->xSum;
List[tmp];
While[tmp =!= tmp1, 
tmp1=tmp;
List[tmp];
tmp=DistConjugate[tmp];
tmp=tmp/.Conjugate[xIntegrate[a__,{c__}]]:>xIntegrate[DistConjugate[Conjugate[a]],{c}];
tmp=tmp/.Conjugate[xIntegrate[a__,c__]]:>xIntegrate[DistConjugate[Conjugate[a]],c];(*for indefinite*)
tmp=tmp/.Conjugate[xSum[a__,c:_List..]]:>xSum[DistConjugate[Conjugate[a]],c];
];
tmp=tmp/.xIntegrate->Integrate/.xSum->Sum;
tmp
];

(*Distribute xSum over arguement of sum .*)
DistSum[exp_]:=Module[{tmp,tmp1},
tmp=exp/.Sum->xSum/.Integrate->xIntegrate;(*bad interaction with Integrate[].*)
tmp=tmp/.xSum[a_==b_,c__]->xSum[a,c]==xSum[b,c];
tmp=tmp//.{xSum[a_+b_,c__]->xSum[a,c]+xSum[b,c],
xSum[a_,c__]:>xSum[Expand[a],c]};
tmp=tmp/.xIntegrate->Integrate/.xSum->Sum;
tmp
];

(*Distribute Integral over summed terms of integrand.*)
DistIntegral[exp_]:=Module[{tmp,tmp1},
xIntegrate/:xIntegrate[a_+b_,c:_List..]:=xIntegrate[a,c]+xIntegrate[b,c];
xIntegrate/:xIntegrate[a_==b_,c:_List..]:=xIntegrate[a,c]==xIntegrate[b,c];
tmp=exp/.Sum->xSum;
tmp=tmp/.Integrate->xIntegrate;
tmp=tmp/.xIntegrate->Integrate/.xSum->Sum;
tmp
];

DistConjugate[exp_]:=Module[{tmp,tmp1=Null},
Unprotect[Conjugate];
Conjugate/:Conjugate[a_+b_]:=Conjugate[a]+Conjugate[b];
Conjugate/:Conjugate[a_ b_]:=Conjugate[a] Conjugate[b];
Conjugate/:Conjugate[Power[a_,b_]]:=Power[Conjugate[a],Conjugate[b]];
Conjugate/:Conjugate[a_==b_]:=Conjugate[a]==Conjugate[b];
Conjugate/:Conjugate[a_->b_]:=Conjugate[a]->Conjugate[b];
Conjugate/:Conjugate[Sum[a_,b__]]:=Sum[Conjugate[a],b];
Conjugate/:Conjugate[Integrate[a_,b__List]]:=Integrate[Conjugate[a],b];
Conjugate/:Conjugate[IntegrateND[a_,c_,d_]]:=IntegrateND[a,c,Conjugate[d]];
Conjugate/:Conjugate[IntegralOp[a_,d_]]:=IntegralOp[a,Conjugate[d]];
Conjugate/:Conjugate[xPartialD[a_,d_]]:=xPartialD[Conjugate[a],Conjugate[d]];
Conjugate/:Conjugate[xSum[a_,d__]]:=xSum[Conjugate[a],d];
Conjugate/:Conjugate[Dot[a_,b_]]:=Dot[Conjugate[a] , Conjugate[b]];
Protect[Conjugate];
tmp=exp;
Unprotect[Conjugate];
Conjugate/:Conjugate[a_ b_]=.;
Conjugate/:Conjugate[a_+b_]=.;
Conjugate/:Conjugate[Power[a_,b_]]=.;
Conjugate/:Conjugate[a_==b_]=.;
Conjugate/:Conjugate[a_->b_]=.;
Conjugate/:Conjugate[Sum[a_,b__]]=.;
Conjugate/:Conjugate[Integrate[a_,b__List]]=.;
Conjugate/:Conjugate[IntegrateND[a_,c_,d_]]=.;
Conjugate/:Conjugate[IntegralOp[a_,d_]]=.;
Conjugate/:Conjugate[xPartialD[a_,d_]]=.;
Conjugate/:Conjugate[xSum[a_,d__]]=.;
Conjugate/:Conjugate[Dot[a_,b_]]=.;
Protect[Conjugate];
tmp
];

(*Eliminates KroneckerDelta's under Sum--simple cases *)
SumK[exp_]:=Module[{tmp,tmp0,sumList,sumList0,sumIndices,sumArg,i,kronIndices,kronPos},
List[tmp=exp,"
",
sumList=tmp/.List[a_,c:_List..]:>List[c],"
",
sumArg=tmp/.List[a_,c:_List..]:>a,"
",
sumIndices=sumList[[All,1]],"
==>",kronPos=Position[sumArg,KroneckerDelta[a_,b_]],"
=>",kronIndices=Level[Extract[ sumArg,kronPos ],{2}],"
",
(*If[Length[kronIndices]>0,*)
sumArg=sumArg//.a___ KroneckerDelta[n_,m_] b___:>(a b/.m:>n)
/;MemberQ[sumIndices,m];
For[i=1,i<=Count[sumIndices,_],i++,
If[MemberQ[kronIndices,sumIndices[[i]]],
sumList=Delete[sumList,Position[sumList,List[sumIndices[[i]],_,_]]]
]
];
(*]*)
,"
",
List["sumList:  ",sumList[[0]],"+",t[ReplacePart[sumList,0->Sequence]]//FullForm,
sumList0=ReplacePart[sumList,0->Sequence]];
If[Length[sumList]>0,
tmp=xSum[sumArg,sumList0],
tmp=sumArg
]
];
tmp
];

(*Until we get the Position function resolved multiple calls to this function  may be necessary.*)
SumKronecker[exp_]:=Module[{tmp,sumList,sumIndices,sumterm},
tmp=exp//DistSum;
tmp=tmp/.Sum->xSum/.Integrate->xIntegrate;
List[tmp//FullForm,"
",
tmp=tmp/.xSum[a___]:>SumK[List[a]],"
",
tmp=tmp/.xSum->Sum/.xIntegrate->Integrate
];
tmp
];

(*Gathers nested Sum[]'s into one Sum[] expression.*)
GatherSum[exp_]:=Module[{tmp=exp,tmp1},
tmp=tmp/.Sum->xSum;
tmp=tmp//.xSum[xSum[a_,na_],nb_]:>xSum[a,Apply[Sequence,Sort[{nb,na}]]];
tmp1=tmp/.xSum->Sum;
tmp1
];

(*Gathers nested Sum[] and xSum[]'s into one xSum[] expression.*)
GatherxSum[exp_]:=Module[{tmp=exp,tmp1},
tmp=tmp/.Sum->xSum;
tmp=tmp//.xSum[xSum[a_,na_],nb_]:>xSum[a,Apply[Sequence,Sort[{nb,na}]]];
tmp
];

(*Eliminates KroneckerDelta[] under Sum[] in general expression.*)
SumKroneckerElim[exp_]:=Module[{tmp,tmp0,sumList,sumList0,sumPos,sumIndices,sumArg,lastsumArg,xsum,xsums,i,is,ik,kronargs,kronPos,kronarg,ind,repl,replList={},DEBUG=0},
xsums=GatherSum[DistSum[exp]]/.Sum->xSum;
sumPos=Position[xsums,xSum[__]];
If[DEBUG>0,Print[xsums,"<<",sumPos]];
For[is=1,is<=Length[sumPos],is++,
tmp=xsum=Extract[xsums,sumPos[[is]]];
If[DEBUG>0,Print["<<",sumPos[[is]],"<<",xsum]];

sumArg=First[tmp];
lastsumArg=NULL;
sumList=Apply[List,Rest[tmp]];
sumList=Rest[tmp];

If[DEBUG>0,Print["<<",sumList,"<<",sumArg]];
While[sumArg=!=lastsumArg,
lastsumArg=sumArg;
kronPos=Position[sumArg,KroneckerDelta[__]];
For[ik=1,ik<=Length[kronPos]&&lastsumArg===sumArg,ik++,
kronargs=Extract[ sumArg,kronPos[[ik,1]] ];
(*Change standard 2 arguement KroneckerDelta.  This routine will not work for more than 2 arguements.*)
If[Length[kronargs]>1,kronarg=kronargs[[1]]-kronargs[[2]],
kronarg=kronargs[[1]]];
If[DEBUG>0,Print["KARG<<",ik,":",kronargs,"<<",Length[kronargs]]];S
For[i=1,i<=Length[sumList]&&lastsumArg===sumArg,i++,
ind=sumList[[i]];
If[Head[ind]===List,ind=First[ind]];
If[!FreeQ[kronarg,ind],
repl=Solve[kronarg==0,ind][[1]];
sumArg=sumArg/.repl;
sumList=Drop[sumList,{i}];
If[DEBUG>0,Print["REPL<<",ind,":",repl,":>",sumArg,"<<",sumList]];
];
];
];
];
xsum=Prepend[sumList,sumArg];
AppendTo[replList,sumPos[[is]]->xsum];
If[DEBUG>0,Print["repList:",replList]];
];
ReplacePart[xsums,replList]/.xSum->Sum
];


(*There is something unusual about the Integrate function. I cannot get a handle on the variables. Apparently there are restriction on the arguements of Integrate such that it does not work with Rules in the substitution of integration variable and limits.
*)

IntegrateNoLimitEval[integrand_,limits__List]:=Module[{tmp,x,NoLimitVars},
List["IntegrateNoLimitEval ",integrand," == ",limits];
SetAttributes[Integrate,HoldAllComplete];
integrandx=integrand/.Integrate->xIntegrate(*Only top level integral --no other Integrate subs*);
NoLimitVars=Map[First[#]&,{limits}];
tmp=Apply[Integrate,FlattenAt[List[integrandx,NoLimitVars],-1]];
tmp=tmp/.Integrate[a_,c___]:>Integrate[a,limits];
ClearAttributes[Integrate,HoldAllComplete];
tmp
];

(* The following Module is incomplete.  It needs to simplify integrands. *)
SimplifyIntegral[exp_]:=Module[{a,b,c,limits,tmp,tmp1=Null,dummy},
tmp=HoldPattern[exp];
While[tmp =!= tmp1, 
tmp1=tmp;
List["SimplifyIntegral:",tmp];
tmp=tmp/.Integrate[a_,c:_List..]:>IntegrateNoLimitEval[a//Simplify,c];
];
tmp//ReleaseHold
];

(*rule substitution for integrand, dfactor is factor for the dvariable *)
SubIntegral[exp_,rule_,dfactor_]:=Module[{a,b,c,limits,tmp,tmp1=Null},
tmp=HoldPattern[exp];
While[tmp =!= tmp1, 
tmp1=tmp;
List[tmp];
tmp=tmp/.Integrate[a_,c:_List..]:>IntegrateNoLimitEval[(a/.rule)dfactor,c];
];
tmp//ReleaseHold
];

(*Move Sum to front of expression with IntegralOp*)
SumIntOpFront[exp_]:=Module[{a,b,c,d,tmp,tmp1=Null,DEBUG=0},
tmp=exp//.distributeIntegralOp;
tmp=tmp//.Sum->xSum;(*Odd behavior with Sum in substitution*)
If[DEBUG>0,Print[tmp]];
While[tmp =!= tmp1, 
tmp1=tmp;
If[DEBUG>0,Print[tmp]];
tmp=tmp/.a_ (xSum[b_,c__]+d_)->xSum[a b,c]+a d;
tmp=tmp/.a_ xSum[b_,c__]->xSum[a b,c];
tmp=tmp/.xSum[a_,b_].xSum[c_,d_]->xSum[a.c,b,d];
tmp=tmp/.a_ IntegralOp[b_List,c__]->IntegralOp[b,a c];
(*for indefinites*)
tmp=tmp/.IntegralOp[c_List,xSum[a_,b__]]->xSum[IntegralOp[c,a],b];
];
tmp=tmp/.xSum:>Sum;
tmp
];
(*Moves IntegralOp to front NOT FINISHED*)
IntOpSumFront[exp_]:=Module[{a,b,c,tmp,tmp1=Null,DEBUG=0},
tmp=exp//.distributeIntegralOp;
tmp=tmp//.Sum->xSum;
If[DEBUG>0,
Print["IntOpSumFront: ",tmp]];
While[tmp =!= tmp1, 
tmp1=tmp;
If[DEBUG>0,
Print["IntOpSumFront: ",tmp]];
tmp=tmp/.a_ xSum[b_,c__]->xSum[a b,c];
tmp=tmp/.a_ IntegralOp[b_,c_]->IntegralOp[b,a c];
tmp=tmp/.xSum[IntegralOp[c_,a_],b__]->IntegralOp[c,xSum[a,b]];
];
tmp=tmp/.xSum:>Sum;
tmp
];

(*Moves non-indexed variables out from under xSum  *)
SumMoveNVarOut[term_,indices__]:=Module[{tmp=xSum[term,indices],indice={indices},i,vlist={},ivar,ilist,ilistFree={},ilistYes={},pattern,out,in,DEBUG=0},
If[DEBUG>0,Print["SumMoveNVarOut:",{term,indice,":",Length[indice]}]];
For[i=1,i<=Length[indice],i++,
ivar=indice[[i]];
AppendTo[vlist,If[AtomQ[ivar],ivar,First[ivar]]];
If[DEBUG>1,Print[ivar]];
];
pattern=Apply[Alternatives,vlist];
If[DEBUG>1,Print[pattern]];
If[Head[term]===Times,
ilist=Apply[List,term];
If[DEBUG>1,Print[ilist]];
For[i=1,i<=Length[ilist],i++,
If[FreeQ[ilist[[i]],pattern],
AppendTo[ilistFree,ilist[[i]]],
AppendTo[ilistYes,ilist[[i]]]
];
];
If[DEBUG>1,Print[ilistFree,ilistYes]];
out=Apply[Times,ilistFree];
in=Apply[Times,ilistYes];
tmp=out xSum[in,indices];
];
If[Head[term]=!=Times,  (*pass through plane function*)
If[FreeQ[term,pattern],
AppendTo[ilistFree,term],
AppendTo[ilistYes,term]
];
If[DEBUG>1,Print[ilistFree,ilistYes]];
out=Apply[Times,ilistFree];
in=Apply[Times,ilistYes];
tmp=out xSum[in,indices];
];
tmp
];

(*Combines Sum[a_,i__] + Sum[b_,i__] expression to Sum[a+b,i]   *)
PlusSum2SumPlus[exp_]:=Module[{tmp=exp},
tmp=tmp//.Sum->xSum;
tmp=tmp/.xSum[a_,i__]:>xSum[a,Apply[Sequence,Sort[{i}]]](*Order Sum indices*);
tmp=tmp//.xSum[a_,i__]+xSum[b_,i__]->xSum[a+b,i]
];
];
Put[Definition[IntegrateSumFunctions],
"IntegrateSumFunctions"
];
(* Legendre orthogonal polynomial relations *)
LegendreFunctions:=Module[{},
subP0=Integrate[a___ LegendreP[n_,t_],{t_,-1,1}]->(2/(2 n+1)) KroneckerDelta[n,0]a;
subP1=Integrate[a___ t_ LegendreP[n_,t_],{t_,-1,1}]->(2/(2 n+1)) KroneckerDelta[n,1]a;
subP2=Integrate[a___ LegendreP[m_,t_] LegendreP[n_,t_],{t_,-1,1}]->(2/(2 n+1)) KroneckerDelta[n,m]a;
subP3=Integrate[a___ LegendreP[1,t_] LegendreP[n_,t_] LegendreP[k_,t_] ,{t_,-1,1}]->2 a ThreeJSymbol[{1,0},{n,0},{k,0}]^2  ;
(*****There is a problem retrieving these definitions from the .m files.  Error on << But prior definitions OK.  Need to Clear[ the index ] before ReleaseHold.  Use Get["Definition/LegendreFunctions"].
******)
(**
subSeries[A_,\[Mu]_,l_]:=A[j___List]->HoldForm[\!\(
\*UnderoverscriptBox[\(\[Sum]\), \(l = 0\), \(\[Infinity]\)]\(A[l, Select[j, # != \[Mu]\  &\ ]]\ 
\*SuperscriptBox[\((\(-\[ImaginaryI]\))\), \(l\)]\ \((2\ l + 1)\)\ LegendreP[l, \[Mu]]\)\)];
subSeriesp[A_,\[Mu]_,l_]:=Derivative[1][A][j___]->HoldForm[\!\(
\*UnderoverscriptBox[\(\[Sum]\), \(l = 0\), \(\[Infinity]\)]\(\(\(Derivative[1]\)[A]\)[l, j]LegendreP[l, \[Mu]]\ 
\*SuperscriptBox[\((\(-\[ImaginaryI]\))\), \(l\)]\ \((2\ l + 1)\)\)\)];
subSeriesp[A_,\[Mu]_,l_]:=A'[j___]->HoldForm[\!\(
\*UnderoverscriptBox[\(\[Sum]\), \(l = 0\), \(\[Infinity]\)]\(\(\((A)\)'\)[l, j]LegendreP[l, \[Mu]]\ 
\*SuperscriptBox[\((\(-\[ImaginaryI]\))\), \(l\)]\ \((2\ l + 1)\)\)\)];
**)
(**TEST Module form of subSeries. **)
subSeries[A_,\[Mu]_,l_]:=Module[{head=Head[A],args=Select[A,#=!=\[Mu]&],tmp,sub},
tmp=Apply[head[l],args];
sub=A->\!\(
\*UnderoverscriptBox[\(\[Sum]\), \(l = 0\), \(\[Infinity]\)]\ \(
\*SuperscriptBox[\((\(-I\))\), \(l\)]\ \((2\ l + 1)\) tmp\ LegendreP[l, \[Mu]]\)\)
(*** This module causes errors if input as a .m file.  ***)
];
Put[Definition[LegendreFunctions],
"LegendreFunctions"
];
];

Define[name_,def_]:=Module[{out},
If[StringQ[name],
If[NameQ[name],Clear[name]];
out={Style[name<>": ",12],Style[def,12]};
ToExpression[name<>":="<>ToString[def,InputForm]]
,Print["\!\(\*
StyleBox[\"ERROR\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"DefPrint\",\nFontColor->RGBColor[1, 0, 0]]\) : ",name,",",def];
];
Apply[Sequence,out]
];

DefPrint[name_,def_]:=Module[{out},
If[StringQ[name],
If[NameQ[name],Clear[name]];
If[ShowDef>0,
Print[Style[name<>": ",12],Style[def,12]]
];
ToExpression[name<>":="<>ToString[def,InputForm]]
,Print["\!\(\*
StyleBox[\"ERROR\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"DefPrint\",\nFontColor->RGBColor[1, 0, 0]]\) : ",name,",",def];
];
];
PrtA[list___]:=Print["\n\[ShortRightArrow] ",list];

DotFunctions:=Module[{tmp0},
DotExpandMode[mode_]:=Module[{},
If[mode===True,
Unprotect[Dot];
Dot/:Dot[a___,b_+c_,d___]:=Dot[a,b,d]+Dot[a,c,d];
Protect[Dot]
,
Unprotect[Dot];
Quiet[
Dot/:Dot[a___,b_+c_,d___]=.;
];
Protect[Dot];
]
];

dotExtract[x_]:=Dot[a___,x,b___]->x Dot[a,b];

commuteDot={
HoldPattern[Dot[a_,b_]]:>Apply[Dot,Sort[{a,b}]]
}//Flatten;

groupDot[var_,exp_]:=
(*groups Dot subexpressions containing var_ *)
Module[{novar={},nodot={},groupdot={},tmpi,tmp=exp,DEBUG=0},
If[DEBUG>0,Print["groupDot:",{var,exp,Head[exp]}]];
If[Head[tmp]===Plus,tmp=Apply[List,tmp];
For[i=1,i<=Length[tmp],i++,tmpi=tmp[[i]];If[FreeQ[tmpi,var],AppendTo[novar,tmpi],If[FreeQ[tmpi,Dot],AppendTo[nodot,tmpi],AppendTo[groupdot,tmpi]]]
];
groupdot=Apply[Plus,groupdot/.var->1];
groupdot=xDot[groupdot,var];
If[DEBUG>0,Print[{groupdot,novar,nodot}]];
tmp=groupdot+Apply[Plus,nodot]+Apply[Plus,novar];
];
tmp
];

(*Keeps under Dot items in clist. Usage  expression/.Dot[a___]\[RuleDelayed]dotKeep[{ keep_list }]  [a].  Returns  nokeep_list Dot[ keep_list ]*)
dotKeep[clist_][seq_]:=
Module[{tmp=seq,i,j,member,tmpd={},tmps={1},DEBUG=0},
If[DEBUG>0,Print["dotKeep: ",seq]];
For[i=1,i<=Length[seq],i++,
If[DEBUG>0,Print["dotKeep: ",seq[[i]]//FullForm," : ",clist]];
For[j=1,j<=Length[clist],j++,
If[DEBUG>0,Print["dotKeep: ",seq[[i]]//FullForm," =?= ",clist[[j]]]];
member=False;
If[ MemberQ[{seq[[i]]},clist[[j]]]||
seq[[i]]=== clist[[j]]
,
member=True; j=Length[clist]+1
];
];
If[ member,
AppendTo[ tmpd,seq[[i]]];,
AppendTo[ tmps,seq[[i]]];
];
If[DEBUG>0,Print["dotKeep: ",">>",tmpd,tmps]];
];
tmp=Null;
If[Length[tmps]>0,
tmp=Apply[Times,tmps]];
If[Length[tmpd]>0,
tmp=tmp Apply[Dot,tmpd]];
If[DEBUG>0,Print["dotKeep: ",tmp]];
tmp
];

(* Version. 2010.2.16 --replaces dotKeep *)
DotKeep[clist_][seq_]:=
(*Keeps under Dot items in clist. Usage  expression/.Dot[a___]\[RuleDelayed]DotKeep[{ keep_list }]  [a].  Returns  nokeep_list Dot[ keep_list ]*)
Module[{tmp=seq,i,j,member,dot={},times={1},test,DEBUG=0},
tmp=tmp/.Times->Dot;
If[DEBUG>0,Print["DotKeep: ",seq," : ",tmp]];
For[i=1,i<=Length[tmp],i++,
test=tmp[[i]];
If[DEBUG>0,Print["DotKeep: ",test," : ",clist]];
member=False;
If[MemberQ[clist,test],member=True];
For[j=1,j<=Length[clist],j++,
If[! FreeQ[test,clist[[j]]],member=True]
];
If[ member,
AppendTo[ dot,test],
AppendTo[ times,test]
];
If[DEBUG>0,Print["DotKeep>>",dot,times]];
];
tmp=1;
If[Length[times]>0,
tmp=Apply[Times,times]];
If[Length[dot]>0,
tmp=tmp Apply[Dot,dot]];
If[DEBUG>0,Print["DotKeep: ",tmp]];
tmp
];

dotRetain[clist_,exp_]:=
(*Keeps clist items under Dot in expression.  This routine is taking advantage of the Dot function to keep variables noncommuting.  A pattern would be useful in clist.  *)
Module[{tmp=exp,i},
List["dotRetain: ",tmp];
tmp=tmp/.Times->Dot;
tmp=tmp/.Dot->xDot;
List["dotRetain0: ",tmp];
tmp=tmp//.xDot[a___]:>DotKeep[clist][{a}]/;!MemberQ[{a},xDot,99,Heads->True];
List["dotRetain1:",tmp];
tmp
];

DotPower[a_,n_]:=Module[{i,out={}},
For[i=1,i<=n,i++,AppendTo[out,a]];
Apply[Dot,out]
];

(*Corrects PartialD's action on Dot list*)
PartialDDot[a_,b_]:=Module[{i,tmp,result={}},If[Head[a]===Dot,tmp=Apply[List,a]; 
For[i=1,i<=Length[tmp],i++,
AppendTo[result,Apply[Dot,ReplacePart[tmp,i->PartialD[a[[i]],b]]]];
];
Apply[Plus,result],PartialD[a,b]](*Last statement may not work.*)
];

(* recursive version, Usage:  exp/.xPartialD[a_,b_]\[RuleDelayed]xPartialDDot[a,b] *)
xPartialDDot[a_,b_]:=Module[{i,tmp1,tmp=Apply[List,a],accum={},head=Head[a] },
List["xPartialDDot:",head,": ",tmp," : ",b];
If[ MemberQ[{Dot,Plus,Times},head] ,
tmp1=tmp;
tmp=Map[xPartialDDot[#,b]&,tmp];
If[ MemberQ[ {Plus},head]  ,tmp=Apply[head,tmp],
(*for multiplicative terms*)
For[i=1,i<=Length[tmp],i++,
AppendTo[accum,Apply[head,ReplacePart[tmp1,i->tmp[[i]]  ]  ]];
List["accum",i,":",accum];
];
tmp=Apply[Plus,accum]
]
,tmp=xPartialD[a,b] (* stop nesting *)
];
List[">",tmp];
tmp
];
(* recursive version, Usage:  exp/.xPartialDu[a_,b_]\[RuleDelayed]xPartialDuDot[a,b] *)
xPartialDuDot[a_,b_]:=Module[{i,tmp1,tmp=Apply[List,a],accum={},head=Head[a],DEBUG=0,mname="xPartialDuDot"},
List[name,head,": ",tmp," : ",b];
If[ MemberQ[{Dot,Plus,Times},head] ,
tmp1=tmp;
tmp=Map[xPartialDuDot[#,b]&,tmp];
If[ MemberQ[ {Plus},head]  ,tmp=Apply[head,tmp],
(*for multiplicative terms*)
For[i=1,i<=Length[tmp],i++,
AppendTo[accum,Apply[head,ReplacePart[tmp1,i->tmp[[i]]  ]  ]];
List["accum",i,":",accum];
];
tmp=Apply[Plus,accum]
]
,tmp=xPartialDu[a,b] (* stop nesting *)
];
List[">",tmp];
tmp
];
(*Expression operator version combining xPartialDDot  and xPartialDuDot.*)
xPartialDDot[exp_]:=Module[{},
tmp=exp/.xPartialD[a_,b_]:>xPartialDDot[a,b];
tmp=tmp/.xPartialDu[a_,b_]:>xPartialDuDot[a,b];
tmp
];

(*Changes xPartialD[IntegralOp[a,b],c]\[Rule]IntegralOp[a,xPartialD[b,c]]
No integration limit checking.*)
ExchangexPartialDIntegralOp[exp_]:=Module[{tmp=exp,tmp1,DEBUG=0},
If[DEBUG>0,Print[tmp]];
tmp=tmp/.xPartialD[a_,b_]:>If[Head[a]===IntegralOp,
a/.IntegralOp[c_,d_]:>IntegralOp[c,xPartialD[d,b]],
xPartialD[a,b]
];
tmp=tmp/.xPartialDu[a_,b_]:>If[Head[a]===IntegralOp,
a/.IntegralOp[c_,d_]:>IntegralOp[c,xPartialDu[d,b]],
xPartialDu[a,b]
];
tmp
];

(*Changes PartialD[Sum[a,b],c]\[Rule]Sum[a,PartialD[b,c]]*)
(* 2.28.2010*)
ExchangePartialDSum[exp_]:=Module[{tmp=exp,tmp1=NULL,DEBUG=0},
If[DEBUG>0,Print["ExchangePartialDSum: ",tmp]];
(*Cannot substitute with PartialD[], change to xPartialD[].  PartialD[] knows how to deal with functions, so needs the PartialD[] phase.
*)
While[tmp1=!=tmp,
tmp1=tmp;
If[DEBUG>0,Print["ExchangePartialDSum: ",tmp]];
tmp=tmp//.PartialD->xPartialD;
tmp=tmp/.distributePartialD;
tmp=tmp/.xPartialD[Sum[a_,c__],b_]:>Sum[xPartialD[a,b],c];
tmp=tmp//.xPartialD->PartialD;
];
tmp
];

distributePartialD=xPartialD[a_,b_]:>If[Head[a]===Plus,Map[xPartialD[#,b]&,a],xPartialD[a,b]];

(*Alternative to just using xPartialDExpand so that xPartialD[array] distributes over arrays.
CAREFUL: Unintended results occur when expression contains a sum of scalars and arrays.  To keep proper relationship keep arrays within Dot expressions.
Usage: expression/.xPartialD[arg,mu]:>xPartialDDistribute[arg,mu]
*)
xPartialDDistribute[arg_,mu_]:=Module[{tmp=arg,DEBUG=0},
tmp=xPartialD[tmp,mu]//.xPartialDExpand;
tmp=tmp//.xPartialD[a_List,mu]:>Thread[xPartialD[a,mu]];
tmp=tmp//.xPartialDExpand;
IfDEBUG["xPartialDDistribute",DEBUG>0,{MatrixForm[tmp]},"result"];
tmp
];
tmp0=f  Dot[f[a],b,g Dot[c,h Muu[i,j]],NN]==0;
dotRetain[{c,f[a],Tensor[M,__],NN},tmp0];
];
(*Functions for IntegralOp*)
IntegralFunctions:=Module[{},
subIntInt2IntNoExpand={
IntegralOp[a_,d_]  IntegralOp[b_,c_] :>IntegralOp[Join[a,b],d c],IntegralOp[a_,d_ IntegralOp[b_,c_] ]:>IntegralOp[Join[a,b],d c],
IntegralOp[a_,IntegralOp[b_,c_ ]]:>IntegralOp[Join[a,b], c]
};
subIntInt2Int={
IntegralOp[a_,d_]  IntegralOp[b_,c_] :>IntegralOp[Join[a,b],ExpandAll[d c]],IntegralOp[a_,d_ IntegralOp[b_,c_]]:>IntegralOp[Join[a,b],ExpandAll[d c]],
IntegralOp[a_,IntegralOp[b_,c_] ]:>IntegralOp[Join[a,b], c]
};
(*subDistributeIntegralOp*)
distributeIntegralOp:=IntegralOp[a_,b_]:>Map[IntegralOp[a,#]&,Expand[b]]/;Head[Expand[b]]===Plus;

gatherInt={c_ IntegralOp[a_,b_]->IntegralOp[a,c b],
IntegralOp[a_,b_]+ IntegralOp[a_,c_]->IntegralOp[a,b+c],
d___ IntegralOp[a_,b_]+ e__ IntegralOp[a_,c_]->IntegralOp[a,d b+e c]
};

sortIntVar=IntegralOp[a_List,b_]:>IntegralOp[Sort[a],b];

MoveIntOut={a__ IntegralOp[b_,c_]:>If[Head[c]===Plus,IntegralOp[b,Map[a # &,c] ],IntegralOp[b,a c ]]};
MoveIntOut1={a__ IntegralOp[b_,c_]:>If[Head[Expand[c]]===Plus,IntegralOp[b,Map[a # &,Expand[c]] ],IntegralOp[b,a c ]]};
IntDotInt2Int={HoldPattern[f___. IntegralOp[a_,intgA_].h___. IntegralOp[b_,intgB_].g___]:>IntegralOp[Sort[Flatten[{a,b},1]],f.intgA.h.intgB.g],HoldPattern[f__. IntegralOp[a_,intgA_].h___]:>IntegralOp[a,f.intgA.h],HoldPattern[ IntegralOp[a_,intgA_].h___]:>IntegralOp[a,intgA.h]};
IntDotInt2Int2= IntegralOp[a_,intgA_]. IntegralOp[b_,intgB_]:>IntegralOp[Sort[Flatten[{a,b},1]],intgA.intgB];

cleanInt={IntegralOp[{},b_]->b,IntegralOp[{__},0]->0};

(* returns {position, integrand} of deepest IntegralOp's in exp_ << 5.30.2010 *)
ExtractIntegrand[exp_]:=Module[{pos,tmp},tmp=Extract[exp,pos=Position[exp,IntegralOp[a_,b_]]][[1,2]];
{   Append[First[pos],2]   ,{tmp}  }
];
(*ExtractIntegrandP returns a Rule *)
ExtractIntegrandP[exp_]:=Module[{pos,tmp},tmp=Extract[exp,pos=Position[exp,IntegralOp[a_,b_]]][[1,2]];
{   Append[First[pos],2]   ->tmp }
];

(*Separates integration variable in multiple integrals into multiple integral expressions with a single variable.  Only acts on IntegralOp's with identical variable list.*)
SeparateIntVar[exp_,varlist_]:=Module[{i,j,tmp,tmpi,pos,poss,tmpe=exp,new},
poss=Position[tmpe,IntegralOp[a_,b_]];
For[i=1,i<=Length[poss],i++,(*do over all IntegralOp*)
tmpi=Extract[tmpe,poss[[i]]];
If[Sort[varlist]==Sort[tmpi[[1]]],(*do separation*)
new =IntegralOp[{Last[varlist]},tmpi[[2]]];
For[j=Length[varlist]-1,j>0,j--,
new =IntegralOp[{varlist[[j]]},new]
];
tmpe=ReplacePart[tmpe,poss[[i]]->new]
];
];
tmpe
];

(*Separates integration variable in multiple integrals into multiple integral expressions with a single variable.  Orders the integral as specified as permutation..*)
SeparateIntVar1[permutation_,Integral_]:=Module[{i,tmp,tmpv,out=Integral,var,integrand,DEBUG=0},
If[DEBUG>0,Print["SeparateIntVar1:",permutation,":",Integral]];
If[Head[Integral]===IntegralOp,
{var,integrand}=Apply[List,Integral];
out=integrand;
var=Permute[var,permutation];
If[DEBUG>0,Print["var:",var,":",out]];
For[
i=Length[var],i>0,i--,
out=IntegralOp[{ var[[i]] },out];
If[DEBUG>1,Print[i,":",out]];
];
];
out
];

gatherIntFast[exp_]:=
(*gathers sums of IntegralOp's with identical dummy variable list*)
Module[{tmp=exp},
tmp=tmp/.-IntegralOp[a_List,b_]->IntegralOp[a,-b];
tmp=tmp//.MoveIntOut1;
tmp=tmp//.IntegralOp[a_List,b_Times|b_Dot|b_List|b_Sum]+ IntegralOp[a_List,c_Times|c_Dot|c_List|c_Sum]:>IntegralOp[a,Flatten[{b,c}]];
tmp=tmp/.IntegralOp[a_List,b_List]:>IntegralOp[a,Apply[Plus,Flatten[b]]];
tmp=tmp/.gatherInt
];

(*Finds and replaces integral representation of DiracDelta with DiracDelta*)
findIntDelta[exp_]:=Module[{i,tmp=exp,v,var,int,intg,intp},
tmp=tmp//.distributeIntegralOp;
If[Head[tmp]===IntegralOp,replaceIntDelta[tmp],
intp=Position[tmp,IntegralOp[_,_] ];
MapAt[replaceIntDelta,tmp,intp]
]
];
replaceIntDelta[int_]:=(*Replaces Integral representation of DiracDelta in single IntegralOp[var,intg(NoSum)]  *)Module[{var,intg,i,ie,v,vnew={},tmp,out=int,tmpI,tmpE,tmpEp,exp,coef,sumcoef,expv,test,DEBUG=0},
If[DEBUG>0,Print["replaceIntDelta:",int]];
If[Head[int]===IntegralOp,
{var,intg}=Apply[List,int];
If[DEBUG>0,Print[{var,intg}]];
tmpI=intg;
For[i=1,i<=Length[var],i++,
expv=1;
sumcoef=0;
v=var[[i,1]];
If[DEBUG>1,Print["v:",v]];
tmpEp=Position[tmpI,Exp[_]];
tmpE=Extract[tmpI,tmpEp];
For[ie=1,ie<=Length[tmpEp],ie++,
exp=tmpE[[ie]]/.Exp[a_]->a;
coef=Coefficient[exp,v];
expv*=Exp[coef v];
sumcoef+=coef;
];
test=tmpI/expv//ExpandAll;
If[DEBUG>1,Print[tmpI, "PP ",expv,"LL: ",Position[test,v],"LL ",test,">>",Length[Position[test,v]]]];
If[Length[Position[test,v]]==0&&Length[Position[expv,v]]!=0,(*IsDelta*)
tmpI=test (2 \[Pi])^Dim[v] DiracDelta[-I sumcoef//Simplify]
,
AppendTo[vnew,{v}]
];
If[DEBUG>0,Print[tmpI,"<<KK"]];
];
out=IntegralOp[vnew,tmpI];
];
out/.cleanInt
];

(*Finds and IntegralOp with DiracDelta*)
findEvalIntDelta[exp_]:=Module[{i,tmp=exp,intPos,out,repl={},DEBUG=0},
tmp=tmp//.distributeIntegralOp;
If[DEBUG>0,Print["findEvalIntDelta: ",tmp]];
If[Head[tmp]===IntegralOp,evalDeltaInt[tmp],
intPos=Position[tmp,IntegralOp[_,_] ];
If[DEBUG>0,Print["findEvalIntDelta: ",Length[intPos],":",intPos]];
MapAt[evalDeltaInt,tmp,intPos]
]
];

evalDeltaInt[int_]:=(*Evaluates DiracDelta within IntegralOp[ { {v1},{v2} },intg(NoSum)]  *)Module[{var,intg,i,id,v,vnew={},tmp,out=int,tmpI,tmpDelta,subv,posDelta,argDelta,vDeltaPos,DEBUG=0},
If[DEBUG>0,Print["<",int,">"]];
If[Head[int]===IntegralOp,
{var,intg}=Apply[List,int];
tmpI=intg;
For[i=1,i<=Length[var],i++,
v=var[[i,1]];
posDelta=Position[tmpI,DiracDelta[_]];
tmpDelta=Extract[tmpI,posDelta];
If[DEBUG>0,Print["v:",v,":",tmpDelta]];
For[id=1,id<=Length[posDelta],id++,
argDelta=tmpDelta[[id]]/.DiracDelta[a_]->a;
vDeltaPos=Position[argDelta,v];
If[Length[vDeltaPos]>0,
If[Position[tmpI,Dot]=!={},
(*simple substitution in case of Dot in integrand*)
subv=Solve[argDelta==0,v][[1]];
tmpI=tmpI/.subv;
tmpI=tmpI/.DiracDelta[0]->1;
,
(*tmpI=IntegrateOp[tmpI,{v,-\[Infinity],\[Infinity]}];
tmpI=tmpI/.IntegrateOp\[Rule]Integrate;  Simple replacement is more predictable.*)
subv=Solve[argDelta==0,v][[1]];
tmpI=tmpI/.subv;
tmpI=tmpI/.DiracDelta[0]->1;
];
id=1000;
];
List[tmpI,"<<KK"];
];
If[id<1000,AppendTo[vnew,var[[i]]]];
];
If[DEBUG>0,Print["DEBUGtmpI: ",Length[tmpI],Head[tmpI]]];
out=IntegralOp[vnew,tmpI];
];
out=out/.cleanInt;
If[DEBUG>0,Print["DEBUGout: ",Position[out,IntegralOp[__]]]];
out
];

(*Finds and IntegralOp with DiracDelta.  Keeps variable vIgnore in DiracDelta.*)
findEvalIntDelta[exp_,vIgnore_]:=Module[{i,tmp=exp,intPos,out,repl={},DEBUG=0},
tmp=tmp//.distributeIntegralOp;
If[Head[tmp]===IntegralOp,evalDeltaInt[tmp],
intPos=Position[tmp,IntegralOp[_,_] ];
If[DEBUG>0,Print["DEBUG findEvalIntDelta:",Length[intPos],":",intPos]];
MapAt[evalDeltaInt[#,vIgnore]&,tmp,intPos]
]
];

evalDeltaInt[int_,vIgnore_]:=(*Evaluates DiracDelta within IntegralOp[var,intg(NoSum)]. Keeps variable vIgnore in DiracDelta evaluation  *)Module[{var,intg,i,id,v,vnew={},tmp,out=int,tmpI,tmpDelta,subv,posDelta,argDelta,vDeltaPos,DEBUG=0},
If[DEBUG>0,Print["<",int,">"]];
If[Head[int]===IntegralOp,
{var,intg}=Apply[List,int];
vnew=Extract[var,Position[var,vIgnore]];
var=Delete[var,Position[var,vIgnore]];
tmpI=intg;
For[i=1,i<=Length[var],i++,
v=var[[i,1]];
posDelta=Position[tmpI,DiracDelta[_]];
tmpDelta=Extract[tmpI,posDelta];
If[DEBUG>0,Print["v:",v,":",tmpDelta]];
For[id=1,id<=Length[posDelta],id++,
argDelta=tmpDelta[[id]]/.DiracDelta[a_]->a;
vDeltaPos=Position[argDelta,v];
If[Length[vDeltaPos]>0,
If[Position[tmpI,Dot]=!={},
(*simple substitution in case of Dot in integrand*)
subv=Solve[argDelta==0,v][[1]];
tmpI=tmpI/.subv;
tmpI=tmpI/.DiracDelta[0]->1;
,
subv=Solve[argDelta==0,v][[1]];
tmpI=tmpI/.subv;
tmpI=tmpI/.DiracDelta[0]->1;
(*
tmpI=IntegrateOp[tmpI,{v,-\[Infinity],\[Infinity]}];
tmpI=tmpI/.IntegrateOp\[Rule]Integrate;*)
];
If[DEBUG>2,Print["tmpI:",tmpI]];
id=1000;
];
List[tmpI,"<<KK"];
];
If[id<1000,AppendTo[vnew,v]];
];
If[DEBUG>0,Print["DEBUGtmpI: ",Length[tmpI],Head[tmpI]]];
out=IntegralOp[vnew,tmpI];
];
out=out/.cleanInt;
If[DEBUG>0,Print["DEBUGout: ",out]];
out
];

evalDeltaIntOver[int_,over_]:=(*Evaluates single DiracDelta over over_ in  IntegralOp[var,intg(NoSum)]. 
Use:  evalDeltaIntOver[IntegralOp[ { {a},{b} },  fn[a,b],  a ]   *)Module[{var,intg,i,id,v,vnew={},tmp,out=int,tmpI,tmpDelta,subv,posDelta,argDelta,vDeltaPos,ilist,varpos,DEBUG=0},
If[DEBUG>0,Print["<",int,">"]];
If[Head[int]===IntegralOp,
{var,intg}=Apply[List,int];
vnew=var;
tmpI=intg;
posDelta=Position[tmpI,DiracDelta[_]];(*position all Deltas*)
tmpDelta=Extract[tmpI,posDelta];
If[DEBUG>0,Print["over:",over,":",posDelta,":",tmpDelta]];
For[id=1,id<=Length[posDelta],id++,
If[!FreeQ[tmpDelta[[id]],over],(*If over is in Delta*)
varpos=Position[var,over];
If[DEBUG>0,Print["varPos:",varpos,varpos[[1,1]]]];
vnew=Delete[var,{varpos[[1,1]]}];
If[DEBUG>0,Print["vnew:",vnew]];
(*delete from output vars*)
argDelta=tmpDelta[[id]]/.DiracDelta[a_]->a;
vDeltaPos=Position[argDelta,over];
If[Length[vDeltaPos]>0,
If[Position[tmpI,Dot]=!={},
(*simple substitution in case of Dot in integrand*)
subv=Solve[argDelta==0,over][[1]];
tmpI=tmpI/.subv;
tmpI=tmpI/.DiracDelta[0]->1;
,
subv=Solve[argDelta==0,over][[1]];
tmpI=tmpI/.subv;
tmpI=tmpI/.DiracDelta[0]->1;
];
If[DEBUG>2,Print["tmpI:",tmpI]];
id=1000;
];
If[DEBUG>2,Print["tmpI:",tmpI]];
];
];

If[DEBUG>0,Print["DEBUGtmpI: ",Length[tmpI],Head[tmpI]]];
out=IntegralOp[vnew,tmpI];
];
out=out/.cleanInt;
If[DEBUG>0,Print["DEBUGout: ",out]];
out
];

(*Fourier symbol replacement-simple case *)
IntReplaceFourier[exp_,var_]:=Module[{tmp=exp,vs,v,integrand,expv,out=exp},
If[Head[tmp]===IntegralOp,
{vs,integrand}=tmp/.IntegralOp[a_,b_]->{a,b};
expv=integrand/.b___ Exp[a_]c___->a;
If[MemberQ[Apply[List,expv],var],
integrand=integrand/.Exp[expv]->1;
expv/=(I var);
integrand=integrand/.a_[var]->
\!\(\*OverscriptBox[\(a\), \(~\)]\)[ expv];
vs=Select[vs,#=!=var&];
out=IntegralOp[vs,integrand],
out=exp
];
];
out
];

UniqueIntVars[exp_]:=(*reassigns dummy integration variables (which are define as x[,] here)in expression so that they are unique. *)Module[{tmp=exp,listIntVar={},ints ,i,j,n=1,ivars,subI,newints={}},
List[exp,">"];
intPos=Position[tmp,IntegralOp[_,_]];
ints=Extract[tmp,intPos];
For[i=1,i<=Length[ints],i++,
ints[[i]]/.IntegralOp[a_,b_]:>AppendTo[listIntVar,a];
ivars=ints[[i]][[1]];
subI={};
For[j=1,j<=Length[ivars],j++,
subv=ivars[[j,1]]/.x[a_,b_]:>(x[a,b]->x[n++,b]);
AppendTo[subI,subv];
];
AppendTo[newints,intPos[[i]]->(ints[[i]]//.subI)]
];
ReplacePart[tmp,newints]
];

UniqueIntVars3[exp_,klist_]:=(*reassigns dummy integration variables in x_List in expression so that they are unique. *)Module[{tmp=exp,listIntVar={},ints ,i,j,n=1,ivars,subI,subv,head,newints={}},
intPos=Position[tmp,IntegralOp[_,_]];
ints=Extract[tmp,intPos];
For[i=1,i<=Length[ints],i++,
ints[[i]]/.IntegralOp[a_,b_]:>AppendTo[listIntVar,a];
ivars=ints[[i]] [[1]];
List[listIntVar,":",  ints[[i]] ," ivars ",ivars];
subI={};
For[j=1,j<=Length[ivars],j++,
If[Head[ivars[[j]]]===Tensor,
head=ivars[[j]]  [[1]];
List[klist,":head:",head,":",ivars[[j]]];
If[MemberQ[klist,head] ,
subv=ivars[[j]]/.Tensor[head,a_,b_]:>If[Head[First[a]]===Integer||Head[First[a]]===Symbol,First[a],Tensor[head,a,b]->Tensor[head,Flatten[{Head[First[a]][xI[n++]],Rest[a]}],b]];
If[Head[subv]===Rule,
AppendTo[subI,subv]];
List["subv",subI];
];
];
];
AppendTo[newints,intPos[[i]]->(ints[[i]]//.subI)]
];
xI[a_]:=a;
tmp=ReplacePart[tmp,newints];
Clear[xI];
tmp
];

UniqueIntVars4[exp_,klist_]:=(*reassigns dummy integration variables in k_List in expression so that they are unique.  Integration variable has form x[k,___] *)Module[{tmp=exp,listIntVar={},ints ,i,j,n=1,ivars,subI,subv,head,newints={}},
intPos=Position[tmp,IntegralOp[_,_]];
ints=Extract[tmp,intPos];
For[i=1,i<=Length[ints],i++,
ints[[i]]/.IntegralOp[a_,b_]:>AppendTo[listIntVar,a];
ivars=ints[[i]] [[1]];
Print[listIntVar,":",  ints[[i]] ," ivars ",ivars];
subI={};
For[j=1,j<=Length[ivars],j++,
If[Head[ivars[[j]]]===Tensor,
head=ivars[[j]]  [[1]];
Print[klist,":head:",head];
If[MemberQ[klist,head] ,
subv=ivars[[j]]/.head[a_,b_]:>(head[a,b]->head[xI[n++],b]);
AppendTo[subI,subv];
List["subv",subI];
];
];
];
AppendTo[newints,intPos[[i]]->(ints[[i]]//.subI)]
];
xI[a_]:=a;
tmp=ReplacePart[tmp,newints];
Clear[xI];
tmp
];

(****)
(*converts IntegralOp integration variable to a uniform set so that integrands may be combined in a sum of IntegralOp's.  This version assumes the variables are referenced as x[n,i].*)
UniformIntVar[exp_]:=Module[{intPos,i,j,k,ints,int,varlist={},var,varj,vars,varsj,intj,intvar,repl={},DEBUG=0},
intPos=Position[exp,IntegralOp[__]];
ints=Extract[exp,intPos];List[ints];
For[i=1,i<=Length[ints],i++,int=ints[[i]][[1]];List[">",int];
AppendTo[varlist,int];
];
varlist=DeleteDuplicates[varlist];
For[i=1,i<=Length[varlist],i++,vars=varlist[[i]];
If[vars=!={},
For[j=1,j<=Length[varlist],j++,varsj=varlist[[j]];
If[vars=!=varsj&&Length[vars]==Length[varsj],
For[intj=1,intj<=Length[ints],intj++,
intvar=ints[[intj]][[1]];
If[intvar===varsj,
List[vars,varsj,ints[[intj]]];
For[k=1,k<=Length[vars],k++,var=vars[[k]];varj=varsj[[k]];
If[varj=!=var,
ints[[intj]]=ints[[intj]]/.varj->var;
];
];
AppendTo[repl,intPos[[intj]]->ints[[intj]]];
];
];
varlist[[j]]={};
];
];
];
];
ReplacePart[exp,repl]
];

UniformIntVar1[exp_]:=
(*converts IntegralOp integration variable to a uniform set so that integrands may be combined in a sum of IntegralOp's.  This version assumes the variables are referenced as x[n,i].*)Module[{intPos},
intPos=Position[exp,IntegralOp[_,__]];
MapAt[DummyIntVar,exp,intPos]
];
DummyIntVar[int_]:=Module[{vars,intg,sub,j,xd},
{vars,intg}=Apply[List,int];
sub={};
For[j=1,j<=Length[vars],j++,
xd=vars[[j,1]];
xd=xd/.x[a_,b_]->x[d[j],b];
AppendTo[sub,vars[[j,1]]->xd];
];
intg=intg/.sub;
vars=vars/.sub;
IntegralOp[vars,intg]
];

(*Moves terms without integration variable out from under integral sign.*)
IntegralOpMoveNVarOut[exp_]:=Module[{tmp=exp,i,vars,vlist={},integrand,ilist,ilistFree={},ilistYes={},pattern,out,in,DEBUG=0},
If[Head[tmp]===IntegralOp,
{vars,integrand}=Apply[List,tmp];
If[DEBUG>0,Print[{vars,integrand}]];

For[i=1,i<=Length[vars],i++,
AppendTo[vlist,First[vars[[i]]]];
If[DEBUG>1,Print[First[vars[[i]]]]];
];
pattern=Apply[Alternatives,vlist];
If[DEBUG>1,Print[pattern]];

If[Head[integrand]===Times,
ilist=Apply[List,integrand];
If[DEBUG>1,Print[ilist]];
For[i=1,i<=Length[ilist],i++,
If[FreeQ[ilist[[i]],pattern],
AppendTo[ilistFree,ilist[[i]]],
AppendTo[ilistYes,ilist[[i]]]
];
];
If[DEBUG>1,Print[ilistFree,ilistYes]];
out=Apply[Times,ilistFree];
in=Apply[Times,ilistYes];
tmp=out IntegralOp[vars,in];
];
];
tmp
];
(*Arguement only version*)
IntegralOpMoveNVarOut[vars_,integrand_]:=Module[{tmp=IntegralOp[vars,integrand],i,vlist={},ilist,ilistFree={},ilistYes={},pattern,out,in,DEBUG=0},
If[DEBUG>0,Print["IntegralOpMoveNVarOut:",{vars,integrand}]];
For[i=1,i<=Length[vars],i++,
AppendTo[vlist,First[vars[[i]]]];
If[DEBUG>1,Print[First[vars[[i]]]]];
];
pattern=Apply[Alternatives,vlist];
If[DEBUG>1,Print[pattern]];
If[Head[integrand]===Times,
ilist=Apply[List,integrand];
If[DEBUG>1,Print[ilist]];
For[i=1,i<=Length[ilist],i++,
If[FreeQ[ilist[[i]],pattern],
AppendTo[ilistFree,ilist[[i]]],
AppendTo[ilistYes,ilist[[i]]]
];
];
If[DEBUG>1,Print[ilistFree,ilistYes]];
out=Apply[Times,ilistFree];
in=Apply[Times,ilistYes];
tmp=out IntegralOp[vars,in];
];
If[Head[integrand]=!=Times,  (*pass through plane function*)
If[FreeQ[integrand,pattern],
AppendTo[ilistFree,integrand],
AppendTo[ilistYes,integrand]
];
If[DEBUG>1,Print[ilistFree,ilistYes]];
out=Apply[Times,ilistFree];
in=Apply[Times,ilistYes];
tmp=out IntegralOp[vars,in];
];
tmp
];

sIntegralOpMoveNVarOut=IntegralOp[a_,b_]:>IntegralOpMoveNVarOut[a,b];

(* Apply IntegralOpMoveNVarOut on all IntegralOp terms.*)
IntegralOpMoveNVarOutAll[exp_]:=Module[{tmp=exp,tmp0=NULL},
While[tmp0=!=tmp,
tmp0=tmp;
tmp=tmp/.IntegralOp[var_,intg_]:>IntegralOpMoveNVarOut[var,intg]
];
tmp
];
(*separates multiples integral into nested single integrals, e.g. IntegralOp[{{a},{b}},f[a,b]] ->IntegralOp[{{a},IntegralOp[{{b}},f[a,b]] 
*)
Int2IntInt[exp_]:=Module[{tmp=exp},
tmp=tmp//.IntegralOp[a_List,b_]:>IntegralOp[{First[a]},IntegralOp[Rest[a],b]]/;Length[a]>1;
tmp
];
Int2IntIntSub=IntegralOp[a_List,b_]:>IntegralOp[{First[a]},IntegralOp[Rest[a],b]]/;Length[a]>1;
(****)
];

IntegralFunctions
DotFunctions

(*From Tensorial*)
MCommutator::usage = "MCommutator[A,B] calculates the commutator of matrices A and B";
MCommutator[A_,B_]:=A.B-B.A;

(*Removes third arguement of Dt.  Mathematica does not allow direct substitution.*)
DtRemove3[exp_]:=exp/.Dt->xDt/.xDt[a_,b_,c___]->Dt[a,b];
DtOnly2[exp_]:=exp/.Dt->xDt/.xDt[a_,b_,c___]->Dt[a,b];



