(* Fermat.m, by M. Headrick *)

(*
This package implements the method described in the paper "Energy functionals for Calabi-Yau metrics" by M. Headrick and A. Nassar (arXiv:0908.2635), for numerically computing the Ricci-flat metric on a Calabi-Yau defined as a polynomial variety in $CP^N$, for the case of the Fermat polynomial.
*)

(*
The method may easily be extended to other projective Calabi-Yaus. Permission is granted to alter this package for that purpose, as long as credit is given to the original package.
*)

(*
The use of this package is illustrated in the notebook optimal.nb. For detailed explanations of the calculational methods and the notation, see the set of notes strategy.pdf. Both may be downloaded at http://people.brandeis.edu/~headrick/physics/ .
*)

(* N1 is $N+1$. qq is $\mathcal{Q}$. EE is $E$. H1 is the unnormalized version of $E$, i.e. the variance of v (numerator of equation (5.4) in the paper). *)

(* Before the package is loaded, the values of N1 and k must be defined. *)

(*

The package consists of several sections.

The first section finds a basis for the space of symmetric polynomials modulo those that vanish on $X$.

The second section defines functions for sprinkling points randomly over $X$.

The third section defines functions for computing the necessary data (Q and qq) given a set of points.

The fourth section defines functions that compute and display v and D and related quantities, given the above data and an h vector.

The fifth section gives functions that remove the zero-mode of H1 (multiplying h by an overall constant) from the space of h's.

The sixth section computes h for the Fubini-Study metric, which can be used as a starting point for the minimization.

The seventh section defines a function that minimizes H1 given the above data and a starting value of h.

The eighth section computes $\hat E$, the two-derivative functional.

*)


(* ******************************************************************************** *)

(* Section 1: Finding a basis of polynomials *)

(* The symmetry group is generated by three factors: multiplication of the coordinates by N1'th roots of unity; permutations of the coordinates; and conjugation of the coordinates. A basis for the degree (k,k) homogeneous polynomials is given by the set of monomials that are invariant under the roots of unity, symmetrized under permutations and conjugation. Each such monomial is determined by the matrix of its exponents, a 2 x N1 matrix of non-negative integers satisfying certain constraints. We begin with some functions for rearranging such matrices. *)

sortColumns[exp_List] := Transpose[ Sort[ Transpose[ exp ] ] ]

canonical[exp_List] := First[ Sort[ { sortColumns[exp], sortColumns[Reverse[exp]] } ] ]

RUsymmetric[exp_List] := And @@ Divisible[ exp[[1]] - exp[[2]], N1 ]

(* We now construct a basis of symmetric (k,k) polynomials and (k-N1,k) polynomials. (The latter are invariant under the roots of unity and symmetric under permutations, but obviously not invariant under conjugation.) *)

OrderedPolys[m_] := IntegerPartitions[m + N1, {N1}] - 1

OrderedPolysk = OrderedPolys[k]

rho = Flatten[Permutations /@ OrderedPolysk, 1]

kkpolys =
  Union[
    canonical /@ 
      Select[ Distribute[ { OrderedPolysk, rho }, List ], RUsymmetric ]
    ]

Numkk = Length[kkpolys]

kminusN1kpolys =
  If[
    k < N1,
    {},
    Union[
      sortColumns /@
        Select[ Distribute[ { OrderedPolys[k-N1], rho }, List ], RUsymmetric ]
      ]
    ]

(* Express g P, where g is a (k-N1,k) polynomial, as a linear combination of the (k,k) polynomials. *)

whichkkpoly[exp_List] :=
  UnitVector[ Numkk, Position[ kkpolys, canonical[exp] ][[1,1]] ]

vec[exp_List] := 
  Sum[ whichkkpoly[ exp + SparseArray[{{1, a} -> N1}, {2, N1}] ], {a, N1} ]

(* Find a basis for the quotient of the space of all (k,k) polynomials by the set of g P for all (k-N1,k) polynomials g. *)

zeroBasis = vec /@ kminusN1kpolys

quotientBasis =
  If[ k < N1, IdentityMatrix[ Numkk ], SparseArray[ NullSpace[ zeroBasis ] ] ]

M = Length[quotientBasis]

Print[
 "Basis of polynomials computed. The space is ",
 M,
 " dimensional."
 ]



(* ******************************************************************************** *)

(* Section 2: Sprinkling points *)

(* inhomogenous coordinates *)

HIC = Table[Subscript[u, n], {n, N1-1}]

HIC1 = Append[HIC,1]

AIC = Table[Subscript[OverBar[u], n], {n, N1-1}]

AIC1 = Append[AIC,1]

Co = Conjugate

P = Total[HIC1^N1]

Q = D[P, {HIC}]


(* project a point u0 in CP^(N1-1) orthogonally onto the P = 0 surface *)

projectOntoP[u0_List]:= (
 w = Co[ (Q - N1 Co[u0]) /. Thread[HIC -> u0] ];
 u1 = u0 + m w;
 u1 /. FindRoot[P /. Thread[HIC -> u1], {m, 0}]
 )


(* generate a set of points on $X$; this is done most efficiently in batches *)

batchsize = 500000

batch[eps_Real]:= (
  USpoints = RandomComplex[ {-I-1,I+1}, batchsize ];
  CPNpoints = Partition[ Pick[ USpoints, Positive[1-Abs[USpoints]] ], N1 - 1 ];
  Pick[ CPNpoints, Positive[ eps - Abs[Total[CPNpoints^N1,{2}]+1] ] ]
  )

sprinkle[num_Integer,eps_Real]:=
  projectOntoP /@ Take[ NestWhile[ Join[#,batch[eps]]&, {}, (Length[#] < num) & ], num ]



(* ******************************************************************************** *)

(* Section 3: Computing data *)

(* Convert the matrices in kkpolys into actual polynomials. *)

ICorders =
  Transpose /@ 
    Join[
      Permutations[ Transpose[ {HIC1,AIC1} ] ],
      Permutations[ Transpose[ {AIC1,HIC1} ] ]
      ]

monomial[var_List, exp_List] := Times @@ Flatten[ var^exp ]

polyFromMatrix[ exp_List ]:= Total[monomial[#, exp] & /@ ICorders]

kkpolynomials = polyFromMatrix /@ kkpolys


(* given a polynomial, construct the N1 x N1 matrix qq, which
   includes as blocks the polynomial, its holomorphic and antiholomorphic 
   gradients, and its Hessian *)

makeqq[poly_] := (
 lastrow = Append[D[poly, {AIC}], poly];
 Append[Transpose[D[lastrow, {HIC}]], lastrow]
 )

(* Compute the values of Q and qq from a set of points. The indices on Q are: alpha, point. The indices on qq are: l, a, \bar b, point. In our tests, compiling the computation of qq sped up the calculation significantly (factor of 2 or 3). *)

HICComplex = ( {#,_Complex} & ) /@ HIC

conj = Thread[ AIC -> Co[ HIC ] ]

Qfunc = Compile[
  Evaluate[ HICComplex ],
  Evaluate[ Q ]
  ]

qqfunc = Compile[
  Evaluate[ HICComplex ],
  Evaluate[ ( makeqq /@ kkpolynomials ) /. conj ]
  ]

calcData[points_List]:= {
  Transpose[ Qfunc @@@ points ],
  quotientBasis . Transpose[ qqfunc @@@ points , {4,1,2,3} ]
  }

(* Write and read data to and from a binary file *)

storeData[data_List,filename_String]:=
  Export[ filename, Prepend[ data, Length[data[[1,1]]] ], {"Binary", "Complex128"}]

getData[filename_String]:= (
  stream = OpenRead[ filename, BinaryFormat -> True ];
  npoints = Floor[ BinaryRead[ stream, "Complex128" ] ];
  {
    Partition[ BinaryReadList[ stream, "Complex128", (N1-1)npoints ], npoints],
    Partition[ Partition[ Partition[
      BinaryReadList[ stream, "Complex128" ],
      npoints], N1], N1
      ]
    }
  )



(* ******************************************************************************** *)

(* Section 4: Computing v and H1 *)

(* given a vector h, compute the list of values of v at the sprinkled
   points *)

Psisymb = Array[ Psitoken, {N1,N1} ]

detPsisymb = Det[Psisymb]

detinvPsisymb = Simplify[detPsisymb Inverse[Psisymb]]

calcv[h_List, {Qvals_List, qqvals_List}] := (
  Psi = h . qqvals;
  detinvPsi = Drop[detinvPsisymb,-1,-1] /. Thread[Flatten[Psisymb] -> Flatten[Psi, 1]];
  Re[
    k^(2 - N1) *
    Psi[[N1,N1]]^(1 - N1) *
    Sum[ Co[Qvals][[i]] detinvPsi[[i,j]] Qvals[[j]], {i,N1-1}, {j,N1-1} ]
   ]
  )

(* given a vector h, compute the list of values of v and D at the sprinkled
   points *)

calcvD[h_List,{Qvals_List,qqvals_List}]:= (
  Psi = h . qqvals;
  Psi2 = Transpose[Psi, {2,3,1}];
  PsiUp = Inverse /@ Psi2;
  Qvals2 = Transpose[
    Append[
      Qvals,
      ConstantArray[ 0, Dimensions[Qvals][[2]] ]
      ]
    ];
  QPsiQ = MapThread[Dot, {Co[Qvals2], PsiUp, Qvals2}];
  Re[ {
    k^(2 - N1) Psi[[N1, N1]]^(1-N1) (Det /@ Psi2) QPsiQ,
     - (N1-1) Psi[[N1, N1]]^(-1) Transpose[ qqvals[[All, N1, N1]] ] +
     Total[ PsiUp Transpose[qqvals, {4,3,2,1}], {2, 3} ] -
      MapThread[
       Dot,
       {Co[Qvals2], PsiUp, Transpose[qqvals, {3,2,4,1}], PsiUp, Qvals2}
       ] /
      QPsiQ
    } ]
  )

(* estimate of our energy functional H1 from the sample of points *)

H1[h_List,data_List] := Variance[ calcv[ h, data ] ]

(* gradient wrt h of the estimate of H1 *)

gradH1[h_List,data_List] := (
  vDvals = calcvD[ h, data ];
  2 Covariance[vDvals[[1]], #]& /@ Transpose[vDvals[[1]] vDvals[[2]]]
  )

(* gradient wrt h of the mean of v on our sample -- should go to zero as the number
   of points goes to infinity *)

gradvmean[h_List,data_List]:= (
  vDvals = calcvD[ h, data ];
  Mean[ vDvals[[1]] vDvals[[2]] ]
 )

(* given h, returns the mean value of v, its variance, and the estimated error on
   the mean *)

ShortSummary[h_List,data_List] := ( 
  vvals = calcv[ h, data ];
  {
    Mean[vvals],
    Variance[vvals],
    (Variance[vvals] / Length[vvals])^(1/2)
    }
  )

(* given h, returns a histogram of values of v, the mean value, its variance,
   the estimated error on the mean, and the norm of the gradient of the variance
   wrt h *)

LongSummary[h_List,data_List] := (
  vDvals = calcvD[ h, data ];
  vvals = vDvals[[1]];
  {
    Histogram[vvals],
    Mean[vvals],
    Variance[vvals],
    (Variance[vvals] / Length[vvals])^(1/2),
    Norm[ 2 Covariance[vvals, #]& /@ Transpose[vvals vDvals[[2]]] ]
    }
  )



(* ******************************************************************************** *)

(* Section 5: Removing the zero-mode and volume-normalizing *)

(* In minimizing H1, we will need to remove the zero-mode from multiplying h by a constant. We do this by fixing the polynomial represented by h to equal 1 at the origin of the patch, i.e. $u_\alpha = 0$. (Of course, this point does not lie on the Calabi-Yau.) The vector poly0 is the value of the polynomial $\mathcal{P}^l$ at that point, in other words poly0.h is the value of the polynomial represented by h. *)

poly0 = quotientBasis.(kkpolynomials /. Thread[ Join[HIC,AIC] -> Table[0,{2N1-2}] ])

(* j is the position at which n is the greatest. This is the coordinate in the space of polynomials that we will remove as we set poly0.h = 1. *)

j = Ordering[ Abs[poly0], -1 ][[1]]

(* Actually, it will be convenient to normalize n so poly0[[j]] = 1. *)

poly0 = poly0 / poly0[[j]]

poly0g = Drop[ poly0, {j} ]

(* Convert from g to h and vice versa. *)

hFromg[g_List]:= Insert[ g, 1 - poly0g.g, j ]

gFromh[h_List]:= Drop[ h, {j} ] / (poly0.h)

gDerivFromhDeriv[hDeriv_List]:= Drop[ hDeriv, {j} ] - poly0g hDeriv[[j]]


(* The actual polynomial p in terms of g *)

p[g_List]:= hFromg[g].quotientBasis.kkpolynomials


(* mean of v, H1, and derivative of H1 in terms of g rather than h. *)

vmean[g_List,data_List]:= Mean[ calcv[ hFromg[g], data ] ]

H1g[g_List,data_List]:= H1[ hFromg[g], data ]

gradH1g[g_List,data_List]:= gDerivFromhDeriv[ gradH1[ hFromg[g], data ] ]


(* Volume-normalized v, H1, and sigma *)

scalemean[l_List]:= l / Mean[l]

eta[g_List,data_List]:= scalemean[ calcv[ hFromg[g], data ] ]

EE[g_List,data_List]:= Variance[ eta[ g, data ] ]

sigma[g_List,data_List]:= MeanDeviation[ eta[ g, data ] ]



(* ******************************************************************************** *)

(* Section 6: Computing the vector h representing the Fubini-Study Kahler potential. *)

zs = Array[ zzb, N1 ]

FSz = Expand[ Total[zs]^k ]

kkcoeff[mono_List] := 
  Length[ Permutations[mono] ] *
    Coefficient[ FSz, Times @@ (zs^mono) ] *
    whichkkpoly[ { mono, mono } ]

FSvec = Total[ kkcoeff /@ OrderedPolysk ]

hFS =
  N[ Take [ LinearSolve[ Transpose[Join[quotientBasis,zeroBasis]], FSvec ], M ] ]

gFS = gFromh[hFS]



(* ******************************************************************************** *)

(* Section 7: Minimizing the functional by Levenberg-Marquardt, supplying the Jacobian *)


subtractMean[v_List]:= v - Mean[v]

jac[g_List, data_List] := (
  vDvals = calcvD[ hFromg[ g ], data ];
  jach = vDvals[[1]] vDvals[[2]];
  meanzero = Transpose[jach] - Mean[jach];
  Transpose[ Drop[meanzero,{j}] - Outer[Times,poly0g,meanzero[[j]]] ]
  )

minimize[gstart_List,data_List]:=
  FindMinimum[
    standin,
    { g, gstart },
    Method -> {
      "LevenbergMarquardt",
      "Residual" -> subtractMean[ calcv[hFromg[g],data] ],
      "Jacobian" -> jac[ g, data ]
      }
    ][[2,1,2]]


(* ******************************************************************************** *)

(* Section 8: Computing $\hat E$ *)

(* calcI computes the values of the integrand for $\hat E$, $I \equiv g^{\bar j i}\partial_i\ln\eta\partial_{\bar j}\ln\eta$. Ehat gives the mean value of the integrand over the given points. *)

(* Note, however, that the metric used to compute the integrand is not the volume-normalized one. So to obtain the value of $\hat E$ for the volume-normalized metric, you have to multiply the output of Ehat by the output of vmean to the 1/(N1-2) power. *)

outer[a__List] := Outer[Times, a]

outerList[a__List] := MapThread[ outer, {a} ]

DotList[a__List] := MapThread[ Dot, {a} ]

Qagfunc = Compile[
  Evaluate[ HICComplex ],
  Evaluate[ D[Q,{HIC}] ]
  ]

calcI[g:{__Real},points_List]:= (
  psialg = p[g];
  psifunc = Compile[
    Evaluate[ HICComplex ],
    Evaluate[ psialg /. conj ]
    ];
  psiafunc = Compile[
    Evaluate[ HICComplex ],
    Evaluate[ D[psialg,{HIC}] /. conj ]
    ];
  psiagfunc = Compile[
    Evaluate[ HICComplex ],
    Evaluate[ D[psialg,{HIC},{HIC} ] /. conj ]
    ];
  psiabfunc = Compile[
    Evaluate[ HICComplex ],
    Evaluate[ D[psialg,{HIC},{AIC}] /. conj ]
    ];
  psiagbfunc = Compile[
    Evaluate[ HICComplex ],
    Evaluate[ D[psialg,{HIC},{HIC},{AIC}] /. conj ]
    ];
  psi = Re [ psifunc @@@ points ];
  psia = ( psiafunc @@@ points ) / psi;
  cpsia = Co[ psia ];
  psiag = ( psiagfunc @@@ points ) / psi;
  psiab = ( psiabfunc @@@ points ) / psi;
  psiagb = ( psiagbfunc @@@ points ) / psi;
  ghatab = 1/k ( psiab - outerList[ psia, cpsia ] );
  psiapsigb = outerList[ psia, psiab ];
  ghatagb =
    1/k (
      psiagb
       - psiapsigb
       - Transpose[ psiapsigb, {1,3,2} ]
       - outerList[ psiag, cpsia ]
       + 2 outerList[ psia, psia, cpsia ]
    );
  ghatup = Inverse /@ ghatab;
  Qa = Qfunc @@@ points;
  Qag = Qagfunc @@@ points;
  Qb = DotList[ ghatup, Qa ];
  Q2 = Re[ DotList[ Qb, Co[Qa] ] ];
  gtilde = ghatup - outerList[ Qb, Co[Qb] ] / Q2;
  daf = Map[ Tr, DotList[ ghatagb, gtilde ], {2} ] + DotList[ Qag, Co[Qb] ] / Q2;
  Re[ DotList[ Co[daf], gtilde, daf ] ]
  )

Ehat[ g:{__Real}, points_List ]:= Mean[ calcI[ g, points ] ]