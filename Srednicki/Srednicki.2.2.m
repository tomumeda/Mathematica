(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Needs["TensorCalculus4V6`Tensorial`"]
Needs["QuantumAlgebra`QuantumAlgebra`"]
Needs["Combinatorica`"]
<<Local`LocalFunctions`
IntegrateSumFunctions


Unprotect[Dot];
Dot[a___,1,c___]:=Dot[a,c]
Dot[a___,0,c___]:=0
Dot[a___,b_+c_,d___]:=Dot[a,b,d]+Dot[a,c,d]
Protect[Dot];
dotExtract[x_]:=Dot[a___,x,b___]->x Dot[a,b]

dotKeep[clist_][seq_]:=
(*Keeps under Dot items in clist.*)
Module[{tmp=seq,i,j,member,tmpd={},tmps={1}},
List[seq];
For[i=1,i<=Length[seq],i++,
List[seq[[i]]//FullForm," : ",clist];
For[j=1,j<=Length[clist],j++,
List[seq[[i]]//FullForm," =?= ",clist[[j]]];
member=False;
If[ MemberQ[{seq[[i]]},clist[[j]]]||
seq[[i]]=== clist[[j]]
,
member=True; j=Length[clist]+1
];
];
If[ member,
AppendTo[ tmpd,seq[[i]]];,
AppendTo[ tmps,seq[[i]]];
]
List[">>",tmpd,tmps];
];
tmp=Null;
If[Length[tmps]>0,
tmp=Apply[Times,tmps]];
If[Length[tmpd]>0,
tmp=tmp Apply[Dot,tmpd]];
List["dotKeep: ",tmp];
tmp
]
dotRetain[clist_,exp_]:=
(*Keeps clist items under Dot in expression.  This routine is taking advantage of the Dot function to keep variables noncommuting.  A pattern would be useful in clist.  *)
Module[{tmp=exp,i},
List["dotRetain: ",tmp];
tmp=tmp/.Times->Dot;
tmp=tmp/.Dot->xDot;
List["dotRetain0: ",tmp];
tmp=tmp//.xDot[a___]:>dotKeep[clist][{a}]/;!MemberQ[{a},xDot,99,Heads->True];
List["dotRetain1:",tmp];
tmp
]

tmp=f  Dot[f[a],b,g Dot[c,h Muu[i,j]],NN]==0
dotRetain[{c,f[a],Tensor[M,__],NN},tmp]


Indices4D={0,1,2,3};
DeclareIndexFlavor[{field,Red}]
DeclareIndexFlavor[{space,Orange}]
DeclareBaseIndices[Indices4D,{field,{1,2}},{space,{1,2,3}}]
DefineTensorShortcuts[{{x,y,dx,\[Xi],b,r,zero,\[CurlyPhi],\[Psi],\[Psi]c,J,K,P,a},1},{{x,g,\[Delta] ,\[Sigma],zero,\[Omega],\[Omega]1,\[Omega]2,\[Omega]s,\[Omega]a,\[Eta],\[CapitalLambda],A,B,M,\[Delta]\[Omega],\[Delta]\[Alpha]},2},{{\[CapitalGamma],\[Epsilon]},3}]
labels = {x,\[Delta],g, \[CapitalGamma]};
DeclareZeroTensor[zero]
TensorLabelFormat[zero,0]

SetTensorValues[\[Delta]ud[i,j],IdentityMatrix[4]]
\[Delta]ud[i,j];
%//EinsteinArray[]//MatrixForm
SetTensorValues[\[Eta]ud[i,j],DiagonalMatrix[{-1,1,1,1}]]
SetTensorValues[\[Eta]uu[i,j],DiagonalMatrix[{-1,1,1,1}]]
SetTensorValues[\[Eta]dd[i,j],DiagonalMatrix[{-1,1,1,1}]]
CompleteBaseIndices



