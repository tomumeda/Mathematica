e[2] = xSum[If[i == 0, -1, 1]*Tensor[X, {i}, {Global`Void}]^2, {i, 0, d}] -> 
     L^2
 
e[9] = {Tensor[X, {0}, {Global`Void}] -> T, Tensor[X, {1}, {Global`Void}] -> 
      X, Tensor[X, {2}, {Global`Void}] -> Y, Tensor[X, {3}, {Global`Void}] -> 
      Z, Tensor[X, {4}, {Global`Void}] -> W, -T^2 + W^2 + X^2 + Y^2 + Z^2 -> 
      L^2, Tensor[X, {1}, {Global`Void}] -> r*Cos[\[CurlyPhi]]*Sin[\[Theta]], 
     Tensor[X, {2}, {Global`Void}] -> r*Sin[\[Theta]]*Sin[\[CurlyPhi]], 
     Tensor[X, {3}, {Global`Void}] -> r*Cos[\[Theta]], 
     Tensor[X, {i}, {Global`Void}] -> r*Tensor[\[Omega], {i}, {Global`Void}], 
     r^2 -> Tensor[X, {1}, {Global`Void}]^2 + Tensor[X, {2}, {Global`Void}]^
        2 + Tensor[X, {3}, {Global`Void}]^2, L^2 -> r^2 - T^2 + W^2}
 
e[9.1] = Subscript[dS, 4] -> -Tensor[X, {0}, {Global`Void}]^2 + 
       Tensor[X, {1}, {Global`Void}]^2 + Tensor[X, {2}, {Global`Void}]^2 + 
       Tensor[X, {3}, {Global`Void}]^2 + Tensor[X, {4}, {Global`Void}]^2 -> 
      L^2
 
e[9.11] = Subscript[dS, 4] -> r^2 - Tensor[X, {0}, {Global`Void}]^2 + 
       Tensor[X, {4}, {Global`Void}]^2 -> L^2
 
e[10] = {}
 
e[10.1] = First[{}]
 
e[10.11] = {First[{}], d[Subscript[\[CapitalOmega], 3]]^2 -> First[{}][[2]], 
     r -> L*Sin[\[Psi]]}
 
e[11] = 
    {d[s]^2 -> (-(Cosh[\[Psi]]*d[t] - t*(d[\[Theta]]^(-2) + Csc[\[Theta]]^
                2/d[\[CurlyPhi]]^2)^2*d[\[Psi]]*Sqrt[-d[\[Psi]]^2 + 
              d[Subscript[H, 3]]^2])^2 + d[$dum$4741]^2*
         Derivative[1][Tensor[X, {1}, {Global`Void}]][$dum$4741]^2 + 
        d[$dum$4741]^2*Derivative[1][Tensor[X, {2}, {Global`Void}]][
           $dum$4741]^2 + d[$dum$4741]^2*
         Derivative[1][Tensor[X, {3}, {Global`Void}]][$dum$4741]^2 - 
        (L^2*d[-1] - L*d[L] - d[-1]*Tensor[X, {1}, {Global`Void}]^2 - 
           d[-1]*Tensor[X, {2}, {Global`Void}]^2 - 
           d[-1]*Tensor[X, {3}, {Global`Void}]^2 + d[$dum$4741]*
            Tensor[X, {1}, {Global`Void}]*Derivative[1][Tensor[X, {1}, {
                Global`Void}]][$dum$4741] + d[$dum$4741]*Tensor[X, {2}, 
             {Global`Void}]*Derivative[1][Tensor[X, {2}, {Global`Void}]][
             $dum$4741] + d[$dum$4741]*Tensor[X, {3}, {Global`Void}]*
            Derivative[1][Tensor[X, {3}, {Global`Void}]][$dum$4741])^2/
         (-L^2 + Tensor[X, {1}, {Global`Void}]^2 + 
          Tensor[X, {2}, {Global`Void}]^2 + Tensor[X, {3}, {Global`Void}]^
           2) /. First[{}]), d[Subscript[H, 3]]^2 -> 
      d[\[Psi]]^2 + d[Subscript[\[CapitalOmega], 2]]^2*Sinh[\[Psi]]^2, 
     {Tensor[X, {0}, {Global`Void}] -> t*Cosh[\[Psi]], r -> t*Sinh[\[Psi]]}}
 
e[13] = {d[s]^2 -> (-(L*Cosh[\[Psi]]*d[\[Theta]]*Sec[\[Theta]]^2 - 
           L*(d[\[Theta]]^(-2) + Csc[\[Theta]]^2/d[\[CurlyPhi]]^2)^2*
            d[\[Psi]]*Tan[\[Theta]]*Sqrt[-d[\[Psi]]^2 + d[$dum$4928]^2*
               Derivative[1][Subscript[H, 3]][$dum$4928]^2])^2 + 
        d[$dum$4741]^2*Derivative[1][Tensor[X, {1}, {Global`Void}]][
           $dum$4741]^2 + d[$dum$4741]^2*
         Derivative[1][Tensor[X, {2}, {Global`Void}]][$dum$4741]^2 + 
        d[$dum$4741]^2*Derivative[1][Tensor[X, {3}, {Global`Void}]][
           $dum$4741]^2 - (L^2*d[-1] - d[-1]*Tensor[X, {1}, {Global`Void}]^
             2 - d[-1]*Tensor[X, {2}, {Global`Void}]^2 - 
           d[-1]*Tensor[X, {3}, {Global`Void}]^2 + d[$dum$4741]*
            Tensor[X, {1}, {Global`Void}]*Derivative[1][Tensor[X, {1}, {
                Global`Void}]][$dum$4741] + d[$dum$4741]*Tensor[X, {2}, 
             {Global`Void}]*Derivative[1][Tensor[X, {2}, {Global`Void}]][
             $dum$4741] + d[$dum$4741]*Tensor[X, {3}, {Global`Void}]*
            Derivative[1][Tensor[X, {3}, {Global`Void}]][$dum$4741])^2/
         (-L^2 + Tensor[X, {1}, {Global`Void}]^2 + 
          Tensor[X, {2}, {Global`Void}]^2 + Tensor[X, {3}, {Global`Void}]^
           2) /. First[{}]), t -> L*Tan[\[Theta]]}
 
e[14] = {r -> L*Sinh[\[Psi]]*Tan[\[Theta]], 
     r -> Sqrt[Tensor[X, {1}, {Global`Void}]^2 + 
        Tensor[X, {2}, {Global`Void}]^2 + Tensor[X, {3}, {Global`Void}]^2], 
     L*Cosh[\[Psi]]*Tan[\[Theta]] -> T}
 
e[15] = d[s]^2 -> (-(L*Cosh[\[Rho]]*Cosh[\[Psi]]*d[\[Rho]] - 
          (L*Cosh[\[Rho]]*Coth[\[Rho]]^3*d[\[Psi]]*
            (d[\[Rho]]^2 + d[\[CurlyPhi]]^2*Sinh[\[Rho]]^2)^2*
            Sqrt[-d[\[Psi]]^2 + d[$dum$4928]^2*Derivative[1][Subscript[H, 3]][
                 $dum$4928]^2])/(d[\[Rho]]^4*d[\[CurlyPhi]]^4))^2 + 
       d[$dum$4741]^2*Derivative[1][Tensor[X, {1}, {Global`Void}]][$dum$4741]^
         2 + d[$dum$4741]^2*Derivative[1][Tensor[X, {2}, {Global`Void}]][
          $dum$4741]^2 + d[$dum$4741]^2*
        Derivative[1][Tensor[X, {3}, {Global`Void}]][$dum$4741]^2 - 
       (L^2*d[-1] - d[-1]*Tensor[X, {1}, {Global`Void}]^2 - 
          d[-1]*Tensor[X, {2}, {Global`Void}]^2 - 
          d[-1]*Tensor[X, {3}, {Global`Void}]^2 + d[$dum$4741]*
           Tensor[X, {1}, {Global`Void}]*Derivative[1][Tensor[X, {1}, 
              {Global`Void}]][$dum$4741] + d[$dum$4741]*Tensor[X, {2}, 
            {Global`Void}]*Derivative[1][Tensor[X, {2}, {Global`Void}]][
            $dum$4741] + d[$dum$4741]*Tensor[X, {3}, {Global`Void}]*
           Derivative[1][Tensor[X, {3}, {Global`Void}]][$dum$4741])^2/
        (-L^2 + Tensor[X, {1}, {Global`Void}]^2 + 
         Tensor[X, {2}, {Global`Void}]^2 + Tensor[X, {3}, {Global`Void}]^
          2) /. First[{}])
 
e[16] = {t -> L*Sinh[\[Rho]], r -> L*Sinh[\[Rho]]*Sinh[\[Psi]], 
     r -> Sqrt[Tensor[X, {1}, {Global`Void}]^2 + 
        Tensor[X, {2}, {Global`Void}]^2 + Tensor[X, {3}, {Global`Void}]^2], 
     T -> L*Cosh[\[Psi]]*Sinh[\[Rho]]}
 
e[18] = d[s]^2 -> L^2*(-d[t]^2 + Cosh[t]^2*d[$dum$6038]^2*
        Derivative[1][Subscript[\[CapitalOmega], 3]][$dum$6038]^2)
 
e[20] = {\[Rho] -> L*Sin[\[Psi]], d[s]^2 -> L^2*d[\[Psi]]^2*Sin[\[Psi]]^2 - 
        (L*Cosh[\[Chi]]*d[\[Chi]]*Sin[\[Psi]] + L*Cos[\[Psi]]*d[\[Psi]]*
           Sinh[\[Chi]])^2 + d[$dum$6375]^2*Derivative[1][Subscript[s, 3]][
           $dum$6375]^2 /. Last[{}]}
 
e[22] = {{t, r, \[Theta], \[CurlyPhi]}[Style["planar coordinates", 
       RGBColor[0, 2/3, 0], FontFamily -> "Helvetica"]], 
     Tensor[X, {0}, {Global`Void}] -> L*((E^t*r^2)/2 + Sinh[t]), 
     Tensor[X, {i}, {Global`Void}] -> E^t*L*r*Tensor[\[Omega], {i}, 
        {Global`Void}], Tensor[X, {4}, {Global`Void}] -> 
      L*(-(E^t*r^2)/2 + Cosh[t]), Tensor[\[Omega], {1}, {Global`Void}] -> 
      Cos[\[CurlyPhi]]*Sin[\[Theta]], Tensor[\[Omega], {2}, {Global`Void}] -> 
      Sin[\[Theta]]*Sin[\[CurlyPhi]], Tensor[\[Omega], {3}, {Global`Void}] -> 
      Cos[\[Theta]], r^2 -> Tensor[x, {1}, {Global`Void}]^2 + 
       Tensor[x, {2}, {Global`Void}]^2 + Tensor[x, {3}, {Global`Void}]^2, 
     Tensor[x, {i}, {Global`Void}] -> r*Tensor[\[Omega], {i}, {Global`Void}]}
 
e[23] = d[s]^2 -> L^2*(-d[t]^2 + 
       (E^(2*t)*(d[\[Theta]]^2*Tensor[x, {1}, {Global`Void}]^4 + 
          d[\[CurlyPhi]]^2*Sin[\[Theta]]^2*Tensor[x, {1}, {Global`Void}]^4 + 
          2*d[\[Theta]]^2*Tensor[x, {1}, {Global`Void}]^2*
           Tensor[x, {2}, {Global`Void}]^2 + 2*d[\[CurlyPhi]]^2*
           Sin[\[Theta]]^2*Tensor[x, {1}, {Global`Void}]^2*
           Tensor[x, {2}, {Global`Void}]^2 + d[\[Theta]]^2*
           Tensor[x, {2}, {Global`Void}]^4 + d[\[CurlyPhi]]^2*Sin[\[Theta]]^2*
           Tensor[x, {2}, {Global`Void}]^4 + 2*d[\[Theta]]^2*
           Tensor[x, {1}, {Global`Void}]^2*Tensor[x, {3}, {Global`Void}]^2 + 
          2*d[\[CurlyPhi]]^2*Sin[\[Theta]]^2*Tensor[x, {1}, {Global`Void}]^2*
           Tensor[x, {3}, {Global`Void}]^2 + 2*d[\[Theta]]^2*
           Tensor[x, {2}, {Global`Void}]^2*Tensor[x, {3}, {Global`Void}]^2 + 
          2*d[\[CurlyPhi]]^2*Sin[\[Theta]]^2*Tensor[x, {2}, {Global`Void}]^2*
           Tensor[x, {3}, {Global`Void}]^2 + d[\[Theta]]^2*
           Tensor[x, {3}, {Global`Void}]^4 + d[\[CurlyPhi]]^2*Sin[\[Theta]]^2*
           Tensor[x, {3}, {Global`Void}]^4 - 2*r*d[r]*d[t]*
           (Tensor[x, {1}, {Global`Void}]^2 + Tensor[x, {2}, {Global`Void}]^
             2 + Tensor[x, {3}, {Global`Void}]^2) - 
          d[t]^2*(r^2 - Tensor[x, {1}, {Global`Void}]^2 - 
            Tensor[x, {2}, {Global`Void}]^2 - Tensor[x, {3}, {Global`Void}]^
             2)*(Tensor[x, {1}, {Global`Void}]^2 + 
            Tensor[x, {2}, {Global`Void}]^2 + Tensor[x, {3}, {Global`Void}]^
             2) + d[$dum$6637]^2*Tensor[x, {1}, {Global`Void}]^2*
           Derivative[1][Tensor[x, {1}, {Global`Void}]][$dum$6637]^2 + 
          2*d[$dum$6637]^2*Tensor[x, {1}, {Global`Void}]*Tensor[x, {2}, 
            {Global`Void}]*Derivative[1][Tensor[x, {1}, {Global`Void}]][
            $dum$6637]*Derivative[1][Tensor[x, {2}, {Global`Void}]][
            $dum$6637] + d[$dum$6637]^2*Tensor[x, {2}, {Global`Void}]^2*
           Derivative[1][Tensor[x, {2}, {Global`Void}]][$dum$6637]^2 + 
          2*d[$dum$6637]^2*Tensor[x, {1}, {Global`Void}]*Tensor[x, {3}, 
            {Global`Void}]*Derivative[1][Tensor[x, {1}, {Global`Void}]][
            $dum$6637]*Derivative[1][Tensor[x, {3}, {Global`Void}]][
            $dum$6637] + 2*d[$dum$6637]^2*Tensor[x, {2}, {Global`Void}]*
           Tensor[x, {3}, {Global`Void}]*Derivative[1][Tensor[x, {2}, 
              {Global`Void}]][$dum$6637]*Derivative[1][Tensor[x, {3}, 
              {Global`Void}]][$dum$6637] + d[$dum$6637]^2*
           Tensor[x, {3}, {Global`Void}]^2*
           Derivative[1][Tensor[x, {3}, {Global`Void}]][$dum$6637]^2 + 
          2*d[t]*d[$dum$6637]*(Tensor[x, {1}, {Global`Void}]^2 + 
            Tensor[x, {2}, {Global`Void}]^2 + Tensor[x, {3}, {Global`Void}]^
             2)*(Tensor[x, {1}, {Global`Void}]*Derivative[1][Tensor[x, {1}, 
                {Global`Void}]][$dum$6637] + Tensor[x, {2}, {Global`Void}]*
             Derivative[1][Tensor[x, {2}, {Global`Void}]][$dum$6637] + 
            Tensor[x, {3}, {Global`Void}]*Derivative[1][Tensor[x, {3}, 
                {Global`Void}]][$dum$6637])))/(Tensor[x, {1}, {Global`Void}]^
          2 + Tensor[x, {2}, {Global`Void}]^2 + Tensor[x, {3}, {Global`Void}]^
          2))
 
e[26] = d[s]^2 -> (2*H^2*r*u*d[r]*d[u] - d[u]^2*(H^2*r^2 + H^2*u^2 - 
         Tensor[x, {1}, {Global`Void}]^2 - Tensor[x, {2}, {Global`Void}]^2 - 
         Tensor[x, {3}, {Global`Void}]^2) - 2*u*d[u]*d[$dum$6637]*
        (Tensor[x, {1}, {Global`Void}]*Derivative[1][Tensor[x, {1}, 
             {Global`Void}]][$dum$6637] + Tensor[x, {2}, {Global`Void}]*
          Derivative[1][Tensor[x, {2}, {Global`Void}]][$dum$6637] + 
         Tensor[x, {3}, {Global`Void}]*Derivative[1][Tensor[x, {3}, 
             {Global`Void}]][$dum$6637]) + 
       (u^2*(d[\[Theta]]^2*(Tensor[x, {1}, {Global`Void}]^2 + 
             Tensor[x, {2}, {Global`Void}]^2 + Tensor[x, {3}, {Global`Void}]^
              2)^2 + d[\[CurlyPhi]]^2*Sin[\[Theta]]^2*
           (Tensor[x, {1}, {Global`Void}]^2 + Tensor[x, {2}, {Global`Void}]^
              2 + Tensor[x, {3}, {Global`Void}]^2)^2 + d[$dum$6637]^2*
           (Tensor[x, {1}, {Global`Void}]*Derivative[1][Tensor[x, {1}, 
                 {Global`Void}]][$dum$6637] + Tensor[x, {2}, {Global`Void}]*
              Derivative[1][Tensor[x, {2}, {Global`Void}]][$dum$6637] + 
             Tensor[x, {3}, {Global`Void}]*Derivative[1][Tensor[x, {3}, 
                 {Global`Void}]][$dum$6637])^2))/
        (Tensor[x, {1}, {Global`Void}]^2 + Tensor[x, {2}, {Global`Void}]^2 + 
         Tensor[x, {3}, {Global`Void}]^2))/(H^4*u^4)
 
e[34] = {T -> Sqrt[L^2 - r^2]*Sinh[t], W -> Sqrt[L^2 - r^2]*Cosh[t]}[
     Style["e[34] static coordinate system", RGBColor[0, 2/3, 0], 
      FontFamily -> "Helvetica"]]
 
e[35] = {d[s]^2 -> d[r]^2 + r^2*d[Subscript[\[CapitalOmega], 2]]^2 + 
        d[$dum$8927]^2*(Derivative[1][Sqrt[L^2 - r^2]*Cosh[t]][$dum$8927]^2 - 
          Derivative[1][Sqrt[L^2 - r^2]*Sinh[t]][$dum$8927]^2)}[
     Style["e[35] metric", RGBColor[0, 2/3, 0], FontFamily -> "Helvetica"]]
 
e[37] = {d[s]^2 -> d[r]^2 + r^2*d[Subscript[\[CapitalOmega], 2]]^2 + 
       d[$dum$8927]^2*(Derivative[1][Sqrt[1 - r^2]*Cosh[t]][$dum$8927]^2 - 
         Derivative[1][Sqrt[1 - r^2]*Sinh[t]][$dum$8927]^2)}
 
e[40] = d[s]^2 -> d[(1 + U*V)/(1 - U*V)]^2 + 
      ((1 + U*V)^2*d[Subscript[\[CapitalOmega], 2]]^2)/(-1 + U*V)^2 + 
      d[$dum$8927]^2*(Derivative[1][2*Sqrt[-((U*V)/(-1 + U*V)^2)]*Cosh[t]][
          $dum$8927]^2 - Derivative[1][2*Sqrt[-((U*V)/(-1 + U*V)^2)]*Sinh[t]][
          $dum$8927]^2)
 
e[52] = Tensor[X, {M}, {Global`Void}]*Tensor[X, {N}, {Global`Void}]*
      Tensor[\[Eta], {Global`Void, Global`Void}, {M, N}] -> 
     -Tensor[X, {0}, {Global`Void}]^2 + Tensor[X, {d}, {Global`Void}]^2 + 
      xSum[Tensor[X, {i}, {Global`Void}]^2, {i, -1 + d}]
 
e[53] = {CommutatorM[Tensor[J, {Global`Void, Global`Void}, {M, N}][
         Style["rotation generator", RGBColor[0, 2/3, 0], 
          FontFamily -> "Helvetica"]], Tensor[J, {Global`Void, Global`Void}, 
         {P, Q}]] -> I*(Tensor[J, {Global`Void, Global`Void}, {N, Q}]*
          Tensor[\[Eta], {Global`Void, Global`Void}, {M, P}] - 
         Tensor[J, {Global`Void, Global`Void}, {N, P}]*Tensor[\[Eta], 
           {Global`Void, Global`Void}, {M, Q}] - 
         Tensor[J, {Global`Void, Global`Void}, {M, Q}]*Tensor[\[Eta], 
           {Global`Void, Global`Void}, {N, P}] + 
         Tensor[J, {Global`Void, Global`Void}, {M, P}]*Tensor[\[Eta], 
           {Global`Void, Global`Void}, {N, Q}]), Element[{M | N | P | Q}, 
       {0, \[Ellipsis], d}]}[Style["e[53] Lie algebra of SO[d,1]", 
      RGBColor[0, 2/3, 0], FontFamily -> "Helvetica"]]
 
e[55] = {{Tensor[P, {Global`Void}, {i}] -> 
         Tensor[J, {Global`Void, Global`Void}, {d, i}] + 
          Tensor[J, {Global`Void, Global`Void}, {i, 0}]}[
       Style["translation", RGBColor[0, 2/3, 0], FontFamily -> "Helvetica"]], 
      {D -> Tensor[J, {Global`Void, Global`Void}, {d, 0}]}[
       Style["dilation", RGBColor[0, 2/3, 0], FontFamily -> "Helvetica"]], 
      {Tensor[K, {Global`Void}, {i}] -> 
         -Tensor[J, {Global`Void, Global`Void}, {d, i}] + 
          Tensor[J, {Global`Void, Global`Void}, {i, 0}]}[
       Style["conformal", RGBColor[0, 2/3, 0], FontFamily -> "Helvetica"]], 
      CommutatorM[Tensor[P, {Global`Void}, {i}], Tensor[P, {Global`Void}, 
         {j}]] -> 0, CommutatorM[Tensor[K, {Global`Void}, {i}], 
        Tensor[K, {Global`Void}, {j}]] -> 0, 
      CommutatorM[D, Tensor[P, {Global`Void}, {i}]] -> 
       (-I)*Tensor[P, {Global`Void}, {i}], 
      CommutatorM[D, Tensor[J, {Global`Void, Global`Void}, {i, j}]] -> 0, 
      CommutatorM[D, Tensor[K, {Global`Void}, {i}]] -> 
       I*Tensor[K, {Global`Void}, {i}], 
      CommutatorM[Tensor[J, {Global`Void, Global`Void}, {i, j}], 
        Tensor[P, {Global`Void}, {k}]] -> 
       I*(Tensor[P, {Global`Void}, {j}]*Tensor[\[Delta], {Global`Void, 
            Global`Void}, {i, k}] - Tensor[P, {Global`Void}, {i}]*
          Tensor[\[Delta], {Global`Void, Global`Void}, {j, k}]), 
      CommutatorM[Tensor[J, {Global`Void, Global`Void}, {i, j}], 
        Tensor[K, {Global`Void}, {k}]] -> 
       I*(Tensor[K, {Global`Void}, {j}]*Tensor[\[Delta], {Global`Void, 
            Global`Void}, {i, k}] - Tensor[P, {Global`Void}, {i}]*
          Tensor[\[Delta], {Global`Void, Global`Void}, {j, k}]), 
      CommutatorM[Tensor[P, {Global`Void}, {i}], Tensor[K, {Global`Void}, 
         {j}]] -> (-2*I)*Tensor[J, {Global`Void, Global`Void}, {i, j}] + 
        (2*I)*D*Tensor[\[Delta], {Global`Void, Global`Void}, {i, j}]}[
     Style["d(d+1)/2 SO[d,1] generators e[55]", RGBColor[0, 2/3, 0], 
      FontFamily -> "Helvetica"]]
 
e[a3] = {Tensor[X, {M}, {Global`Void}][Style["embedding space", 
       RGBColor[0, 2/3, 0], FontFamily -> "Helvetica"]], 
     {X \[CenterDot] X -> Tensor[X, {M}, {Global`Void}]*Tensor[X, {N}, 
           {Global`Void}]*Tensor[\[Eta], {Global`Void, Global`Void}, 
           {M, N}] -> 1}[Style["constraint", RGBColor[0, 2/3, 0], 
       FontFamily -> "Helvetica"]], 
     {Inactive[Integrate][(\[Lambda]*(-1 + Tensor[X, {M}, {Global`Void}]*
             Tensor[X, {N}, {Global`Void}]*Tensor[\[Eta], {Global`Void, 
               Global`Void}, {M, N}]))/2 + 
         (Tensor[\[Eta], {Global`Void, Global`Void}, {M, N}]*
           tuDDown["\[PartialD]"][Tensor[X, {M}, {Global`Void}], \[Zeta]]*
           tuDDown["\[PartialD]"][Tensor[X, {N}, {Global`Void}], \[Zeta]])/2, 
        \[Zeta]]}[Style["extremizing integral", RGBColor[0, 2/3, 0], 
       FontFamily -> "Helvetica"]]}
 
Attributes[Subscript] = {NHoldRest}
 
Attributes[$dum$8927] = {Temporary}
 
Attributes[Derivative] = {NHoldAll, ReadProtected}
 
Attributes[$dum$4928] = {Temporary}
 
Attributes[$dum$4741] = {Temporary}
 
T[A_, uds_String][index0__] := Module[{tmp, ud = Characters[uds], 
      index = {index0}}, If[Cases[ud, Except["u" | "d"]] === {} && 
       (tmp = Which[Head[index] === List && Length[ud] == Length[index], 
          Tensor[A, MapThread[If[#1 === "u", #2, Global`Void] & , 
            {ud, index}], MapThread[If[#1 === "d", #2, Global`Void] & , 
            {ud, index}]], ud === {"u"}, Tensor[A, {index}, {Global`Void}], 
          ud === {"d"}, Tensor[A, {Global`Void}, {index}], True, -1]) =!= -1, 
      tmp, Style[Tensor[A, uds, index], FontColor -> Red]]]
 
T[A_, up_List, down_List] := Module[{tmp, u = up /. Null -> Global`Void, 
      d = down /. Null -> Global`Void, return}, 
     If[up == {} && down == {}, Return[Tensor[A, up, down]]]; 
      If[up == {}, u = Table[Global`Void, {Length[d]}]]; 
      If[down == {}, d = Table[Global`Void, {Length[u]}]]; 
      If[Length[d] == Length[u] && 
         !Inner[(#1 =!= Global`Void && #2 =!= Global`Void) || 
            (#1 === Global`Void && #2 === Global`Void) & , u, d, Or], 
       Tensor[A, u, d], Style[Tensor[A, up, down], FontColor -> Red]]]
 
T[A_, uds_String, index_List] := Module[{tmp, ud = Characters[uds]}, 
     If[Cases[ud, Except["u" | "d"]] === {} && 
       (tmp = Which[Head[index] === List && Length[ud] == Length[index], 
          Tensor[A, MapThread[If[#1 === "u", #2, Global`Void] & , 
            {ud, index}], MapThread[If[#1 === "d", #2, Global`Void] & , 
            {ud, index}]], ud === {"u"}, Tensor[A, {index}, {Global`Void}], 
          ud === {"d"}, Tensor[A, {Global`Void}, {index}], True, -1]) =!= -1, 
      tmp, Style[Tensor[A, uds, index], FontColor -> Red]]]
 
T /: T::usage = "T[A_,uds_String][index0__] produces any Tensor where \
uds_String specifies up/down position of index_, \
e.g.,T[Symbol,\"udd\"][i,j,k]->((\!\(\*SuperscriptBox[\(Symbol\), \
\(i\)]\)\!\(\*SubscriptBox[\()\), \(jk\)]\))"
 
tmp = -1 + E^(2*K*\[Zeta])*Tensor[a, {N}, {Global`Void}]*
       Tensor[a, {Global`Void}, {N}] + Tensor[a, {Global`Void}, {N}]*
       Tensor[b, {N}, {Global`Void}] + Tensor[a, {N}, {Global`Void}]*
       Tensor[b, {Global`Void}, {N}] + (Tensor[b, {N}, {Global`Void}]*
        Tensor[b, {Global`Void}, {N}])/E^(2*K*\[Zeta]) -> 0
 
Attributes[CenterDot] = {Flat, OneIdentity}
 
Attributes[$dum$6637] = {Temporary}
 
Attributes[$dum$6375] = {Temporary}
 
Attributes[$dum$6038] = {Temporary}
 
ee[1] = Tensor[b, {1}, {Global`Void}] -> E^(-Subscript[t, s])
 
ee[2] = Tensor[a, {1}, {Global`Void}] -> -1
 
ee[3] = Tensor[a, {0}, {Global`Void}] -> -E^(-Subscript[t, s])
 
ee[4] = Tensor[b, {0}, {Global`Void}] -> (1 + E^(-2*Subscript[t, s]))/2
 
ee[5] = Tensor[a, {4}, {Global`Void}] -> E^(-Subscript[t, s])
 
ee[6] = Tensor[b, {4}, {Global`Void}] -> 1/2 - 1/(2*E^(2*Subscript[t, s]))
 
ee[7] = \[Zeta] -> E^t
 
Attributes[ee$] = {Temporary}
 
Attributes[error$] = {Temporary}
 
evalDifferentialOps[opdef_][exp_] := Module[{$ = exp, op}, 
     $ = $ /. dd:xDot[a__] :> Fold[op, arg, Reverse[dd]]; 
      op[a_, b_] := b /. opdef[a]; $]
 
$ = {\[Zeta] -> E^t, Tensor[a, {0}, {Global`Void}] -> -E^(-Subscript[t, s]), 
     Tensor[a, {1}, {Global`Void}] -> -1, Tensor[a, {4}, {Global`Void}] -> 
      E^(-Subscript[t, s]), Tensor[b, {0}, {Global`Void}] -> 
      (1 + E^(-2*Subscript[t, s]))/2, Tensor[b, {1}, {Global`Void}] -> 
      E^(-Subscript[t, s]), Tensor[b, {4}, {Global`Void}] -> 
      1/2 - 1/(2*E^(2*Subscript[t, s]))}
 
Attributes[xDot] = {Flat, OneIdentity}
 
Attributes[exp0$] = {Temporary}
 
Attributes[exp1$] = {Temporary}
 
expand2CT[ispace_Integer, ones_][exp_] := 
    Module[{$scal, $ = exp, $1, $2 = {}, $4 = {}, $1s = ones}, 
     $ = If[Length[$] < 2, xDot[$], $]; xPrint["exp: ", $]; 
      $scal = tuExtractPattern[scal[_]][$]; xPrint["$scal: ", $scal]; 
      $scal = Times @@ $scal /. scal[a_] -> a; If[$scal =!= 1, 
       AppendTo[$2, $scal]]; $ = Select[List @@ $,  !MatchQ[#1, scal[_]] & ]; 
      While[Length[$] > 0, {$1, $} = {$[[1]], $[[2 ;; All]]}; 
        If[tuMemberQ[$1, {X[_]}], If[Length[$4] > 0, 
           AppendTo[$2, xDot @@ $4]; $4 = {}]; AppendTo[$2, $1], 
         AppendTo[$4, $1]]]; If[Length[$4] > 0, AppendTo[$2, xDot @@ $4]]; 
      $ = (ReplacePart[$1s, ispace -> #1] & ) /@ $2 /. X[a__] -> a /. toDot; 
      Dot @@ $]
 
$1 = Tensor[b, {4}, {Global`Void}] -> 1/2 + E^(-t - Subscript[t, s]) - 
      1/(2*E^(2*Subscript[t, s])) - Tensor[a, {4}, {Global`Void}]/E^t
 
$2 = E^(-Subscript[t, s]) - Tensor[a, {4}, {Global`Void}] -> 0
 
tuExtractPattern[pattern_, maxlevel_:Infinity][exp_] := 
    Module[{pos}, pos = Position[exp, pattern, {0, maxlevel}]; 
      Extract[exp, pos]]
 
tuExtractPattern /: tuExtractPattern::usage = "tuExtractPattern[pattern_,maxl\
evel_:Infinity][exp_] extracts a List of items in exp_ that match pattern_ to \
maxlevel_. *3Feb2014* "
 
tuMemberQ[patterns_][variable_] := tuMemberQ[variable, patterns]
 
tuMemberQ[variable_, patterns_] := 
    Or @@ (MemberQ[Flatten[{variable}], #1] & ) /@ Flatten[{patterns}]
 
tuMemberQ /: tuMemberQ::usage = "tuMemberQ[variable_,patterns_] True if any \
variable_ (may be List[]) matches any in patterns_ (may be List). Equivalent \
form: tuMemberQ[patterns_][variable_] *16May2015*"
 
toDot := dotOps -> Dot
 
dotOps := Dot | xDot | CenterDot | Inactive[Dot]
 
expandCom[subs_:{}][exp_] := Block[{tmp = exp}, 
     tmp = expandDot[subs][tmp //. tuCommutatorExpand]; tmp = tmp /. toxDot; 
      tmp = expandDot[toDot][tuMatrixOrderedMultiply[tmp]]; tmp]
 
expandCom /: expandCom::usage = 
     "expandCom[subs_:{}][exp_] expands Commutator expressions *22Mar2019*"
 
expandDot[sub_:{}, scalar_:{}, func_:{}, iterate_:20][exp_] := 
    tuRepeat[{sub, tuOpDistribute[dotOps], tuOpSimplify[dotOps, scalar]}, 
      {func}, iterate][exp]
 
expandDot /: expandDot::usage = "expandDot[sub_:{},scalar_:{},func_:{},iterat\
e_:20] functional definition equivalent to \
tuRepeat[{sub,tuOpDistribute[dotOps],tuOpSimplify[dotOps,scalar]},{func},iter\
ate]. This definition serves as an example of how to collect several repeated \
operations into one statement.  *22Mar2019*"
 
tuRepeat[rules_List:{}, operations_:{}, nInterate_:100][exp_] := 
    Module[{$IterationLimit = 20, xrule, xop, tmp = exp, tmp0, icnt = 0}, 
     xrule = tuRule[{rules}]; xop = Flatten[{operations}]; 
      xPrint[xrule, xop, $IterationLimit]; While[tmp0 =!= tmp, 
       tmp0 = tmp; xPrint[icnt, tmp]; icnt++; xPrint[xop]; 
        If[xop =!= {}, tmp = (Composition[Sequence @@ xop])[tmp]]; 
        If[xrule =!= {}, tmp = Fold[#1 //. Sequence[#2, MaxIterations -> 
               nInterate] & , tmp, xrule]]; xPrint[operation =!= Null]; 
        If[icnt >= nInterate, Return[tmp]]; xPrint[$IterationLimit]; ]; tmp]
 
tuRepeat /: tuRepeat::usage = "tuRepeat[rules_List:{},operations_:{},nInterat\
e_:100][exp_] applies rules_List and operations_ (may be List) repeatedly \
until exp_ does not change. nInterate_ sets MaxInterations in ReplaceRepeated \
and While[] loop. *22Feb2016*"
 
$IterationLimit = 4096
 
tuRule[rules_, negativePower_:False, simplerArg_:True] := 
    Module[{$ = rules, rr$}, $ = Flatten[$]; 
      $ = tuExtractPattern[(Rule[__]) | (RuleDelayed[__])][$]; 
      $ = tuNoComments[$]; If[simplerArg, 
       $ = $ /. (rr:Rule | RuleDelayed)[-(a_), b_] -> rr[a, -b]; ]; 
      If[negativePower, $ = {$, tuRulePositiveNegativePower[$], 
         $ /. (rr:Rule | RuleDelayed)[a_, b_] -> rr[1/a, 1/b]}]; 
      $ = Flatten[DeleteCases[(Rule | RuleDelayed)[a_, a_]][$]]; 
      $ = Flatten[DeleteCases[FontFamily -> a_][$]]; DeleteDuplicates[$]]
 
tuRule /: tuRule::usage = "tuRule[rules_,negativePower_:False,simplerArg_:Tru\
e] produces a List of valid Rule[]s from rules_ and forms a Flatten[]d list \
of Rules. Deletes imbedded comments in the form of head_[CG[__]] and other \
non-Rule forms. If  If negativePower_\[Rule]True then negative Power of \
Rule[]s are generated.  If simplerArg_\[Rule]True then Rules are transformed \
from -a\[Rule]b \[Rule] a\[Rule]-b and \!\(\*SuperscriptBox[\(a\), \
\(2\)]\)->b \[Implies] a\[Rule]Sqrt[b] . *7Aug2015*1Feb2018*"
 
Attributes[rr$] = {Temporary}
 
tuNoComments[exp_] := Module[{head, $s, $comments = {CR, CG, CO, CP, CB}}, 
     $s = ((head_)[#1[_], ___] -> head & ) /@ $comments; exp //. $s]
 
tuNoComments /: tuNoComments::usage := "tuNoComments[exp_] removes comments \
from variables in exp_ where the comments are in the form of \
variable[$comments[_,___]]. $comments={CR,CG,CO,CP,CB} *4Dec2019*"
 
$s = Tensor[a, {4}, {Global`Void}] -> E^(-Subscript[t, s])
 
CR[a__] := style[Red, a]
 
style[color_, exp__] := Module[{tmp = {exp}}, 
     tmp = Thread[Style[tmp, color, FontFamily -> "Helvetica"]]; 
      Sequence @@ tmp]
 
CG[a__] := style[Darker[Green], a]
 
CO[a__] := style[Orange, a]
 
CP[a__] := style[Darker[Pink], a]
 
CB[a__] := style[Blue, a]
 
tuRulePositiveNegativePower[rules_] := Module[{$ = rules, rr$}, 
     $ = $ /. (rr:Rule | RuleDelayed)[(a_)^(b_), c_] :> 
        (rr$[a^(-b), c^(-1)] /. rr$ -> rr)]
 
tuRulePositiveNegativePower /: tuRulePositiveNegativePower::usage = "tuRulePo\
sitiveNegativePower[rules_] produces inverse Power in Rule[]s that include \
Power[] in first arguement.  Mathematica does not recognize inversed Power \
terms in pattern matching.  *2Feb2018*"
 
tuOpDistribute[op_, over_:Plus] := {oo:op[a1___, over[a_, ap__], a2___] :> 
      Distribute[ExpandAll[oo], over], oo:op[over[a_, ap__], a2___] :> 
      Distribute[ExpandAll[oo], over]}
 
tuOpDistribute /: tuOpDistribute::usage = "tuOpDistribute[op_,over_:Plus] \
Rule for distributing op_ over over_. \
EG.\na.(b-c).d/.tuOpDistribute[dotOps]->a.b.d+a.(-c).d. Works with op_s of \
form  CommutatorM[arg__\!\(\*SubscriptBox[\(]\), \(\[Rho]\)]\) as well.  \
*21May2015*23Jun2017*15Jun2020*"
 
tuOpSimplify[operator_, scalars_List:{}, oneIdentity_:{}] := 
    tuRule[{(op:operator)[a_] :> a /; MatchQ[op, dotOps], 
      (op:operator)[a_] :> a /; tuMemberQ[op, oneIdentity], 
      (op:operator)[] -> 1, (op:operator)[Longest[a___], 
        (cc:(c_)^(n_:1))*(d_), Longest[e___]] :> cc*op[a, d, e] /; 
        (NumericQ[c] || tuMemberQ[c, scalars]) && (NumericQ[n] || 
          tuMemberQ[n, scalars]), (op:operator)[Longest[a___], 
        cc:(c_)^(n_:1), Longest[d___]] :> cc*op[a, d] /; 
        (NumericQ[c] || tuMemberQ[c, scalars]) && (NumericQ[n] || 
          tuMemberQ[n, scalars]), Conjugate[(op:operator)[a__]] :> 
       op @@ Thread[Conjugate[{a}]]}]
 
tuOpSimplify /: tuOpSimplify::usage = "tuOpSimplify[operator_,scalars_List:{}\
,oneIdentity_:{}] Rule for simplifying operator[] expressions by removing \
NumericQ and scalars_ from its arguements. \noneIdentity_:{} identifies \
operators that behave like OneIdentity Attribute[]. NOTE: Some of these \
Rule[]s do not seem active for some expressions. BUG: Does not Match some \
scalars_. *26Sep2015**21Mar2018**12Mar2019*25Mar2020*"
 
cc[a_] := Conjugate[a]
 
tuCommutatorExpand := {CommutatorP -> ACommutator, CommutatorM -> MCommutator}
 
tuCommutatorExpand /: tuCommutatorExpand::usage = "tuCommutatorExpand is \
Rule[] to replace Commutator expression into Dot[]d notation. *21Mar2016*"
 
ACommutator[A_, B_] := tuCommutator[Dot, 1][A, B]
 
tuCommutator[op_:Dot, sign_:-1][A_, B_] := op[A, B] + sign*op[B, A]
 
tuCommutator /: tuCommutator::usage = "tuCommutator[op_:Dot,sign_:-1][A_,B_] \
expands the commutator of matrices A and B using op_ as multiplicative \
operator. *17Feb2016*"
 
sign[i_] := If[i == 0, -1, 1]
 
MCommutator[A_, B_] := tuCommutator[Dot][A, B]
 
toxDot := dotOps -> xDot
 
tuMatrixOrderedMultiply[exp_] := Module[{tmp, A$, head, pos, $p, i, $n, $}, 
     pos = tuExtractPositionPattern[dotOps][exp]; xPrint[">>", pos]; 
      pos = tuPositionNestDelete[pos]; xPrint[">>", pos]; 
      Do[$p = pos[[i,1]]; xPrint[$p, "<<"]; $p = If[$p[[-1]] == 0, 
          Delete[$p, -1]]; $ = exp[[Sequence @@ $p]]; xPrint["===", $]; 
        pos[[i,1]] = $p; If[MatchQ[head = Head[$], dotOps], 
         tmp = MapIndexed[Map[A$[#2], #1, {2}] & , $]; 
          tmp = tmp /. head -> Dot; tmp = tmp /. Times -> head; 
          tmp = tmp /. A$[_][a_] -> a]; pos[[i,2]] = tmp, {i, Length[pos]}]; 
      tuReplacePart[exp, pos]]
 
tuMatrixOrderedMultiply /: tuMatrixOrderedMultiply::usage = "tuMatrixOrderedM\
ultiply[exp_] evaluates top Level matrix expressions (Head->dotOps) using Dot \
for actual matrix multiply but maintaining order of elements from each \
matrix.  The matrix inputs must have the same proper form and sizes. This \
routine is useful when matrix elements are noncommuting matrices. \
*18Feb2016*"
 
Attributes[A$] = {Temporary}
 
tuExtractPositionPattern[pattern_, maxlevel_:Infinity][exp_] := 
    Module[{xpattern = pattern, pos, list, tmp, xList}, 
     If[Head[xpattern] == List, xpattern = Alternatives @@ xpattern; 
        xPrint[xHead[xpattern]]]; pos = Position[exp, xpattern, 
        {0, maxlevel}, Heads -> True]; list = Extract[exp, pos]; 
      tmp = Thread[pos -> list]; xPrint["X ", tmp, ", ", xpattern, ", ", 
       list, ", ", pos]; tmp]
 
tuExtractPositionPattern /: tuExtractPositionPattern::usage = "tuExtractPosit\
ionPattern[pattern_,maxlevel_:Infinity][exp_] extracts a List of \
{Positions,items} that match pattern_ in exp_ up to Level maxlevel_.  Returns \
a List[ pos1->match1,pos2->match2,... ]. pattern_ may be a List or \
Alternatives. *3Nov2016*)"
 
tuPositionNestDelete[position_List] := Module[{$ = position, $p, dup, $n, $t, 
      i}, $p = $ = (#1 & ) /@ Sort[$]; xPrint[$p]; If[$p[[1,1]] == {}, 
       Return[{$p[[1]]}]]; Do[$t = $p[[i,1]]; $n = FirstPosition[$t, 0][[1]]; 
        $p[[i,1]] = $t[[1 ;; If[NumericQ[$n], $n - 1, -1]]], 
       {i, Length[$p]}]; Do[If[MemberQ[SequencePosition[$p[[$j,1]], 
          $p[[$i,1]]], {1, ___}], $[[$j]] = dup[$i, $[[$j]]]], 
       {$i, Length[$] - 1}, {$j, $i + 1, Length[$]}]; DeleteCases[$, dup[__]]]
 
tuPositionNestDelete /: tuPositionNestDelete::usage = "tuPositionNestDelete[p\
osition_List] reduces the result of Position\[Rule] position_List so that \
there is only top level positions. E.G. \
{{1,2}\[Rule]a,{1}\[Rule]r[a]}\[Rule]{{1}->r[a]}. If pointer to whole \
expression {} exists then that alone is returned.  *11Feb2017*"
 
$t = {T -> \[Rho]*Sinh[\[Chi]], r -> \[Rho]*Cosh[\[Chi]]}
 
tuReplacePart[pos_List][exp_] := tuReplacePart[exp, pos]
 
tuReplacePart[exp_, pos_List] := Module[{$}, 
     If[Length[$ = Cases[pos, ({} -> _) | ({} :> _)]] > 0, $[[1,2]], 
      ReplacePart[exp, pos]]]
 
tuReplacePart /: tuReplacePart::usage = "tuReplacePart[exp_,pos_List] like \
ReplacePart[] except replaces whole exp_ when pos contains {{}->replacement} \
in which case ReplacePart does nothing. *5Sep2015*"
 
expandDC[sub_:{}, scalar_:{}, func_:{}, iterate_:20] := 
    expandDot[sub, scalar, func, iterate]
 
Attributes[exp$] = {Temporary}
 
Attributes[eyd$] = {Temporary}
 
Attributes[e$] = {Temporary}
 
$0 = {tuIndexDummyOrdered[Tensor[\[Eta], {Global`Void, Global`Void}, {M, M}]*
        (\[Lambda]*Tensor[X, {M}, {Global`Void}] - tuDDown["\[PartialD]"][
          tuDDown["\[PartialD]"][Tensor[X, {M}, {Global`Void}], \[Zeta]], 
          \[Zeta]]) -> 0], -1 + Tensor[X, {M}, {Global`Void}]*
        Tensor[X, {N}, {Global`Void}]*Tensor[\[Eta], {Global`Void, 
          Global`Void}, {M, N}] -> 0}
 
tuIndexDummyOrdered[indices_:{}][exp_] := Module[{tmp = exp}, 
     tmp = Expand[tmp]; tmp = tmp /. Plus -> xPlus; If[tuHasAnyQ[tmp, xPlus], 
       tmp = tmp /. pp:xPlus[a__] :> (tuIndexUpDnOrder[indices][#1] & ) /@ 
            pp; tmp = tmp /. xPlus -> Plus, tmp = tuIndexUpDnOrder[indices][
         tmp]]; Return[tmp]; ]
 
tuIndexDummyOrdered /: tuIndexDummyOrdered::usage = "tuIndexDummyOrdered[indi\
ces_:{}][exp_] UpDn orders Dummy indices_ of each term found in Plus[] \
expressions of exp_.  If indicies_ are not specified then all dummy indices \
are used.  *2Jan2016**2Jan2018**6Mar2019*"
 
tuHasAnyQ[exp_, items_] := Or @@ ( !FreeQ[exp, #1] & ) /@ Flatten[{items}]
 
tuHasAnyQ /: tuHasAnyQ::usage = "tuHasAnyQ[exp_,items_List] returns True if \
exp_ has any item(FreeQ) in items_List. *18Jul2015*"
 
tuIndexUpDnOrder[index_:{}][exp_] := Module[{$indices, $index, $pdum, $dums, 
      $dum, $i, $out, $term, $replace = {}}, $indices = Flatten[{index}]; 
      $dums = First[tuIndexParser[exp]]; If[Length[$indices] > 0, 
       $dums = Intersection[$indices, $dums]]; 
      $pdum = tuExtractPositionPattern[Alternatives @@ $dums][exp]; 
      $out = exp; For[$i = 1, $i <= Length[$dums], $i++, 
       $index = $dums[[$i]]; $dum = Select[$pdum, 
          tuHasAnyQ[#1[[2]], $index] & ]; If[Length[$dum] == 2, 
         $term = $out[[Sequence @@ Most[$dum[[1,1]]]]]; 
          If[MatchQ[$term, tuDerivOpsD[__]], 
           $out = tuIndexSwapUpDown[$dum[[1,2]]][$out]; , 
           If[ !MatchQ[$term, tuDerivOpsU[__]] && $dum[[1,1,-2]] == 3, 
            $out = tuIndexSwapUpDown[$dum[[1,2]]][$out]]]; ]; ]; $out]
 
tuIndexUpDnOrder /: tuIndexUpDnOrder::usage = "tuIndexUpDnOrder[indices_:{}][\
exp_] orders Dummy indices in exp_.  Only indices specified by indices_ are \
ordered if specified and if not specified then all dummy indices are used. \
NOTE: this routine is designed to operate on exp_ that have unique UpDn dummy \
indices as in product-like expressions. *6Mar2019*"
 
tuIndexParser[term_] := Module[{tmp, pos, up = {}, dn = {}, updup, dndup, 
      dummy = {}, bad = {}}, If[Head[term] =!= Plus, 
       tmp = term //. IndexParsingRules; 
        pos = tuExtractPositionPattern[Tensor[$A_, $u_, $d_]][tmp]; 
        pos = tuPositionNestDelete[pos]; pos = (#1[[2]] & ) /@ pos; 
        xPrint["pos:", pos, "tmp", tmp, ":"]; 
        up = (DeleteCases[#1, Global`Void] & )[Flatten[(#1[[2]] & ) /@ pos]]; 
        dn = (DeleteCases[#1, Global`Void] & )[Flatten[(#1[[3]] & ) /@ pos]]; 
        updup = Tally[up]; dndup = Tally[dn]; xPrint[up]; 
        bad = (#1[[1]] & ) /@ Join[Cases[updup, {_, n_ /; n > 1}], 
           Cases[dndup, {_, n_ /; n > 1}]]; dummy = Intersection[up, dn]; 
        up = DeleteCases[up, Alternatives @@ Join[dummy, bad]]; 
        dn = DeleteCases[dn, Alternatives @@ Join[dummy, bad]]; 
        xPrint[{up, dn}]; ]; {dummy, {up, dn}, bad}]
 
tuIndexParser /: tuIndexParser::usage = "tuIndexParser[term_] extends \
ParseTermIndices in Tensorial handle complex Tensor notation. Returns \
{dummy,{up,down},error} indices. Returns indices of only top level Tensors. \
*11Feb2017"
 
tuDerivOpsD := tuDPartial | tuDCovariant | tuDs[_] | tuDDown[_]
 
tuDPartial[a_, b_] := tuDDown["\[PartialD]"][a, b]
 
tuDCovariant[a_, b_] := tuDDown["\[Del]"][a, b]
 
tuDs[s_][a_, b_] := tuDDown[s][a, b]
 
tuIndexSwapUpDown[index_][exp_] := Module[{tmp = exp, XXXX, YYYY}, 
     If[Head[index] =!= List, tmp = tuIndicesLower[index, XXXX][tmp]; 
        tmp = tuIndicesRaise[index, YYYY][tmp]; 
        tmp = tmp /. XXXX -> index /. YYYY -> index, 
       tmp = Fold[tuIndexSwapUpDown[#2][#1] & , exp, index]]; tmp]
 
tuIndexSwapUpDown /: tuIndexSwapUpDown::usage = "tuIndexSwapUpDown[index_][ex\
p_] swaps UpDn position of index_ in exp_. index_ may be List in which case \
the indices are Fold[]d over List. *22Oct2015*"
 
tuIndicesLower[from_, to_:{}][exp_] := 
    Module[{$ = exp, $s, $f = Flatten[{from}], $t = Flatten[{to}]}, 
     If[Length[$f] != Length[$t], $t = $f]; 
      $s = Thread[tuIndexLowerAll[$f, $t]]; Fold[#2[#1] & , $, $s]]
 
tuIndicesLower /: tuIndicesLower::usage = "tuIndicesLower[from_,to_:{}][exp_] \
lowers from_ indices to to_ indices. from_ and to_ may be lists of indices \
then the lowering is performed pairwise.  If to_ is omitted or not equal in \
Length then to_ = from_.  *29May2015*"
 
$f = {Tensor[X, {0}, {Global`Void}] -> L*((E^t*r^2)/2 + Sinh[t]), 
     Tensor[X, {4}, {Global`Void}] -> L*(-(E^t*r^2)/2 + Cosh[t])}
 
tuIndexLowerAll[from_, to_][exp_] := Module[{upD, dnD, opD, subd, ipos, ip, 
      xexp, xfrom, xto, $Pattern}, opD = DerivOpsU; upD = List @@ opD; 
      dnD = List @@ DerivOpsD; subd = Thread[upD -> RemovePatterns[dnD]]; 
      subd = ((#1 /. a_ :> If[Head[a] === Symbol, a, Head[a]] & ) /@ 
          #1 & ) /@ subd; {xexp, xfrom, xto} = 
       (#1 //. Pattern -> $Pattern & ) /@ {exp, from, to}; 
      xexp = xexp //. t$:Tensor[A_, u_List, d_List] :> 
         tuIndexLower[xfrom, xto][t$]; 
      xexp = xexp //. (OP:opD)[a_, b_] :> (OP //. subd)[a, xto] /; 
          (b //. Pattern -> $Pattern) == xfrom; xexp //. $Pattern -> Pattern]
 
tuIndexLowerAll /: tuIndexLowerAll::usage = "tuIndexLowerAll[from_,to_][exp_] \
lowers one index from_ to to_ found in exp_.  Handles indices in DerivOpsD to \
DerivOpsU *20Jun2015*"
 
DerivOpsU := Join[xPartialDu | xCovariantDu | xDu[_], tuDerivOpsU]
 
xPartialDu[field_, var_] := tuPartialDu[field, var]
 
tuPartialDu := tuDPartialu
 
tuPartialDu /: tuPartialDu::usage = "tuPartialDu[field_,var_] displays the \
PartialDu[field,var] \[Rule] \!\(\*SuperscriptBox[\(\[PartialD]\), \
\(var\)]\)field. "
 
tuDPartialu[a_, b_] := tuDUp["\[PartialD]"][a, b]
 
tuDerivOpsU := tuDPartialu | tuDCovariantu | tuDsu[_] | tuDUp[_]
 
tuDCovariantu[a_, b_] := tuDUp["\[Del]"][a, b]
 
tuDsu[s_][a_, b_] := tuDUp[s][a, b]
 
DerivOpsD := Join[xPartialD | xCovariantD | xD[_], tuDerivOpsD]
 
xPartialD[field_, var_] := tuPartialD[field, var]
 
tuPartialD := tuDPartial
 
tuPartialD /: tuPartialD::usage = "tuPartialD[field_,var_] displays the \
PartialD[field,var] \[Rule] \!\(\*SubscriptBox[\(\[PartialD]\), \
\(var\)]\)field. "
 
RemovePatterns[exp_] := tuPatternRemove[exp]
 
tuPatternRemove[exp_] := Module[{tmp = exp, xPattern}, 
     tmp = tmp /. PatternTest -> xPatternTest /. xPatternTest[a_, b_] -> a; 
      tmp = tmp //. Pattern -> xPattern //. Blank -> xBlank //. 
        BlankSequence -> xBlankSequence; 
      tmp = tmp //. xPattern[a_, xBlank[] | xBlankSequence[]] -> a; 
      tmp = tmp /. xPattern -> Pattern]
 
tuPatternRemove /: tuPatternRemove::usage = "tuPatternRemove[exp_] removes \
Pattern[a_,Blank[]|BlankSequence[]]:>a in all of exp_ *24Nov2013"
 
Attributes[t$] = {Temporary}
 
tuIndexLower[var1_, var2_][A_Tensor] := Module[{Name$, u$, d$, $swap}, 
     {Name$, u$, d$} = List @@ A; {u$, d$} = If[MemberQ[u$, var1], 
        u$ = u$ //. var1 -> $swap; SwapVarFromAtoB[$swap, u$, d$], {u$, d$}]; 
      {d$, u$} = {d$, u$} //. $swap -> var2; Tensor[Name$, u$, d$]]
 
tuIndexLower /: tuIndexLower::usage = "tuIndexLower[var1_,var2_][A_Tensor] \
lowers index var1_ to var2_ in A_Tensor. eg: $exp/. \
tt:Tensor[\[Gamma],{ii:_},{_}]\[RuleDelayed]tuIndexLower[ii,ii][tt] \
*23Apr2015*"
 
Attributes[u$] = {Temporary}
 
Attributes[d$] = {Temporary}
 
SwapVarFromAtoB[var_, A_List, B_List] := 
    Module[{tmp, pos, xpos, i, len, xA = A, xB = B}, 
     If[Length[xA] == Length[xB], pos = Flatten[Position[xA, var, 1]]; 
        len = Length[pos]; If[len > 0, For[i = 1, i <= len, i++, 
           xpos = pos[[i]]; tmp = xB[[xpos]]; xB[[xpos]] = xA[[xpos]]; 
            xA[[xpos]] = tmp; ]; ]; ]; {xA, xB}]
 
tuIndicesRaise[from_, to_:{}][exp_] := 
    Module[{$ = exp, $s, $f = Flatten[{from}], $t = Flatten[{to}]}, 
     If[Length[$f] != Length[$t], $t = $f]; 
      $s = Thread[tuIndexRaiseAll[$f, $t]]; Fold[#2[#1] & , $, $s]]
 
tuIndicesRaise /: tuIndicesRaise::usage = "tuIndicesRaise[from_,to_:{}][exp_] \
raises from_ indices to to_ indices. from_ and to_ may be lists of indices \
then the raising is performed pairwise.  If to_ is omitted or not equal in \
Length then to_ = from_.  *29May2015*"
 
tuIndexRaiseAll[from_, to_][exp_] := Module[{upD, dnD, opD, subd, ipos, ip, 
      xexp, xfrom, xto, $Pattern}, opD = DerivOpsD; dnD = List @@ opD; 
      upD = List @@ DerivOpsU; subd = Thread[dnD -> RemovePatterns[upD]]; 
      subd = ((#1 /. a_ :> If[Head[a] === Symbol, a, Head[a]] & ) /@ 
          #1 & ) /@ subd; {xexp, xfrom, xto} = 
       (#1 //. Pattern -> $Pattern & ) /@ {exp, from, to}; 
      xexp = xexp //. t$:Tensor[A_, u_List, d_List] :> 
         tuIndexRaise[xfrom, xto][t$]; 
      xexp = xexp //. (OP:opD)[a_, b_] :> (OP /. subd)[a, xto] /; 
          (b //. Pattern -> $Pattern) == xfrom; xexp //. $Pattern -> Pattern]
 
tuIndexRaiseAll /: tuIndexRaiseAll::usage = "tuIndexRaiseAll[from_,to_][exp_] \
raises one index from_ to to_ found in exp_.  Handles indices in DerivOpsD to \
DerivOpsU *20Jun2015*"
 
tuIndexRaise[var1_, var2_][A_Tensor] := Module[{Name$, u$, d$, $swap}, 
     {Name$, u$, d$} = List @@ A; {d$, u$} = If[MemberQ[d$, var1], 
        d$ = d$ //. var1 -> $swap; SwapVarFromAtoB[$swap, d$, u$], {d$, u$}]; 
      {d$, u$} = {d$, u$} //. $swap -> var2; Tensor[Name$, u$, d$]]
 
tuIndexRaise /: tuIndexRaise::usage = "tuIndexRaise[var1_,var2_][A_Tensor] \
raises index var1_ to var2_ in A_Tensor. eg: $exp/. \
tt:Tensor[\[Gamma],{_},{ii:_}]\[RuleDelayed]tuIndexRaise[ii,ii][tt] \
*23Apr2015*"
 
$00 = Tensor[X, {4}, {Global`Void}] -> (L - E^(2*t)*L*(-1 + r^2))/(2*E^t)
 
$3 = {r -> L*Sinh[\[Psi]]*Tan[\[Theta]], 
     r -> Sqrt[Tensor[X, {1}, {Global`Void}]^2 + 
        Tensor[X, {2}, {Global`Void}]^2 + Tensor[X, {3}, {Global`Void}]^2], 
     L*Cosh[\[Psi]]*Tan[\[Theta]] -> T}
 
$conformal = {Cosh[t] -> Sec[\[Tau]], -Pi/2 < \[Tau] < Pi/2}
 
$conformalds = d[s]^2 -> -(L^2*Sec[\[Tau]]^2*(d[\[Tau]]^2 - 
        d[$dum$6038]^2*Derivative[1][Subscript[\[CapitalOmega], 3]][
           $dum$6038]^2))
 
$conformalwiki = {Tanh[\[Tau]/2] -> Tan[T/2], -Pi/2 < T < Pi/2, 
     T -> 2*ArcTan[Tanh[\[Tau]/2]], \[Tau] -> 2*ArcTanh[Tan[T/2]]}
 
$def["AZ.IX"] = {xSum[If[i == 0, -1, 1]*Tensor[X, {i}, {Global`Void}]^2, 
       {i, 0, d}] -> L^2, d[Subscript[\[CapitalOmega], 2]]^2 -> 
      d[\[Theta]]^2 + d[\[CurlyPhi]]^2*Sin[\[Theta]]^2, 
     d[Subscript[s, 3]]^2 -> d[$dum$2339]^2*
       (Derivative[1][Tensor[X, {1}, {Global`Void}]][$dum$2339]^2 + 
        Derivative[1][Tensor[X, {2}, {Global`Void}]][$dum$2339]^2 + 
        Derivative[1][Tensor[X, {3}, {Global`Void}]][$dum$2339]^2), 
     d[Subscript[s, 3]]^2 -> d[$dum$2339]^2*
        Derivative[1][Tensor[X, {1}, {Global`Void}]][$dum$2339]^2 + 
       d[$dum$2339]^2*Derivative[1][Tensor[X, {2}, {Global`Void}]][$dum$2339]^
         2 + d[$dum$2339]^2*Derivative[1][Tensor[X, {3}, {Global`Void}]][
          $dum$2339]^2, 
     Style["For sphere \!\(\*SuperscriptBox[\(S\), \(n - 1\)]\)", 
      RGBColor[0, 2/3, 0], FontFamily -> "Helvetica"], 
     Tensor[\[Omega], {1}, {Global`Void}] -> 
      Cos[Tensor[\[Theta], {Global`Void}, {1}]], 
     Tensor[\[Omega], {i}, {Global`Void}] -> 
      Cos[Tensor[\[Theta], {Global`Void}, {i}]]*
       Product[Sin[Tensor[\[Theta], {Global`Void}, {j}]], {j, 1, -1 + i}], i, 
     1, -1 + n, Tensor[\[Omega], {n}, {Global`Void}] -> 
      Product[Sin[Tensor[\[Theta], {Global`Void}, {j}]], {j, 1, -2 + n}]*
       Sin[Tensor[\[Theta], {Global`Void}, {-1 + n}]], 
     Inequality[0, LessEqual, Tensor[\[Theta], {Global`Void}, {i}], Less, 
      Pi], Inequality[1, LessEqual, i, Less, -1 + n], 
     Inequality[0, LessEqual, Tensor[\[Theta], {Global`Void}, {-1 + n}], 
      Less, 2*Pi], Framed[Column[{xSum[Tensor[\[Omega], {i}, {Global`Void}]^
           2, {i, 1, n}] -> 1, d[Subscript[\[CapitalOmega], -1 + n]]^2 -> 
         xSum[d[Tensor[\[Omega], {i}, {Global`Void}]]^2, {i, 1, n}], 
        xSum[d[Tensor[\[Omega], {i}, {Global`Void}]]*Tensor[\[Omega], {i}, 
            {Global`Void}], {i, 1, n}] -> 0}]], Style["$s\[Omega]1", 
      RGBColor[0, 2/3, 0], FontFamily -> "Helvetica"], 
     d[$dum$4003]^2*Derivative[1][Subscript[\[CapitalOmega], -1 + n]][
         $dum$4003]^2 -> d[$dum$4003]^2*
       (d[Subscript[\[CapitalOmega], -2 + n]]^2*
         Sin[Tensor[\[Theta], {Global`Void}, {1}]]^2 + 
        Derivative[1][Tensor[\[Theta], {Global`Void}, {1}]][$dum$4003]^2), 
     Tensor[X, {0}, {Global`Void}] -> T, Tensor[X, {1}, {Global`Void}] -> X, 
     Tensor[X, {2}, {Global`Void}] -> Y, Tensor[X, {3}, {Global`Void}] -> Z, 
     Tensor[X, {4}, {Global`Void}] -> W, -T^2 + W^2 + X^2 + Y^2 + Z^2 -> L^2, 
     Tensor[X, {1}, {Global`Void}] -> r*Cos[\[CurlyPhi]]*Sin[\[Theta]], 
     Tensor[X, {2}, {Global`Void}] -> r*Sin[\[Theta]]*Sin[\[CurlyPhi]], 
     Tensor[X, {3}, {Global`Void}] -> r*Cos[\[Theta]], 
     Tensor[X, {i}, {Global`Void}] -> r*Tensor[\[Omega], {i}, {Global`Void}], 
     r^2 -> Tensor[X, {1}, {Global`Void}]^2 + Tensor[X, {2}, {Global`Void}]^
        2 + Tensor[X, {3}, {Global`Void}]^2, L^2 -> r^2 - T^2 + W^2, 
     First[{}], d[Subscript[\[CapitalOmega], 3]]^2 -> First[{}][[2]], 
     r -> L*Sin[\[Psi]], Subscript[dS, 4] -> 
      r^2 - Tensor[X, {0}, {Global`Void}]^2 + Tensor[X, {4}, {Global`Void}]^
         2 -> L^2, Style["Kruskal-Szekeres coordinates", RGBColor[0, 2/3, 0], 
      FontFamily -> "Helvetica"], Style[L -> 1, RGBColor[0, 2/3, 0], 
      FontFamily -> "Helvetica"], SuperPlus[x] -> t + Log[(1 + r)/(1 - r)]/2, 
     SuperMinus[x] -> t - Log[(1 + r)/(1 - r)]/2, Inequality[0, LessEqual, r, 
      Less, 1], t -> (SuperMinus[x] + SuperPlus[x])/2, 
     r -> (-1 + E^(-SuperMinus[x] + SuperPlus[x]))/
       (1 + E^(-SuperMinus[x] + SuperPlus[x])), 
     d[$dum$9392]*Derivative[1][SuperPlus[x]][$dum$9392] -> 
      -(d[r]/(-1 + r^2)) + d[t], d[$dum$9392]*Derivative[1][SuperMinus[x]][
        $dum$9392] -> d[r]/(-1 + r^2) + d[t], 
     d[$dum$9392]^2*Derivative[1][SuperMinus[x]][$dum$9392]*
       Derivative[1][SuperPlus[x]][$dum$9392] -> -(d[r]^2/(-1 + r^2)^2) + 
       d[t]^2, d[s]^2 -> d[r]^2 + r^2*d[Subscript[\[CapitalOmega], 2]]^2 + 
       d[$dum$8927]^2*(Derivative[1][Sqrt[1 - r^2]*Cosh[t]][$dum$8927]^2 - 
         Derivative[1][Sqrt[1 - r^2]*Sinh[t]][$dum$8927]^2), 
     {{d[s]^2 -> d[r]^2 + r^2*d[Subscript[\[CapitalOmega], 2]]^2 + 
          d[$dum$8927]^2*(Derivative[1][Sqrt[1 - r^2]*Cosh[t]][$dum$8927]^2 - 
            Derivative[1][Sqrt[1 - r^2]*Sinh[t]][$dum$8927]^2)}}[
      Style["e[37]", RGBColor[0, 2/3, 0], FontFamily -> "Helvetica"]], 
     U -> E^SuperMinus[x], V -> -E^(-SuperPlus[x]), 
     r -> (-1 - U*V)/(-1 + U*V), U/V -> -E^(2*t), 
     d[U] -> E^SuperMinus[x]*d[$dum$9737]*Derivative[1][SuperMinus[x]][
        $dum$9737], d[V] -> d[-1]/E^SuperPlus[x] + 
       (d[$dum$9737]*Derivative[1][SuperPlus[x]][$dum$9737])/E^SuperPlus[x], 
     {d[s]^2 -> d[(1 + U*V)/(1 - U*V)]^2 + 
         ((1 + U*V)^2*d[Subscript[\[CapitalOmega], 2]]^2)/(-1 + U*V)^2 + 
         d[$dum$8927]^2*(Derivative[1][2*Sqrt[-((U*V)/(-1 + U*V)^2)]*Cosh[t]][
             $dum$8927]^2 - Derivative[1][2*Sqrt[-((U*V)/(-1 + U*V)^2)]*Sinh[
                t]][$dum$8927]^2)}[Style["e[40]", RGBColor[0, 2/3, 0], 
       FontFamily -> "Helvetica"]]}
 
$def["/Users/Tom/Mathematica/Gravity/AZee/AZee.IX.10.1"] = {}
 
Attributes[$dum$2339] = {Temporary}
 
Attributes[$dum$4003] = {Temporary}
 
Attributes[$dum$9392] = {Temporary}
 
Attributes[$dum$9737] = {Temporary}
 
$defID := NBname["stub"]
 
NBname[type_String] := Module[{name = NotebookFileName[], 
      dir = FileNameDrop[NotebookFileName[], -1], 
      base = FileBaseName[NotebookFileName[]]}, Switch[type, "name", name, 
      "dir", dir, "base", base, "stub", FileNameJoin[{dir, base}]]]
 
$defName = "AZ.IX"
 
$dS = {L^2 - W^2 - \[Rho]^2 -> 0}
 
$ds2 = -d[Tensor[X, {0}, {Global`Void}]]^2 + d[Tensor[X, {1}, {Global`Void}]]^
      2 + d[Tensor[X, {2}, {Global`Void}]]^2 + 
     d[Tensor[X, {3}, {Global`Void}]]^2 + d[Tensor[X, {4}, {Global`Void}]]^2
 
$ds2a = -(Cosh[\[Psi]]*d[t] + t*d[\[Psi]]*Sinh[\[Psi]])^2 + 
      d[$dum$4741]^2*Derivative[1][Tensor[X, {1}, {Global`Void}]][$dum$4741]^
        2 + d[$dum$4741]^2*Derivative[1][Tensor[X, {2}, {Global`Void}]][
         $dum$4741]^2 + d[$dum$4741]^2*
       Derivative[1][Tensor[X, {3}, {Global`Void}]][$dum$4741]^2 - 
      (L^2*d[-1] - L*d[L] - d[-1]*Tensor[X, {1}, {Global`Void}]^2 - 
         d[-1]*Tensor[X, {2}, {Global`Void}]^2 - 
         d[-1]*Tensor[X, {3}, {Global`Void}]^2 + d[$dum$4741]*
          Tensor[X, {1}, {Global`Void}]*Derivative[1][Tensor[X, {1}, 
             {Global`Void}]][$dum$4741] + d[$dum$4741]*Tensor[X, {2}, 
           {Global`Void}]*Derivative[1][Tensor[X, {2}, {Global`Void}]][
           $dum$4741] + d[$dum$4741]*Tensor[X, {3}, {Global`Void}]*
          Derivative[1][Tensor[X, {3}, {Global`Void}]][$dum$4741])^2/
       (-L^2 + Tensor[X, {1}, {Global`Void}]^2 + 
        Tensor[X, {2}, {Global`Void}]^2 + Tensor[X, {3}, {Global`Void}]^2) /. 
     First[{}]
 
$ds3 = d[Subscript[s, 3]]^2 -> 
     d[$dum$2339]^2*Derivative[1][Tensor[X, {1}, {Global`Void}]][$dum$2339]^
        2 + d[$dum$2339]^2*Derivative[1][Tensor[X, {2}, {Global`Void}]][
         $dum$2339]^2 + d[$dum$2339]^2*
       Derivative[1][Tensor[X, {3}, {Global`Void}]][$dum$2339]^2
 
$dS4 = L -> Sqrt[r^2 - T^2 + W^2]
 
$dXe = {d[$dum$2339]*Derivative[1][Tensor[X, {1}, {Global`Void}]][
        $dum$2339] -> r*Cos[\[Theta]]*Cos[\[CurlyPhi]]*d[\[Theta]] + 
       Cos[\[CurlyPhi]]*d[r]*Sin[\[Theta]] - r*d[\[CurlyPhi]]*Sin[\[Theta]]*
        Sin[\[CurlyPhi]], 
     d[$dum$2339]*Derivative[1][Tensor[X, {2}, {Global`Void}]][$dum$2339] -> 
      r*Cos[\[CurlyPhi]]*d[\[CurlyPhi]]*Sin[\[Theta]] + 
       r*Cos[\[Theta]]*d[\[Theta]]*Sin[\[CurlyPhi]] + 
       d[r]*Sin[\[Theta]]*Sin[\[CurlyPhi]], 
     d[$dum$2339]*Derivative[1][Tensor[X, {3}, {Global`Void}]][$dum$2339] -> 
      Cos[\[Theta]]*d[r] - r*d[\[Theta]]*Sin[\[Theta]], 
     d[$dum$2339]*Derivative[1][Tensor[X, {i}, {Global`Void}]][$dum$2339] -> 
      d[r]*Tensor[\[Omega], {i}, {Global`Void}] + r*d[$dum$2339]*
        Derivative[1][Tensor[\[Omega], {i}, {Global`Void}]][$dum$2339]}
 
$dXe4 = First[{}]
 
$dXe42 = First[{}]
 
$d\[CapitalOmega]3 = d[Subscript[\[CapitalOmega], 3]]^2 -> First[{}][[2]]
 
$el = {(Tensor[\[Eta], {Global`Void, Global`Void}, {M, N}]*
        (\[Lambda]*Tensor[X, {N}, {Global`Void}] - tuDDown["\[PartialD]"][
          tuDDown["\[PartialD]"][Tensor[X, {N}, {Global`Void}], \[Zeta][dn]], 
          \[Zeta][dn]]))/2 == 0, 
     (Tensor[\[Eta], {Global`Void, Global`Void}, {M, N}]*
        (\[Lambda]*Tensor[X, {M}, {Global`Void}] - tuDDown["\[PartialD]"][
          tuDDown["\[PartialD]"][Tensor[X, {M}, {Global`Void}], \[Zeta][dn]], 
          \[Zeta][dn]]))/2 == 0, 
     (-1 + Tensor[X, {M}, {Global`Void}]*Tensor[X, {N}, {Global`Void}]*
         Tensor[\[Eta], {Global`Void, Global`Void}, {M, N}])/2 == 0}
 
$fn[tt_, rr_] := Module[{$exp = $, $s, $ds}, xPrint["exp: ", $exp]; 
      $s = First[tuExtractPattern[ArcCosh[_]][$exp[[2]]]]; 
      $ds = D[$s[[1]], rr$]; $ds = $ds /. t -> tt /. rr$ -> rr; 
      xPrint["$s : $ds: ", $s, " : ", $ds]; 
      $exp = If[$ds < 0, {ArcSin[$exp[[1]]], $exp[[2]]}, {ArcSin[$exp[[1]]], 
           -$exp[[2]]}] /. rr$ -> rr /. t -> tt; $exp]
 
$g = {Tensor[X, {0}, {Global`Void}] -> L*Sinh[\[Tau]], 
     Tensor[X, {4}, {Global`Void}] -> L*Cos[\[Psi]]*Cosh[\[Tau]]}
 
$geod = {{Tensor[J, {M, N}, {Global`Void, Global`Void}] -> 
        -(Tensor[X, {N}, {Global`Void}]*tuDDown["\[PartialD]"][
            Tensor[X, {M}, {Global`Void}], \[Zeta]]) + 
         Tensor[X, {M}, {Global`Void}]*tuDDown["\[PartialD]"][
           Tensor[X, {N}, {Global`Void}], \[Zeta]]}[Style["conserved", 
       RGBColor[0, 2/3, 0], FontFamily -> "Helvetica"]], 
     J \[CenterDot] J -> (Tensor[J, {M, N}, {Global`Void, Global`Void}]*
        Tensor[J, {Global`Void, Global`Void}, {M, N}])/2, 
     tuIndexDummyOrdered[J \[CenterDot] J -> 
       ((-(Tensor[X, {N}, {Global`Void}]*tuDDown["\[PartialD]"][
             Tensor[X, {M}, {Global`Void}], \[Zeta]]) + 
          Tensor[X, {M}, {Global`Void}]*tuDDown["\[PartialD]"][
            Tensor[X, {N}, {Global`Void}], \[Zeta]])*
         (-(Tensor[X, {Global`Void}, {N}]*tuDDown["\[PartialD]"][
             Tensor[X, {Global`Void}, {M}], \[Zeta]]) + 
          Tensor[X, {Global`Void}, {M}]*tuDDown["\[PartialD]"][
            Tensor[X, {Global`Void}, {N}], \[Zeta]]))/2], 
     tuIndexDummyOrdered[J \[CenterDot] J -> 
       (Style["\[Sum]", RGBColor[0.7, 0, 1, 1]][
          Grid[{{-(Tensor[X, {N}, {Global`Void}]*tuDDown["\[PartialD]"][
                Tensor[X, {M}, {Global`Void}], \[Zeta]])}, 
            {Tensor[X, {M}, {Global`Void}]*tuDDown["\[PartialD]"][Tensor[X, 
                {N}, {Global`Void}], \[Zeta]]}}, Dividers -> 
            {{True}, {False}}, FrameStyle -> Directive[RGBColor[0.7, 0, 1, 
              1], Thickness[Tiny]], Alignment -> Left]]*
         Style["\[Sum]", RGBColor[0.7, 0, 1, 1]][
          Grid[{{-(Tensor[X, {Global`Void}, {N}]*tuDDown["\[PartialD]"][
                Tensor[X, {Global`Void}, {M}], \[Zeta]])}, 
            {Tensor[X, {Global`Void}, {M}]*tuDDown["\[PartialD]"][Tensor[X, 
                {Global`Void}, {N}], \[Zeta]]}}, Dividers -> 
            {{True}, {False}}, FrameStyle -> Directive[RGBColor[0.7, 0, 1, 
              1], Thickness[Tiny]], Alignment -> Left]])/2]}
 
$ks = {SuperPlus[x] -> t + Log[(1 + r)/(1 - r)]/2, 
     SuperMinus[x] -> t - Log[(1 + r)/(1 - r)]/2, Inequality[0, LessEqual, r, 
      Less, 1], t -> (SuperMinus[x] + SuperPlus[x])/2, 
     r -> (-1 + E^(-SuperMinus[x] + SuperPlus[x]))/
       (1 + E^(-SuperMinus[x] + SuperPlus[x]))}
 
$ksUV = {U -> E^SuperMinus[x], V -> -E^(-SuperPlus[x])}
 
$lightlike = Tensor[X, {M}, {Global`Void}] -> Tensor[a, {M}, {Global`Void}] + 
      \[Zeta]*Tensor[b, {M}, {Global`Void}]
 
$pass = {-2 + E^(t - Subscript[t, s]) + E^(t + Subscript[t, s]) - 
       2*E^Subscript[t, s]*Tensor[a, {0}, {Global`Void}] - 
       2*E^Subscript[t, s]*\[Zeta]*Tensor[b, {0}, {Global`Void}] -> 0, 
     1 - E^(t - Subscript[t, s]) + Tensor[a, {1}, {Global`Void}] + 
       \[Zeta]*Tensor[b, {1}, {Global`Void}] -> 0, 
     E^t/2 - E^(t - 2*Subscript[t, s])/2 + E^(-Subscript[t, s]) - 
       Tensor[a, {4}, {Global`Void}] - \[Zeta]*Tensor[b, {4}, 
         {Global`Void}] -> 0}
 
$r2 = r^2 -> Tensor[X, {1}, {Global`Void}]^2 + Tensor[X, {2}, {Global`Void}]^
       2 + Tensor[X, {3}, {Global`Void}]^2
 
$R3 = d[Subscript[s, 3]]^2 -> d[$dum$2339]^2*
      (Derivative[1][Tensor[X, {1}, {Global`Void}]][$dum$2339]^2 + 
       Derivative[1][Tensor[X, {2}, {Global`Void}]][$dum$2339]^2 + 
       Derivative[1][Tensor[X, {3}, {Global`Void}]][$dum$2339]^2)
 
$s1 = {R -> L*Cosh[t], T -> L*Sinh[t]}
 
$sd = {d[$dum$9392]*Derivative[1][SuperPlus[x]][$dum$9392] -> 
      -(d[r]/(-1 + r^2)) + d[t], d[$dum$9392]*Derivative[1][SuperMinus[x]][
        $dum$9392] -> d[r]/(-1 + r^2) + d[t]}
 
$sd2 = d[$dum$9392]^2*Derivative[1][SuperMinus[x]][$dum$9392]*
      Derivative[1][SuperPlus[x]][$dum$9392] -> -(d[r]^2/(-1 + r^2)^2) + 
      d[t]^2
 
$sD3 = -Tensor[X, {0}, {Global`Void}]^2 + Tensor[X, {1}, {Global`Void}]^2 + 
      Tensor[X, {2}, {Global`Void}]^2 + Tensor[X, {3}, {Global`Void}]^2 -> L^2
 
$sH3 = d[Subscript[H, 3]]^2 -> d[\[Psi]]^2 + 
      d[Subscript[\[CapitalOmega], 2]]^2*Sinh[\[Psi]]^2
 
$sL = L -> 1
 
$sn = n -> 4
 
$spacelike = {Tensor[X, {M_}, {Global`Void}] -> 
      Cos[K*\[Zeta]]*Tensor[a, {M}, {Global`Void}] + 
       Sin[K*\[Zeta]]*Tensor[b, {M}, {Global`Void}], 
     tuIndexDummyOrdered[-1 + Tensor[a, {Global`Void}, {N}]*
         Tensor[b, {N}, {Global`Void}] + Tensor[a, {N}, {Global`Void}]*
         Tensor[b, {Global`Void}, {N}] -> 0], 
     Tensor[ab_, {Global`Void}, {m_}]*Tensor[ab_, {m_}, {Global`Void}] -> 0}
 
$SpinorsPath = "/Users/Tom/Library/Mathematica/Applications"
 
$sr = r -> (-1 - U*V)/(-1 + U*V)
 
$sT = {T -> -ArcCosh[Sec[\[Tau]]], T -> ArcCosh[Sec[\[Tau]]]}
 
$sT1 = T -> 2*ArcTan[Tanh[\[Tau]/2]]
 
$sW = W -> Sqrt[L^2 - \[Rho]^2]
 
$sx = Tensor[X, {M_}, {Global`Void}] -> 
     E^(K*\[Zeta])*Tensor[a, {M}, {Global`Void}] + 
      Tensor[b, {M}, {Global`Void}]/E^(K*\[Zeta])
 
$s\[Psi] = {Tensor[X, {0}, {Global`Void}] -> t*Cosh[\[Psi]], 
     r -> t*Sinh[\[Psi]]}
 
$s\[Omega] = {Style["For sphere \!\(\*SuperscriptBox[\(S\), \(n - 1\)]\)", 
      RGBColor[0, 2/3, 0], FontFamily -> "Helvetica"], 
     {Tensor[\[Omega], {1}, {Global`Void}] -> 
       Cos[Tensor[\[Theta], {Global`Void}, {1}]], 
      {Tensor[\[Omega], {i}, {Global`Void}] -> 
        Cos[Tensor[\[Theta], {Global`Void}, {i}]]*
         Product[Sin[Tensor[\[Theta], {Global`Void}, {j}]], {j, 1, -1 + i}], 
       {i, 1, -1 + n}}, Tensor[\[Omega], {n}, {Global`Void}] -> 
       Product[Sin[Tensor[\[Theta], {Global`Void}, {j}]], {j, 1, -2 + n}]*
        Sin[Tensor[\[Theta], {Global`Void}, {-1 + n}]]}, 
     {{{Inequality[0, LessEqual, Tensor[\[Theta], {Global`Void}, {i}], Less, 
         Pi]}, Inequality[1, LessEqual, i, Less, -1 + n]}, 
      Inequality[0, LessEqual, Tensor[\[Theta], {Global`Void}, {-1 + n}], 
       Less, 2*Pi]}, Framed[Column[
       {xSum[Tensor[\[Omega], {i}, {Global`Void}]^2, {i, 1, n}] -> 1, 
        d[Subscript[\[CapitalOmega], -1 + n]]^2 -> 
         xSum[d[Tensor[\[Omega], {i}, {Global`Void}]]^2, {i, 1, n}], 
        xSum[d[Tensor[\[Omega], {i}, {Global`Void}]]*Tensor[\[Omega], {i}, 
            {Global`Void}], {i, 1, n}] -> 0}]], Style["$s\[Omega]1", 
      RGBColor[0, 2/3, 0], FontFamily -> "Helvetica"]}
 
$s\[Omega]1 = {xSum[Tensor[\[Omega], {i}, {Global`Void}]^2, {i, 1, n}] -> 1, 
     d[Subscript[\[CapitalOmega], -1 + n]]^2 -> 
      xSum[d[Tensor[\[Omega], {i}, {Global`Void}]]^2, {i, 1, n}], 
     xSum[d[Tensor[\[Omega], {i}, {Global`Void}]]*Tensor[\[Omega], {i}, 
         {Global`Void}], {i, 1, n}] -> 0}
 
$s\[Omega]1i[ii_] := $s\[Omega]1 /. {i, 1, n} -> {i, ii, n} /. n - 1 -> n - ii
 
$s\[CapitalOmega]2 = d[Subscript[\[CapitalOmega], 2]]^2 -> 
     d[\[Theta]]^2 + d[\[CurlyPhi]]^2*Sin[\[Theta]]^2
 
$tglobal = {r -> L*Cosh[t]*Sin[\[Psi]], W -> L*Cos[\[Psi]]*Cosh[t], 
     T -> L*Sinh[t]}
 
$timelike = {Tensor[X, {M_}, {Global`Void}] -> 
      E^(K*\[Zeta])*Tensor[a, {M}, {Global`Void}] + 
       Tensor[b, {M}, {Global`Void}]/E^(K*\[Zeta]), 
     tuIndexDummyOrdered[-1 + Tensor[a, {Global`Void}, {N}]*
         Tensor[b, {N}, {Global`Void}] + Tensor[a, {N}, {Global`Void}]*
         Tensor[b, {Global`Void}, {N}] -> 0], 
     Tensor[ab_, {Global`Void}, {m_}]*Tensor[ab_, {m_}, {Global`Void}] -> 0}
 
$x = {SuperPlus[x] -> t + Log[(1 + r)/(1 - r)]/2, 
     SuperMinus[x] -> t - Log[(1 + r)/(1 - r)]/2}
 
$X4 = Tensor[X, {4}, {Global`Void}] -> 
     -Sqrt[L^2 - Tensor[X, {1}, {Global`Void}]^2 - 
        Tensor[X, {2}, {Global`Void}]^2 - Tensor[X, {3}, {Global`Void}]^2]
 
$Xe3 = {Tensor[X, {1}, {Global`Void}] -> r*Cos[\[CurlyPhi]]*Sin[\[Theta]], 
     Tensor[X, {2}, {Global`Void}] -> r*Sin[\[Theta]]*Sin[\[CurlyPhi]], 
     Tensor[X, {3}, {Global`Void}] -> r*Cos[\[Theta]], 
     Tensor[X, {i}, {Global`Void}] -> r*Tensor[\[Omega], {i}, {Global`Void}], 
     r^2 -> Tensor[X, {1}, {Global`Void}]^2 + Tensor[X, {2}, {Global`Void}]^
        2 + Tensor[X, {3}, {Global`Void}]^2}
 
$Xspace = xSum[Tensor[X, {i}, {Global`Void}]^2, {i, 1, d}] -> L^2
