(* ::Package:: *)

(*******************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which
typically will have the same name as this file except ending in
".nb" instead of ".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent
to using the Evaluate Initialization Cells menu command in the front
end.

DO NOT EDIT THIS FILE.  This entire file is regenerated
automatically each time the parent Notebook file is saved in the
Mathematica front end.  Any changes you make to this file will be
overwritten.
***********************************************************************)











(*  TCLifford is a Mathematica package for Mathematica 4.1*)

(*  Author: Renan Cabrera   *)

(*  rencabla@ceibo.entelnet.bo / renanbo@hotmail.com / cabrer7@uwindsor.ca*)

(*  I would appreciate any comments and your contributions are welcome to \
become part of TMecanica. *)

(* TClifford can be used and distributed freely, for non commercial purpose, 
always mentioning the author every time used as specified at Mathsource \
(www.mathsource.com)

 This software package and its accompanying documentation are provided \
without 
 guarantee of support or maintenance *)

(*  Mathematica is a registered trademark of Wolfram Research, Inc.     *)





BeginPackage[
"TCliffordAlgebra1`TClifford`", {"TensorCalculus3`Tensorial`", 
"DiscreteMath`Combinatorica`"}];


$PrePrint=StyleForm[##,FontSize->16,FontFamily->"Courier"]&;





BasisLabelsList::usage="List that contains the labels of the symbols to be \
considered labels of orthonormal basis."



BasisLabelsList={};



PVector::usage="PVector[label,n] represents a vector of grade n.\n \
PVector[label] represnts an undefined grade vector. This is useful when this \
vector could be made of multiple grade vectors."





usage::Diamond=" Symbol used to denote the vector product. ";

NonCommutativeMultiply::usage=
    "The vector product of the Clifford algebra is the Mathematica Operator ** \
NonCommutativeMultiply  ";

GeometricPSimplify::usage=
    "GeometricPSimplify[expr] Simplifies expr involving vector products.";

GeometricPToWI::usage=
    "GeometricPToWI[expr] writes a vector product of two elements in expr as \
a sum of wedge and inner products.";



Wedge::usage=
    " The wedge product is the standard Mathematica operator \[Wedge]  ";

WedgeSimplify::usage="WedgeSimplify[expr] Simplifies expr involving wedge \
products."

WedgeToGeometricP::usage=
    "WedgeToGeometricP[expr] Writes a wedge product of two vectors into a \
superposition of vector products. One of the vectors involved must be of \
first order.";



SortWedgeC1::usage=
    "SortWedgeC1[ expr ] sorts the wedge product of expr if expr is made only \
of first order vectors. \n There a general but slower function \
SortWedge[expr].";

SortWedge::usage="SortWedge[ expr ] Sorts the wedge products of expr.\n When \
expr is made of only first order vectors SOrtWedgeC1 is more efficient."





CenterDot::usage=
    "The inner product is the standard Mathematica operator CenterDot \
\[CenterDot] ";

InnerSimplify::usage=
    "InnerSimplify[expr] simplies expr involving inner products. ";



InnerToGeometricP::usage=
    "InnerToGeometricP[expr] writes a inner product of two vectors in terms \
of vector products. One of the vectors must be of first grade.";



SuperDagger::usage=
    " SuperDagger[expr] represents the HermitianConjugation of expr. This is \
evaluated by the EvaluateSuperDagger function.";

EvaluateSuperDagger::usage=
    "EvaluateSuperDagger[expr] evaluates the Hermitian conjugation expressed \
with SuperDagger.";

FullEvaluateSuperDagger::usage=
    "EvaluateSuperDagger[expr] evaluates the Hermitian conjugation expressed \
with SuperDagger.";



RealPart::usage="RealPart[expr] represents the real part of expr. RealPart is \
executed applying the function ExpandRealPart."

ExpandRealPart::usage="ExpandRealPart[expr] expands RealPart[x] if appears in \
expr."

ImaginaryPart::usage="ImaginaryPart[expr] represents the imaginary part of \
expr. ImaginaryPart is executed applying the function ExpandImaginaryPart."

ExpandImaginaryPart::usage="ExpandImaginaryPart[expr] expands \
ImaginaryPart[x] if appears in expr."



ScalarPart::usage="ScalarPart[expr] represents the real part of expr. \
ScalarPart is executed applying the function ExpandScalarPart."

ExpandScalarPart::usage="ExpandRealPart[expr] expands ScalarPart[x] if \
appears in expr."

VectorPart::usage="VectorPart[expr] represents the imaginary part of expr. \
VectorPart is executed applying the function ExpandImaginaryPart."

ExpandVectorPart::usage="ExpandVectorPart[expr] expands VectorPart[x] if \
appears in expr."













GradeAutomorphism::usage="GradeAutomorphism[expr]";

EvaluateGradeAutomorphism::usage="EvaluateGradeAutomorphism[expr]";

EvenPart::usage="EvenPart[expr]";

ExpandEvenPart::usage="ExpandEvenPart[expr]";

OddPart::usage="OddPart[expr]";

ExpandOddPart::usage="ExpandOddPart[expr]";



GetPossibleGrades::usage=
    "GetPossibleGrades[g][x] gives the posible grades of x in a space of \
grade g. Not all the given grades can be present but grades that are not in \
the list do not exist at all.";

GetGrade::usage=
    "GetGrade[g][x] gives the actual grades present in x in a space of grade \
g. ";

GeneralGetPossibleGrades::usage=
    "GeneralGetPossibleGrades[g][x] gets the grade of x in a space of grade g \
even if some of the elements in a vector product are the same.";

GetMod::usage=
    "GradeMod[g][n] gives the grade of n independent first order vectors \
wedge multiplied in a space of grade g. ";

TakeGrade::usage="TakeGrade[exp,n] Takes the part of expr with grade n. It \
keeps unevaluated until EvaluateTakeGrade is applied."

EvaluateTakeGrade::usage="EvaluateTakeGrade[expr] evaluates TakeGrade[x,n] \
that appear in expr."



SetCliffordBasisValueRules::usage="SetCliffordBasisValueRules[e,n] defines \
the properties of a system of orthonormal vectors with label e in a space of \
grade n. Each vector is of the FullForm: PVector[Subscript[e,i],1]"

BasisSimplify::usage="BasisSimplify[e][expr] Simplifies expr involving the \
Basis vectors of label e."



CliffordBasis::usage="CliffordBasis[e,n] generates a list of a orthonormal \
basis of label e and grade n.\n CliffordBasis[e,{n,m}] gives the list of \
vectors of grade m in a space of grade n."

BasisInnerToGeometricP::usage="BasisInnerToGeometricP[expr] expands inner \
products into vector products but the answer is only valid if all the vectors \
are first order independent orthonormal vectors."

BasisWedgeToGeometricP::usage="BasisWedgeToGeometricP[expr] expands wedge \
products into vector products but the answer is only valid if all the vectors \
are first order independent orthonormal vectors."



SetParavectorBasisValues::usage="SetParavectorBasisValues[e,n] sets the \
paravector basis over a previous regular basis of label e with dimension n. \n\
 
The paravectors are denoted: PVector[Subscript[e,i],{0,1}] \n The Tensorial \
declaration of bases indices must be of the form:
 DeclareBaseIndices[{0,1,2,3}]"



GeometricPower::usage="GeometricPower[expr,n] represents the power of expr to \
the integer n involving vector products."

CliffordExpToTrig::usage=
    "CliffordExpToTrig[a][ expr ] writes the exponentials of bivectors in \
terms of Sin and Cos functions. The vectors and bivectors must be written as \
a modulus times the unit vector or bivector that are assumed to have label a\n\

CliffordExpToTrig[a,b][ expr ] does the same but the unit bivector can be \
explicitly the geometric product of two vectors with labels a and b.";



CliffordSimplify[
    expr]:="CliffordSimplify[expr] tries to simplify expr unvolving wedge and \
vector products."

CliffordExpand::usage=
    "CliffordExpand[expr] distributes the vector product, wedge product and \
inner products over the sum of terms";

CliffordOperatorExpand::usage=
    "CliffordOperatorExpand[expr] distributes differential operators.";



VolumeElement::usage=
    "VolumeElement[g,e] gives the Volume element in terms of the basis \
vectors of label e.The volume element is the higher grade vector ina space of \
grade g. A third argument can be supplied to specify the flavor.";

Dual::usage=
    "Dual[expr] represnts the dual of expr in terms of the basis vectors of \
label e in a space of grade g.";

EvaluateDual::usage=
    "EvaluateDual[g,e][expr] evaluetes the dual of expr in terms of the basis \
vectors of label e in a space of grade g.\n EvaluateDual[g,e,flavor][expr] \
uses the basis with flavor.";

ExpandDual::uage="ExpandDual[ expr ]"



BarConjugation::usage="BarConjugation[ expr] reverses the sign of vector \
part."

ExpandBarConjugation::usage="ExpandBarConjugation[ expr ], Obsolete, use \
FullBarConjugation instead. "

EvaluateBarConjugation::usage="EvaluateBarConjugation[expr ]"

FullEvaluateBarConjugation::usage="FullBarConjugation[ expr ], evaluates the \
BarConjugation until it does not yield any change."



PushThrough::usage=
    "PushThrough[argslist, opts...] is a pure function which applies Through \
to subexpressions of the form a_. (h_)[args], within a larger expression,  \
where arglist is a list of the arguments to be pushed through. Through is \
applied repeatedly by an internal rule until a fixed point is reached or \
until it has been applied depth times. The depth is set by the option \
PushThroughDepth and has a default of 20. The option, Constants, can be used \
to specify a list of symbols or expressions which will be taken as constant. \
Numbers and Mathematica constants such as \[Pi], True, etc. will \
automatically be treated as constants. The option StopPatterns gives a list \
of patterns which will not be pushed through. Derivative[__][__] is a pattern \
which is never pushed through. The option PushThroughRules specifies whether \
rules should be pushed. The default is False.\nExample:\n(a x - 2 \
y)[1,2]//PushThrough[{1,2},Constants\[Rule]{a}] \[Implies] a x[1,2]- 2 \
y[1,2].\nPushThrough[opts...][(head)[args...]] will push through args if head \
is free of args, a shorthand for common cases.";

PushThroughDepth::usage=
    "PushThroughDepth is an option for PushThrough which tells the maximum \
depth to push through the arguments. The default value is 20.";

PushThroughRules::usage=
    "PushThroughRules is an option for PushThrough which tells whether Rules \
should be pushed through. The default value is False.";

StopPatterns::usage=
    "StopPatterns is an option for PushThrough which gives a list of patterns \
that will not be pushed through. The default value is {}. However \
Derivative[__][__] is never pushed through.";

$NewMessage[Constants,"usage"];
Constants::usage=
    Constants::usage<>
      " For the PushThrough routine, Constants specifies a list of symbols \
which will be treated as constants and not pushed through.";



Begin["`Private`"]





Format[PVector[x_]]:=
  StyleForm[SequenceForm[x],FontColor->RGBColor[0, 0, 0.996109]  ]

Format[PVector[x_,n_List]]:=
    StyleForm[SequenceForm[x],FontColor->RGBColor[0, 0, 0.996109]];

Format[PVector[x_,0]]:=StyleForm[SequenceForm[x],Magnification->1]

Format[PVector[x_,1]]:=
  StyleForm[SequenceForm[x],FontColor->RGBColor[0, 0, 0.996109],
    Magnification->N[Power[1,1/3]]]

Format[PVector[x_,2]]:=
  StyleForm[SequenceForm[x],
    FontColor->RGBColor[0.945327, 0.050782, 0.386725],
    Magnification->N[Power[2,1/3]]]

Format[PVector[x_,3]]:=
  StyleForm[SequenceForm[x],
    FontColor->RGBColor[0.269535, 0.785168, 0.210941],
    Magnification->N[Power[3,1/3]]]

Format[PVector[x_,n_]]:=
    StyleForm[SequenceForm[x],
      FontColor->RGBColor[0.500008, 0.250004, 0.250004],
      Magnification->N[Power[n,1/3]]];



Format[PVector[x_,{0,1}]]:=
  StyleForm[SequenceForm[x],FontColor->RGBColor[0.589853, 0, 0.292973],
    Magnification->N[Power[1,1/3]]]

Format[PVector[x_,{1,2}]]:=
  StyleForm[SequenceForm[x],
    FontColor->RGBColor[0.250004, 0.500008, 0.500008],
    Magnification->N[Power[1,1/3]]]



Format[PVector[x_,{0,2}]]:=
  StyleForm[SequenceForm[x],
    FontColor->RGBColor[0.996109, 0.500008, 0.250004],
    Magnification->N[Power[1,1/3]]]



Format[PVector[Subscript[x_,d_],n_]]:=
    StyleForm[Subscript[x,d],FontColor->RGBColor[0, 0, 0.62501]];

Format[PVector[Superscript[x_,u_],n_]]:=
    StyleForm[Superscript[x,u],FontColor->RGBColor[0, 0, 0.62501]];




Unprotect[NonCommutativeMultiply];

Format[NonCommutativeMultiply[u__]]:=Diamond[u];

Format[NonCommutativeMultiply[u_,v_]]:=(Diamond[u,v]);



Format[RealPart[w_]]:=
  RowBox[{SubscriptBox[
          RowBox[{"\[LeftAngleBracket]",w,"\[RightAngleBracket]"}],
          "\[ScriptCapitalR]"]}]//DisplayForm

Format[ImaginaryPart[w_]]:=
  RowBox[{SubscriptBox[
          RowBox[{"\[LeftAngleBracket]",w,"\[RightAngleBracket]"}],
          "\[ScriptCapitalI]"]}]//DisplayForm

Format[ScalarPart[w_]]:=
  RowBox[{SubscriptBox[
          RowBox[{"\[LeftAngleBracket]",w,"\[RightAngleBracket]"}],"S"]}]//
    DisplayForm

Format[VectorPart[w_]]:=
  RowBox[{SubscriptBox[
          RowBox[{"\[LeftAngleBracket]",w,"\[RightAngleBracket]"}],"V"]}]//
    DisplayForm

Format[ImaginaryScalarPart[w_]]:=
  RowBox[{SubscriptBox[
          RowBox[{"\[LeftAngleBracket]",w,"\[RightAngleBracket]"}],
          "\[ScriptCapitalI]S"]}]//DisplayForm

Format[EvenPart[w_]]:=
  RowBox[{SubscriptBox[
          RowBox[{"\[LeftAngleBracket]",w,"\[RightAngleBracket]"}],"+"]}]//
    DisplayForm

Format[OddPart[w_]]:=
  RowBox[{SubscriptBox[
          RowBox[{"\[LeftAngleBracket]",w,"\[RightAngleBracket]"}],"-"]}]//
    DisplayForm



Format[ Dual[a_] ]:= SequenceForm["(",Overscript["","*"], a ,")"];



Unprotect[Exp];
Unprotect[Power];

Format[Exp[x_]] := 
    Superscript[E,StyleForm[x,Magnification->1.3]];



Format[NonCommutativeMultiply[u:PVector[Subscript[e_,_],1]..]]:=
    Module[{i,a,ind1,in2},
      
      If[MemberQ[BasisLabelsList,e],
        StyleForm[
          Subscript[e,SequenceForm[Sequence@@GetProductBasisIndices[u]]],
          FontColor->RGBColor[0, 0, 0.996109]],
        StyleForm[Diamond[u],FontColor->RGBColor[0, 0, 0.996109]]
        ]
      
      ];

GetProductBasisIndices[u:PVector[Subscript[e_,_],1]..]:=
    Module[{i,a,ind1,in2},
      Flatten[{u}/.PVector[Subscript[_,i_],1]:> i]
      ];



Format[BarConjugation[PVector[a__]]]:=Overscript[PVector[a],"_"];

Format[BarConjugation[a_Symbol]]:=Overscript[a,"_"];

Format[BarConjugation[h_[a__]]]:=Overscript[h[a],SequenceForm[
        Sequence@@Table[
            "_",{2*Length[{a}]}
              ]]
      ];





GeometricPSimplify[x_]:=Module[{u,v,w,a},
    x//.{
        NonCommutativeMultiply[u_,a_?NumericQ*v_,w_]:> 
          a*NonCommutativeMultiply[u,v,w],
        
        NonCommutativeMultiply[u_PVector,PVector[a_,0]]:> 
          PVector[a,0]*u,
        NonCommutativeMultiply[PVector[a_,0],u_PVector]:> 
          PVector[a,0]*u,
        
        NonCommutativeMultiply[u__,v_*PVector[a_,0]]:> 
          PVector[a,0]*NonCommutativeMultiply[u,v],
        NonCommutativeMultiply[v_*PVector[a_,0],w__]:> 
          PVector[a,0]*NonCommutativeMultiply[v,w],
        NonCommutativeMultiply[u__,v_*PVector[a_,0],w__]:> 
          PVector[a,0]*NonCommutativeMultiply[u,v,w],
        
        NonCommutativeMultiply[u__,a_*v_,w__]:> 
          a*NonCommutativeMultiply[u,v,w]/;
            Count[a,PVector[__],{0,\[Infinity]}]===0,
        
        NonCommutativeMultiply[u__,a_*v_]:> 
          a*NonCommutativeMultiply[u,v]/;
            Count[a,PVector[__],{0,\[Infinity]}]===0,
        
        NonCommutativeMultiply[a_*v_,w__]:> 
          a*NonCommutativeMultiply[v,w]/;
            Count[a,PVector[__],{0,\[Infinity]}]===0,
        
        NonCommutativeMultiply[u_,a_]:> 
          a*u/;Count[a,PVector[__],{0,\[Infinity]}]===0,
        
        NonCommutativeMultiply[a_,w_]:> 
          a*w/;Count[a,PVector[__],{0,\[Infinity]}]===0,
        
        NonCommutativeMultiply[u__,a_]:> 
          a*NonCommutativeMultiply[u]/;
            Count[a,PVector[__],{0,\[Infinity]}]===0,
        
        NonCommutativeMultiply[a_,w__]:> 
          a*NonCommutativeMultiply[w]/;
            Count[a,PVector[__],{0,\[Infinity]}]===0,
        
         NonCommutativeMultiply[u:PVector[_,1],u:PVector[_,1]]:> 
          u\[CenterDot]u,
        
         NonCommutativeMultiply[v__,u:PVector[_,1],u:PVector[_,1],
            w__]:> u\[CenterDot]u*NonCommutativeMultiply[v,w],
        
         NonCommutativeMultiply[u:PVector[_,1],u:PVector[_,1],
            w__]:> u\[CenterDot]u*w,
        
         NonCommutativeMultiply[v__,u:PVector[_,1],
            u:PVector[_,1]]:> u\[CenterDot]u*v,
        
        NonCommutativeMultiply[u__,a:CenterDot[__],w__]:> 
          a*NonCommutativeMultiply[u,w],
        
        NonCommutativeMultiply[u_,a:CenterDot[__]]:> a*u,
        NonCommutativeMultiply[a:CenterDot[__],v_]:> a*v,
        
        NonCommutativeMultiply[u__,a:CenterDot[__]]:> 
          a*NonCommutativeMultiply[u],
        NonCommutativeMultiply[a:CenterDot[__],v__]:> 
          a*NonCommutativeMultiply[v]
        }
    ]

GeometricPToWI[w_]:=w/.u_**v_:> u\[Wedge]v+u\[CenterDot]v;



Wedge[a_,a_]:=0;

WedgeSimplify[x_]:=Module[{u,v,w,a,b,c},
    x//.{
        Wedge[0]:> 0,
        Wedge[a___,u_,b___,u_,c___]:> 0,
        Wedge[u___,a_?NumericQ,w___]:> 0,
        Wedge[u__,a_?NumericQ*v_,w__]:> a*Wedge[u,v,w],
        
        Wedge[u_PVector,a_]:> 
          0/;Count[a,PVector[__],{0,\[Infinity]}]===0,
        Wedge[a_,w_PVector]:> 
          0/;Count[a,PVector[__],{0,\[Infinity]}]===0,
        
        Wedge[u_PVector..,a_,w_PVector..]:> 
          0/;Count[a,PVector[__],{0,\[Infinity]}]===0,
        
        Wedge[u__,a_]:> 
          a*Wedge[u]/;Count[a,PVector[__],{0,\[Infinity]}]===0,
        Wedge[a_,w__]:> 
          a*Wedge[w]/;Count[a,PVector[__],{0,\[Infinity]}]===0,
        
        Wedge[___,a_.*PVector[_,0],___]:> 
          0/;Count[a,PVector[__],{0,\[Infinity]}]===0,
        
        Wedge[u__,v_*PVector[a_,0]]:> PVector[a,0]*Wedge[u,v],
        Wedge[v_*PVector[a_,0],w__]:> PVector[a,0]*Wedge[v,w],
        Wedge[u__,v_*PVector[a_,0],w__]:> 
          PVector[a,0]*Wedge[u,v,w],
        
        Wedge[u__,a_*v_,w__]:> 
          a*Wedge[u,v,w]/;Count[a,PVector[_,_],{0,\[Infinity]}]===0,
        Wedge[u__,a_*v_]:> 
          a*Wedge[u,v]/;Count[a,PVector[__],{0,\[Infinity]}]===0,
        Wedge[a_*v_,w__]:> 
          a*Wedge[v,w]/;Count[a,PVector[__],{0,\[Infinity]}]===0
        }
    ]

WedgeToGeometricP[w_]:=
  Module[{a,i,j},
    w/.{Wedge[PVector[a_,1],PVector[b_,1]]:> 
          1/2(PVector[a,1]**PVector[b,1]-PVector[b,1]**PVector[a,1]),
        
        Wedge[PVector[a_,k_],PVector[b_,1]]:> 
          1/2(PVector[a,k]**PVector[b,1]+(-1)^k*PVector[b,1]**PVector[a,k]),
        
        Wedge[PVector[b_,1],PVector[a_,k_]]:> 
          1/2(PVector[b,1]**PVector[a,k]+(-1)^k*PVector[a,k]**PVector[b,1])
        }]



SortWedgeC1::usage=
    "SortWedgeC1[ expr ] sorts the wedge product of expre if expr is made \
only of first order vectors. \n There is the more general but slower function \
SortWedge[expr].";

SortWedgeC1[x_]:=Module[{w},
    x/. 
      Wedge[w:PVector[_,1]..]:>  
        Signature[{w}]*Wedge[Sequence@@Sort[{w}]]
    ]

SortWedge[ w_ ]:=Module[{n,m,a,b},
      FixedPoint[
      WedgeSimplify[#]/.PVector[a_,n_]\[Wedge]PVector[b_,
                m_] :>    -(-1)^(n+m)*
                PVector[b,m]\[Wedge]PVector[a,n]/;Not[OrderedQ[{a,b}]]&,w]
    ]





Format[CenterDot[b_,c_]]:=SequenceForm["(",b,"\[CenterDot]",c,")"];

Format[CenterDot[b_Plus,c_Plus]]:=
    SequenceForm["(","(",b,")","\[CenterDot]","(",c,")",")"];

Format[CenterDot[b_,c_Plus]]:=
    SequenceForm["(",b,"\[CenterDot]","(",c,")",")"];

Format[CenterDot[b_Plus,c_]]:=
    SequenceForm["(","(",b,")","\[CenterDot]",c,")"];

InnerSimplify[x_]:=Module[{},
    x//.{
        CenterDot[u_PVector,v_PVector*a_Symbol]:> 
          a*CenterDot[u,v],
        CenterDot[a_Symbol*u_PVector,v_PVector]:> 
          a*CenterDot[u,v],
        CenterDot[u_PVector,v_PVector*a_?NumericQ]:> 
          a*CenterDot[u,v],
        CenterDot[a_?NumericQ*u_PVector,v_PVector]:> 
          a*CenterDot[u,v],
        
        CenterDot[u_,v_*a:PVector[_,0]]:> a*CenterDot[u,v],
        CenterDot[v_*a:PVector[_,0],w_PVector]:> 
          a*CenterDot[v,w],
        
        CenterDot[u_,a_*v_]:> 
          a*CenterDot[u,v]/;Count[a,PVector[__],{0,\[Infinity]}]===0,
        CenterDot[a_*v_,w_]:> 
          a*CenterDot[v,w]/;Count[a,PVector[__],{0,\[Infinity]}]===0}
    ]







InnerToGeometricP[w_]:=
  Module[{a,b,k},
    w/.{CenterDot[PVector[a_,1],PVector[b_,1]]:> 
          1/2(PVector[a,1]**PVector[b,1]+PVector[b,1]**PVector[a,1]),
        
        CenterDot[PVector[a_,k_],PVector[b_,1]]:> 
          1/2(PVector[a,k]**PVector[b,1]-(-1)^k*PVector[b,1]**PVector[a,k]),
        
        CenterDot[PVector[b_,1],
            PVector[a_,k_]]:> -1/
              2(PVector[a,k]**PVector[b,1]-(-1)^k*PVector[b,1]**PVector[a,k])
        }
    ]







EvaluateSuperDagger[w_]:=Module[{a,b,c},
      w//.{
          SuperDagger[a_Symbol]:> a,
          SuperDagger[Complex[a_,b_]]:>Complex[a,-b],
          
          SuperDagger[c_*Complex[a_,b_]]:>
            SuperDagger[c]*Complex[a,-b],
          SuperDagger[a_?NumericQ]:> a/;Head[a]=!=Complex,
          
          SuperDagger[a_?NumericQ*b_]:> 
            a*SuperDagger[b]/;Head[a]=!=Complex,
          SuperDagger[a_Symbol*b_]:> a*SuperDagger[b],
          
          SuperDagger[PVector[a_,1]]:> PVector[a,1],
          
          SuperDagger[PVector[a_,{0,1}]]:> PVector[a,{0,1}],
          
          SuperDagger[BarConjugation[PVector[a_,{0,1}]]]:>
            BarConjugation@ PVector[a,{0,1}],
          
          SuperDagger[PVector[a_,0]]:> PVector[a,0],
          
          SuperDagger[b_*PVector[a_,0]]:> 
            PVector[a,0]*SuperDagger[b],
          
          SuperDagger[PVector[a_,1]]:> PVector[a,1],
          
          SuperDagger[SuperDagger[a_]]:>a,
           
          SuperDagger[BarConjugation[SuperDagger[a_]]]:>
            BarConjugation[a],
          
          
          SuperDagger[PVector[a_,n_]]:> 
            Module[{q},PVector[a,n]*Signature[Reverse@Array[q,n]]],
          
          SuperDagger[Exp[a_]]:> Exp[SuperDagger[a]],
          SuperDagger[a_Plus]:> Map[SuperDagger,a],
          
          SuperDagger[a_**b_]:> SuperDagger[b]**SuperDagger[a],
          
          SuperDagger[Wedge[a__]]:> 
            Wedge[ Sequence@@(SuperDagger/@Reverse[{a}]) ],
          
          SuperDagger[a_\[CenterDot]b_]:> 
            SuperDagger[b]\[CenterDot]SuperDagger[a],
          
          
          SuperDagger[a_]:> 
            a/;((Count[a,PVector[__],{0,\[Infinity]}]===0)&&(Head[a]=!=
                      Complex)),
          
          SuperDagger[a_Times]:> SuperDagger/@a,
          
          
          SuperDagger[ 
              HoldPattern[
                PVector[Subscript["\[PartialD]",a_],0][c_] ] ]:>
            PVector[Subscript["\[PartialD]",a],0][SuperDagger@c] ,
          
          
          SuperDagger[ 
              HoldPattern[
                PVector["\[Del]",1][c_] ] ]:>SuperDagger[c][
              PVector["\[Del]",1]],
          
          
          SuperDagger[ 
              HoldPattern[c_[PVector["\[Del]",1]] ] ]:>PVector[
                "\[Del]",1][SuperDagger[c]]
          }
      ]//GeometricPSimplify

FullEvaluateSuperDagger[w_]:=Module[{},
      FixedPoint[
        EvaluateSuperDagger,w]
      ]//ExpandAll



ExpandRealPart[x_]:=Module[{w,a},
      Expand[x]//.{
          
          RealPart[Equal[a_,b_]]:> 
            Equal[RealPart[a],RealPart[b]],
          
          RealPart[a_?NumericQ*w_]:>
            a*1/2(w+EvaluateSuperDagger[SuperDagger[w]]),
          
          RealPart[a_Symbol*w_]:>
            a*1/2(w+EvaluateSuperDagger[SuperDagger[w]]),
          
          RealPart[w_*a:PVector[_,0]]:>
            a*1/2(w+EvaluateSuperDagger[SuperDagger[w]]),
          
          RealPart[w_**a:PVector[_,0]]:>
            a*1/2(w+EvaluateSuperDagger[SuperDagger[w]]),
          
          RealPart[
              w_]:>1/2(w+EvaluateSuperDagger[SuperDagger[w]])
          }
      ]//Expand

ExpandImaginaryPart[x_]:=Module[{w,a},Expand[x]//.{
          
          ImaginaryPart[Equal[a_,b_]]:> 
            Equal[ImaginaryPart[a],ImaginaryPart[b]],
          
          ImaginaryPart[a_?NumericQ*w_]:>
            a*1/2(w-EvaluateSuperDagger[SuperDagger[w]]),
          
          ImaginaryPart[a_Symbol*w_]:>
            a*1/2(w-EvaluateSuperDagger[SuperDagger[w]]),
          
          ImaginaryPart[w_*a:PVector[_,0]]:>
            a*1/2(w-EvaluateSuperDagger[SuperDagger[w]]),
          
          ImaginaryPart[w_**a:PVector[_,0]]:>
            a*1/2(w-EvaluateSuperDagger[SuperDagger[w]]),
          
          ImaginaryPart[
              w_]:>1/2(w-EvaluateSuperDagger[SuperDagger[w]])
          }
      ]//Expand















OnlyZeroOrder[w_]:=Count[w,PVector[_,_],{0,\[Infinity]}]===0

EvaluateBarConjugation[w_]:=Module[{a,c,k,n,q,step},
        step=
          w/.{BarConjugation[NonCommutativeMultiply[a_,b__]] :> 
                NonCommutativeMultiply@@Map[BarConjugation,Reverse[{a,b}]  ],
              BarConjugation[a_Plus]:> Map[BarConjugation,a],
              
              BarConjugation[a_?NumericQ*b_]:> 
                a*BarConjugation[b],
              BarConjugation[a_Symbol*b_]:> a*BarConjugation[b],
              
              BarConjugation[b_*a:PVector[_,0]]:> 
                a*BarConjugation[b],
              
              BarConjugation[a_*b_]:> 
                a*BarConjugation[b]/;
                  Count[a,PVector[__],{0,\[Infinity]}]===
                    Count[a,PVector[_,0],{0,\[Infinity]}],
              BarConjugation[a_*b_]:> 
                a*BarConjugation[b]/;Count[a,PVector[__],{0,\[Infinity]}]===0
              };
        
        step/.{BarConjugation[a_Symbol]:> a,
            BarConjugation[a_?NumericQ]:> a,
            
            BarConjugation[a_]:> 
              a/;Count[a,PVector[__],{0,\[Infinity]}]===0,
            BarConjugation[BarConjugation[a_]]:> a,
            
            BarConjugation[SuperDagger[BarConjugation[a_]]]:> 
              SuperDagger[a],
            BarConjugation[PVector[a_,0]]:> PVector[a,0],
            BarConjugation[PVector[a_,1]]:> -PVector[a,1],
            BarConjugation[PVector[a_,2]]:> -PVector[a,2],
            
            BarConjugation[
                PVector[a_,1]\[CenterDot]PVector[a_,1]]:> 
              PVector[a,1]\[CenterDot]PVector[a,1],
            
            
            BarConjugation[
                PVector[a_,n_]]:> (-1)^n*SuperDagger@PVector[a,n]/;
                Not[VectorQ[n]],
            
            
            BarConjugation[k_*PVector[a_,0]]:> 
              PVector[a,0]*BarConjugation[k],
            
            BarConjugation[a_]:> 
              a/;Count[a,PVector[__],{0,\[Infinity]},Heads->True]===
                  Count[a,PVector[_,0],{0,\[Infinity]},Heads->True],
            
            
            BarConjugation[k_*a_]:> 
              k*BarConjugation[a]/;Count[k,PVector[__],{0,\[Infinity]}]===0,
            
            BarConjugation[ 
                HoldPattern[
                  PVector[Subscript["\[PartialD]",a_],0][
                    k_] ] ]:>PVector[Subscript["\[PartialD]",a],
                  0][BarConjugation@k] ,
            
            
            BarConjugation[ 
                HoldPattern[
                  PVector["\[Del]",1][   
                    PVector[c_,0]   ] ] ]:>-PVector["\[Del]",1][
                  PVector[c,0]],
            
            
            BarConjugation[ 
                HoldPattern[
                  PVector["\[Del]",1][c_] ] ]:>-BarConjugation[c][
                  PVector["\[Del]",1]],
            
            
            BarConjugation[ 
                HoldPattern[
                  c_[PVector["\[Del]",1]] ] ]:>-PVector["\[Del]",
                    1][BarConjugation[c]]
            }
        ]//GeometricPSimplify;

FullEvaluateBarConjugation[w_]:=Module[{},
      FixedPoint[
        EvaluateBarConjugation,w]
      ]//ExpandAll

ExpandBarConjugation[w_]:=Module[{a,b,Du},
      FixedPoint[
        EvaluateBarConjugation,w]
      ]//Expand



ExpandScalarPart[x_]:=
  Module[{w,a,b,step1,step2},
        step1=x/.{ScalarPart[Equal[a_,w_]]:>
                Equal[ScalarPart[a],ScalarPart[w]]};
        
        step2=step1/.
            {ScalarPart[a_?NumericQ*w_]:>
                a*1/2(w+ExpandBarConjugation[BarConjugation[w]]),
              ScalarPart[a_Symbol*w_]:>
                a*1/2(w+ExpandBarConjugation[BarConjugation[w]]),
              ScalarPart[w_*a:PVector[_,0]]:>
                a*1/2(w+ExpandBarConjugation[BarConjugation[w]]),
              ScalarPart[w_**a:PVector[_,0]]:>
                a*1/2(w+ExpandBarConjugation[BarConjugation[w]]),
              ScalarPart[
                  w_]:>1/
                    2(w+ExpandBarConjugation[BarConjugation[w]])};
        Expand[step2]/.a_[PVector[b__]]:>
            PushThrough[StopPatterns->{PVector[_,_]}][a[PVector[b]]]]//
      GeometricPSimplify//Expand

ExpandVectorPart[x_]:=Module[{w,a,b,step,step2},
      step1=x/.{
            
            VectorPart[Equal[a_,w_]]:> 
              Equal[VectorPart[a],VectorPart[w]]};
      
      step2=step1/.
          {
            
            VectorPart[a_?NumericQ*w_]:>
              a*1/2(w-ExpandBarConjugation[BarConjugation[w]]),
            
            VectorPart[a_Symbol*w_]:>
              a*1/2(w-ExpandBarConjugation[BarConjugation[w]]),
            
            VectorPart[w_*a:PVector[_,0]]:>
              a*1/2(w-ExpandBarConjugation[BarConjugation[w]]),
            
            VectorPart[w_**a:PVector[_,0]]:>
              a*1/2(w-ExpandBarConjugation[BarConjugation[w]]),
            
            VectorPart[
                w_]:>1/
                  2(w-ExpandBarConjugation[BarConjugation[w]])
            };
      Expand[step2]/.a_[PVector[b__]]:> 
          PushThrough[StopPatterns->{PVector[_,_]}][a[PVector[b]]]
      ]//Expand



GradeAutomorphism[x_]:=SuperDagger@BarConjugation[x];

EvaluateGradeAutomorphism[x_]:=x//EvaluateBarConjugation//EvaluateSuperDagger;

ExpandEvenPart[x_]:=Module[{w},
    x/.EvenPart[w_]:> 
        1/2*(w+EvaluateGradeAutomorphism@GradeAutomorphism[w])
    ]

ExpandOddPart[x_]:=Module[{w},
    x/.OddPart[w_]:> 
        1/2*(w-EvaluateGradeAutomorphism@GradeAutomorphism[w])
    ]



GradeMod[g_][x_List]:= Map[GradeMod[g][#]&,x];
GradeMod[g_][x_]=Abs[Mod[x,2*g]-2*Mod[x,g]];

GradeRange[g_][m_,n_]:=Module[{i},GradeMod[g][Table[i,{i,Abs[m-n],m+n,2}]]]

GetPossibleGrades[g_][x_]:=Module[{terms,grades,Ggrades,m,n,a},
    terms=
      CliffordSimplify@
          Expand[CliffordExpand[x]]//.{a_*b_:> 
            b*PVector[a,0]/;(a=!=PVector&&
                  Count[a,PVector[__],{1,\[Infinity]}]===0),
          
          a_+b_:> 
            b+PVector[a,0]/;(a=!=PVector&&
                  Count[a,PVector[__],{1,\[Infinity]}]===0)};
    
    Ggrades=(terms/.Plus->List)/.PVector[_,n_]:> 
          G[Unique[i]][Flatten[{n}]];
    
    grades=Ggrades//. {
          
          G[i_][n_]\[Wedge]G[_][m_]:>
            G[i][Flatten@ Outer[ GradeMod[g][Plus[#1,#2]]&,m,n]],
          
          G[i_][n_]**G[_][m_]:>
            G[i][Flatten@ Outer[GradeRange[g][#1,#2]&,m,n]]
          };
    
    Union@Flatten[ grades /.G[_]->Sequence]
    ]



ExpandVectorInBasis[{e_,g_},a_,n_]:=Module[{},
    CliffordBasis[e,{g,n}].Array[a,Binomial[g,n]]
    ]

ZeroGradeQ[x_]:=Module[{step,step2},
    step=Expand@CliffordExpand[x]/.{NonCommutativeMultiply[__]->0,
          Wedge[__]->0,CenterDot[__]->0};
    
    step2=step/.PVector[__]->0;
    
    If[step2===0,False,True]
    ]

GetGrade[g_][x_]:=Module[{a,n,G,step,step2,step3,step4,step5,f},
    BasisLabelsListOld=BasisLabelsList;
    SetCliffordBasisValueRules[e,g];
    step=x/.{PVector[a_,n_List]:> 
            Plus@@(ExpandVectorInBasis[{e,g},a,#]&/@n),
          PVector[a_,n_]:> ExpandVectorInBasis[{e,g},a,n]};
    step2=(BasisSimplify[e][Expand@CliffordExpand[step]]/.Wedge->
            NonCommutativeMultiply);
    
    step3=FixedPoint[
        BasisSimplify[e]@
            CliffordExpand@BasisInnerToGeometricP@CliffordSimplify[#]&
        ,step2];
    
    step4=
      step3/.{b_*NonCommutativeMultiply[a__]:> G[Length[{a}]],
          b_*PVector[_,_]:> G[1]};
    step5=(step4/.b_*G[a_]-> G[a])/.f_[_]:> 0/;f=!=G;
    step6=(List@@step5)/.G->Identity;
    If[ZeroGradeQ[step2],Union@Flatten@Prepend[{step6},0],step6]
    ]



Format[TakeGrade[w_,n_]]:=
  RowBox[{SubscriptBox[
          RowBox[{"\[LeftAngleBracket]",w,"\[RightAngleBracket]"}],n]}]//
    DisplayForm

EvaluateTakeGrade[x_]:=Module[{w,m,n},
      x/.{
          
          
          TakeGrade[PVector[a_,k_]**PVector[b_,1],m_]:>  
            1/2(PVector[a,k]**PVector[b,1]+(-1)^k*PVector[b,1]**PVector[a,k])/;
              m===k+1,
          
          TakeGrade[PVector[a_,1]**PVector[b_,k_],m_]:> 
            1/2(PVector[a,1]**PVector[b,k]+(-1)^k*PVector[b,k]**PVector[a,1])/;
              m===k+1,
          
          
          TakeGrade[PVector[a_,k_]**PVector[b_,1],m_]:> 
            1/2(PVector[a,k]**PVector[b,1]-(-1)^k*PVector[b,1]**PVector[a,k])/;
              m===k-1,
          
          TakeGrade[PVector[a_,1]**PVector[b_,k_],k_-1]:> 
            1/2(PVector[a,1]**PVector[b,k]-(-1)^k*PVector[b,k]**PVector[a,1])/;
              m===k-1,
          
          TakeGrade[PVector[a_,1]**PVector[b_,k_],m_]:> 
            0/;(m=!=k+1)&&(m=!=k-1),
          
          
          TakeGrade[PVector[a_,k_]**PVector[b_,1_],m_]:> 
            0/;(m=!=k+1)&&(m=!=k-1)
          
          }
      ];





SetCliffordBasisValueRules[e_,n_,flavor_:Identity]:=
  Module[{initial,OldBasisLabelsList,i,j,eUpValuesDot2,eUpValuesVP},
    
    OldBasisLabelsList=BasisLabelsList;
    BasisLabelsList={};
    BasisLabelsList=Union@Append[OldBasisLabelsList,e];
    
    initial=UpValues[e];
    Clear[e];
    
    eUpValuesDot1=Outer[
          (PVector[Subscript[e,flavor[#1]],1]\[CenterDot]
                  PVector[Subscript[e,flavor[#2]],1]:> 0)&,
          Sequence@@Table[{i,j},{i,1,n},{j,1,n}]
          ]//Flatten;
    
    eUpValuesDot2=eUpValuesDot1/.RuleDelayed[
            
            PVector[Subscript[e,i_],1]\[CenterDot]
              PVector[Subscript[e,i_],1],_]:> RuleDelayed[
            PVector[Subscript[e,i],1]\[CenterDot]PVector[Subscript[e,i],1],
            1];
    
    eUpValuesVP=Map[
        (PVector[Subscript[e,flavor[#1]],1]**
                PVector[Subscript[e,flavor[#1]],1]:> 1)&,
        Range[n] ];
    
    UpValues[e]=Union@Flatten[{eUpValuesVP,eUpValuesDot2,initial}];
    ]



BasisSimplify[e_][x_]:=
    Module[{step,step2,b,u},
      step=FixedPoint[
          GeometricPSimplify[#/.UpValues[e]]/.{NonCommutativeMultiply[
                    u:PVector[Subscript[e,_],1],b:PVector[Subscript[e,_],1],
                    u:PVector[Subscript[e,_],1] ]:>-b,
                
                
                NonCommutativeMultiply[u:PVector[Subscript[e,_],1],
                    b:PVector[Subscript[e,_],1]..,
                    u:PVector[Subscript[e,_],1]]:>
                  NonCommutativeMultiply[b]*(-1)^Length[{b}]
                }&,CliffordSimplify@x];
      
      step2=
        step/.NonCommutativeMultiply[
              b:PVector[Subscript[e,_],1]..]:>
            Signature[{b}]*NonCommutativeMultiply[Sequence@@Sort[{b}]];
      
      EvaluateSuperDagger@EvaluateBarConjugation@GeometricPSimplify[step2]
      ];



iBase[e_,flavor_:Identity][x_]:=(PVector[Subscript[e,flavor[#1]],1]&)/@x

IntroNCM[{x_}]:=x;
IntroNCM[x_]:=NonCommutativeMultiply@@x;

CliffordBasis[e_,n_,flavor_:Identity]:=Module[{i},
    Prepend[Table[
        Map[IntroNCM,Map[iBase[e,flavor],KSubsets[Range[n],i]]]
        ,{i,1,n}],1]
    ]

CliffordBasis[e_,{n_,m_},flavor_:Identity]:=Module[{i},
    CliffordBasis[e,n,flavor][[m+1]]
    ]

BasisInnerToGeometricP[w_]:=Module[{a,b,c,k},
    w/.{
        CenterDot[c:Wedge[a__],PVector[b_,1]]:> 
          1/2(c**PVector[b,1]-(-1)^Length[{a}]*PVector[b,1]**c),
        
        CenterDot[PVector[b_,1],c:Wedge[a__]]:> 
          1/2(PVector[b,1]**c-(-1)^Length[{a}]*c**PVector[b,1]),
        
        CenterDot[c:NonCommutativeMultiply[a__],PVector[b_,1]]:> 
          1/2(c**PVector[b,1]-(-1)^Length[{a}]*PVector[b,1]**c),
        
        CenterDot[PVector[b_,1],c:NonCommutativeMultiply[a__]]:> 
          1/2(PVector[b,1]**c-(-1)^Length[{a}]*c**PVector[b,1])
        }
    ]

BasisWedgeToGeometricP[w_]:=Module[{a,b,c,k},
    w/.{
        Wedge[c:NonCommutativeMultiply[a__],PVector[b_,1]]:> 
          1/2(c**PVector[b,1]+(-1)^Length[{a}]*PVector[b,1]**c),
        
        Wedge[PVector[b_,1],c:NonCommutativeMultiply[a__]]:> 
          1/2(PVector[b,1]**c+(-1)^Length[{a}]*c**PVector[b,1])
        }
    ]



SetParavectorBasisValues[e_,n_,flavor_:Identity]:=Module[{new,newup},
    initial=UpValues[e];
    Clear[e];
    
    new={
        PVector[Subscript[e,flavor@0],{0,1}]:> 
          PVector[Subscript[e,flavor@0],0],
        PVector[Subscript[e,flavor@#],{0,1}]:> 
              PVector[Subscript[e,flavor@#],1]&/@(Range[n]-1),
        
        PVector[Subscript[e,flavor@0],0]**
              PVector[Subscript[e,flavor@#],1]:> 
            PVector[Subscript[e,flavor@#],1]
          &/@(Range[n]-1),
        
        PVector[Subscript[e,flavor@0],0]**
            PVector[Subscript[e,flavor@0],0]:>
          PVector[Subscript[e,flavor@0],0],
        
        PVector[Subscript[e,flavor@0],0]*
            PVector[Subscript[e,flavor@0],0]:> 
          PVector[Subscript[e,flavor@0],0],
        
        PVector[Subscript[e,flavor@0],0]^_:> 
          PVector[Subscript[e,flavor@0],0],
        
        SuperDagger[PVector[Subscript[e,flavor@0],0]]:> 
          PVector[Subscript[e,flavor@0],0],
        
        BarConjugation[PVector[Subscript[e,flavor@0],0]]:> 
          PVector[Subscript[e,flavor@0],0],
        
        SuperDagger@
            BarConjugation[PVector[Subscript[e,flavor@0],0]]:> 
          PVector[Subscript[e,flavor@0],0],
        
        BarConjugation@
            SuperDagger[PVector[Subscript[e,flavor@0],0]]:> 
          PVector[Subscript[e,flavor@0],0]
        };
    
    newup={
        PVector[Superscript[e,flavor@0],{0,1}]:> 
          PVector[Superscript[e,flavor@0],0],
        PVector[Superscript[e,flavor@#],{0,1}]:> 
              PVector[Superscript[e,flavor@#],1]&/@(Range[n]-1),
        
        PVector[Superscript[e,flavor@0],0]**
              PVector[Superscript[e,flavor@#],1]:> 
            PVector[Superscript[e,flavor@#],1]
          &/@(Range[n]-1),
        
        PVector[Superscript[e,flavor@0],0]**
            PVector[Superscript[e,flavor@0],0]:>
          PVector[Superscript[e,flavor@0],0],
        
        PVector[Superscript[e,flavor@0],0]*
            PVector[Superscript[e,flavor@0],0]:> 
          PVector[Superscript[e,flavor@0],0],
        
        PVector[Superscript[e,flavor@0],0]^_:> 
          PVector[Superscript[e,flavor@0],0],
        
        SuperDagger[PVector[Superscript[e,flavor@0],0]]:> 
          PVector[Superscript[e,flavor@0],0],
        
        BarConjugation[PVector[Superscript[e,flavor@0],0]]:> 
          PVector[Superscript[e,flavor@0],0],
        
        SuperDagger@
            BarConjugation[PVector[Superscript[e,flavor@0],0]]:> 
          PVector[Superscript[e,flavor@0],0],
        
        BarConjugation@
            SuperDagger[PVector[Superscript[e,flavor@0],0]]:> 
          PVector[Superscript[e,flavor@0],0]
        };
    
    newDot1=Outer[
          (PVector[Superscript[e,flavor[#1]],1]\[CenterDot]PVector[
                    Superscript[e,flavor[#2]],1]:> 0)&,
          Sequence@@Table[{i,j},{i,1,n},{j,1,n}]
          ]//Flatten;
    
    newDot2=newDot1/.RuleDelayed[
            
            PVector[Superscript[e,i_],1]\[CenterDot]PVector[Superscript[e,i_],
                1],_]:> RuleDelayed[
            
            PVector[Superscript[e,i],1]\[CenterDot]PVector[Superscript[e,i],
                1],1];
    
    newVP=Map[
        (PVector[Superscript[e,flavor[#1]],1]**
                PVector[Superscript[e,flavor[#1]],1]:> 1)&,
        Range[n] ];
    
    UpValues[e]=Union@Flatten[{initial,new,newup,newVP,newDot2}];
    ]



GeometricPower[w_,0]:=1;

GeometricPower[w_,1]:=w;

GeometricPower[w_,n_]:=NonCommutativeMultiply@@Table[w,{n}]



CliffordExpToTrig[a_][w_]:=
  Module[{},
    w/.{Exp[\[Theta]_*PVector[a,2]] :> 
          Cos[\[Theta]]+PVector[a,2]*Sin[\[Theta]],
        Exp[\[Theta]_*PVector[a,1]] :> 
          Cosh[\[Theta]]+PVector[a,1]*Sinh[\[Theta]]
        }]

CliffordExpToTrig[a_,b_][w_]:=
  Module[{},
    w/.{Exp[\[Theta]_*PVector[a,1]**PVector[b,1]] :> 
          Cos[\[Theta]]+PVector[a,1]**PVector[b,1]*Sin[\[Theta]]
        }]



CliffordSimplify[x_]:=Module[{a,b},
    GeometricPSimplify[WedgeSimplify[InnerSimplify[x]]]
    ]





CliffordExpand[Equal[x_,y_]]:=Equal[CliffordExpand[x],CliffordExpand[y]];

CliffordExpand[VectorPart[x_]]:=VectorPart[CliffordExpand[x]];

CliffordExpand[ScalarPart[x_]]:=ScalarPart[CliffordExpand[x]];

CliffordExpand[RealPart[x_]]:=RealPart[CliffordExpand[x]];

CliffordExpand[ImaginaryPart[x_]]:=ImaginaryPart[CliffordExpand[x]];

CliffordExpand[x_]:=
  Module[{a,b,c,step1,step2,n},
      step1=x/.{HoldPattern[Wedge[Plus[b__],c_]]:>
              Map[CliffordExpand[Wedge[#,c]]&,Plus[b]],
            HoldPattern[Wedge[b_,Plus[c__]]]:>
              Map[CliffordExpand[Wedge[b,#]]&,Plus[c]],
            HoldPattern[Wedge[a__,Plus[b__],c__]]:>
              Wedge[Map[CliffordExpand[Wedge[a,#]]&,Plus[b]],c],
            NonCommutativeMultiply[b_Plus,c_]:>
              Map[CliffordExpand[NonCommutativeMultiply[#,c]]&,b],
            NonCommutativeMultiply[b_,c_Plus]:>
              Map[CliffordExpand[NonCommutativeMultiply[b,#]]&,c],
            NonCommutativeMultiply[a__,b_Plus,c__]:>
              NonCommutativeMultiply[
                Map[CliffordExpand[NonCommutativeMultiply[a,#]]&,b],c],
            CenterDot[b_Plus,c_]:>
              Map[CliffordExpand[CenterDot[#,c]]&,b],
            CenterDot[b_,c_Plus]:>
              Map[CliffordExpand[CenterDot[b,#]]&,c]}
      ]//ExpandAll

CliffordOperatorExpand[Equal[x_,y_]]:=
    Equal[CliffordOperatorExpand[x],CliffordOperatorExpand[y]];

CliffordOperatorExpand[VectorPart[x_]]:=VectorPart[CliffordOperatorExpand[x]];

CliffordOperatorExpand[ScalarPart[x_]]:=ScalarPart[CliffordOperatorExpand[x]];

CliffordOperatorExpand[RealPart[x_]]:=RealPart[CliffordOperatorExpand[x]];

CliffordOperatorExpand[ImaginaryPart[x_]]:=
    ImaginaryPart[CliffordOperatorExpand[x]];

CliffordOperatorExpand[x_]:=
  Module[{a,b,c,step1,step2,n},
      step1=x/.{HoldPattern[Wedge[Plus[b__],c_]]:>
              Map[CliffordExpand[Wedge[#,c]]&,Plus[b]],
            HoldPattern[Wedge[b_,Plus[c__]]]:>
              Map[CliffordExpand[Wedge[b,#]]&,Plus[c]],
            HoldPattern[Wedge[a__,Plus[b__],c__]]:>
              Wedge[Map[CliffordExpand[Wedge[a,#]]&,Plus[b]],c],
            NonCommutativeMultiply[b_Plus,c_]:>
              Map[CliffordExpand[NonCommutativeMultiply[#,c]]&,b],
            NonCommutativeMultiply[b_,c_Plus]:>
              Map[CliffordExpand[NonCommutativeMultiply[b,#]]&,c],
            NonCommutativeMultiply[a__,b_Plus,c__]:>
              NonCommutativeMultiply[
                Map[CliffordExpand[NonCommutativeMultiply[a,#]]&,b],c],
            CenterDot[b_Plus,c_]:>
              Map[CliffordExpand[CenterDot[#,c]]&,b],
            CenterDot[b_,c_Plus]:>
              Map[CliffordExpand[CenterDot[b,#]]&,c]};
      
      step2=
        ExpandAll[
          PushThrough[
                StopPatterns->{HoldPattern[PVector[__]],
                    HoldPattern[BarConjugation[_]],
                    HoldPattern[SupperDagger[_]]}][ 
              step1]/.{HoldPattern[PVector["\[Del]",1][a_Plus]]:>
                PVector["\[Del]",1]/@a,
              HoldPattern[
                  PVector[Subscript["\[PartialD]",c_],0][
                    a_Plus]]:>
                PVector[Subscript["\[PartialD]",c],0]/@a}];
      
      step2/.{PVector[a_][b_]:> 
            PVector[a]**b/;(a=!="\[Del]")&&(a=!="\[PartialD]")&&
                Not[MatchQ[a,Subscript["\[PartialD]",_]]],
          
          PVector[a_,n_][b_]:> 
            PVector[a,n]**b/;(a=!="\[Del]")&&(a=!="\[PartialD]")&&
                Not[MatchQ[a,Subscript["\[PartialD]",_]]]
          }
      ]//ExpandAll





VolumeElement[g_,e_,flavor_:Identity]:=
    NonCommutativeMultiply@@Table[PVector[Subscript[e,flavor[i]],1],{i,1,g}];

EvaluateDual[g_,e_,flavor_:Identity][w_]:=Module[{x,vol},
      vol=EvaluateSuperDagger[SuperDagger[VolumeElement[g,e,flavor]]];
      w/.Dual[x_]:> x**vol
      ];

HoldPattern[Dual[Dual[a_]]]:=a/;Head[a]=!=Dual;

ExpandDual[w_]:=Module[{a,b,Du},
    step=w/.{
          Dual[Plus[a__]]:> Map[Du,Plus[a]]
          };
    step/.Du-> Dual
    ]





PVector["\[Del]",1][ a_?NumericQ]:=0

PVector["\[Del]",1][ a_Symbol]:=0

PVector["\[Del]",1][ a_]:=0/;Count[a,PVector[__],{0,\[Infinity]}]===0;

PVector[Subscript["\[PartialD]",c_],0][ a_?NumericQ]:=0

PVector[Subscript["\[PartialD]",c_],0][ a_Symbol]:=0

PVector[Subscript["\[PartialD]",c_],0][ a_]:=
    0/;Count[a,PVector[__],{0,\[Infinity]}]===0;

PVector["\[Del]",1][ a_?NumericQ*b_]:=a*PVector["\[Del]",1][b];

PVector["\[Del]",1][ a_Symbol*b_]:=a*PVector["\[Del]",1][b];

PVector["\[Del]",1][ a_*b_]:=
  a*PVector["\[Del]",1][b]/;Count[a,PVector[__],{0,\[Infinity]}]===0

PVector[Subscript["\[PartialD]",c_],0][a_?NumericQ*b_]:=
    a*PVector[Subscript["\[PartialD]",c],0][b];

PVector[Subscript["\[PartialD]",c_],0][a_Symbol*b_]:=
    a*PVector[Subscript["\[PartialD]",c],0][b];

PVector[Subscript["\[PartialD]",c_],0][a_*b_]:=
    a*PVector[Subscript["\[PartialD]",c],0][b]/;
      Count[a,PVector[__],{0,\[Infinity]}]===0;



Options[PushThrough]={PushThroughDepth->20,StopPatterns->{},
      PushThroughRules->False,Constants->{}};

PushThrough[{args___},opts___?OptionQ]:=Module[{depth,rule,stoppatterns,pushrules,constnants,mathconstants},depth=PushThroughDepth/. {opts}/. Options[PushThrough];stoppatterns=StopPatterns/. {opts}/. Options[PushThrough];pushrules=PushThroughRules/. {opts}/. Options[PushThrough];constants=Constants/. {opts}/. Options[PushThrough];stoppatterns=Join[stoppatterns,{
\!\(\*SuperscriptBox[\(__\), \*
TagBox[
RowBox[{"(", "__", ")"}],
Derivative],
MultilineFunction->None]\)}];mathconstants=Join[Alternatives@@constants,I|Root[_,__]|C[_]|$Aborted|$Failed|True|False|DirectedInfinity|Indeterminate|Null|(_->_)|(_:>_)];If[pushrules,mathconstants=Drop[mathconstants,-2]];rule:=a_. (h_/;!AtomQ[h]&&!Or@@(MatchQ[h,#1]&)/@stoppatterns)[args]:>(a Through[h[args],Head[h]]/. g_[___]/;NumberQ[g]||Head[g]===Symbol&&MemberQ[Attributes[g],Constant]:>g/. (g:mathconstants)[___]:>g);FixedPoint[#1/. rule&,#1,depth]]&;


PushThrough[opts___?OptionQ][(head_)[args___]]/;
    FreeQ[head, Alternatives[args],\[Infinity]]:=
  PushThrough[{args},opts][head[args]]



Attributes[Wedge]={Flat};

Protect[NonCommutativeMultiply];
Protect[Exp];
Protect[Power];



End[]

EndPackage[]
