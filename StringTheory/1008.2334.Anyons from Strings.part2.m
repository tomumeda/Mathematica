(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
<<Local`QFTToolKit2`
tuItalics
tuLoad["StringTheory/1008.2334.Anyons from Strings.out"];

tuLightCone//Clear
tuLightCone//Clear
tuLightCone//Clear
tuLightCone[level_:1][exp_]:=Module[{$,$s,$st,$g,$s0,$p,$x,$s1,$s2,$slightcone},
If[level==1,(*expand Matrix expressions for \[CapitalTheta] and \[CapitalGamma] *)
$st=e[26]//tuRuleSelect[\!\(\*OverscriptBox[\(T[\[CapitalTheta], "\<\>", {}]\), \(_\)]\)];
$g={$gamma//tuRuleSelect[Tensor[\[CapitalGamma],_,_],{},{\[Sigma],"+",pm,"-"}],
$gamma//tuRuleSelect[T[\[CapitalGamma],"d",{_}],{T[\[CapitalGamma],"u",{_}]},{}]
}//tuRule;
$=exp//expandDot[{toxDot,$st,$g,T[\[CapitalTheta],"",{}]->{{\[Theta]1},{\[Theta]2}}},{T},{tuDerivativeExpand[]},3]//tuMatrixOrderedMultiply//expandDot[{toDot,{{a_}}->a},{},{},3]
];

If[level==1.5,(*Sum terms in exp_ over \[Mu] indices *)

$=exp//Expand//(#/.pp:Plus[_,__]:>tuIndependentTerms[{\[Mu]}][pp]+Sum[tuDependentTerms[{\[Mu]}][pp],{\[Mu],0,2}]/;tuHasAllQ[pp,\[Mu]]&);
];

If[level==1.6,(*expand expand \[CapitalGamma],\[CapitalTheta]*)
$st=e[26]//tuRuleSelect[\!\(\*OverscriptBox[\(T[\[CapitalTheta], "\<\>", {}]\), \(_\)]\)];
$g={$gamma//tuRuleSelect[Tensor[\[CapitalGamma],_,_],{},{\[Sigma],"+",pm,"-"}],
$gamma//tuRuleSelect[T[\[CapitalGamma],"d",{_}],{T[\[CapitalGamma],"u",{_}]},{}]
}//tuRule;
$=exp//expandDot[{toxDot,$st,$g,T[\[CapitalTheta],"",{}]->{{\[Theta]1},{\[Theta]2}}},{T},{tuDerivativeExpand[]},3]//tuMatrixOrderedMultiply//expandDot[{toDot,{{a_}}->a},{},{},3]
];

If[level==2,(*X^n\[Rule]X^+-,P^n\[Rule]P^+-, *)
$g={$gamma//tuRuleSelect[Tensor[\[CapitalGamma],_,_],{},{\[Sigma],"+",pm,"-"}]
}//tuRule;
$=exp/.tuRule[$metric]/.(e[1]//tuRuleSelect[{T[X,"d",{0|1|2}],T[P,"u",{0|1|2}]},{},{T,pm}])/.
(e[4]//tuRuleSelect[{T[X,"u",{0|1|2}],T[P,"d",{0|1|2}]},{},{T,pm}])/.
tuRuleSelect[T[\[CapitalGamma],"d",{_}],{T[\[CapitalGamma],"u",{_}]},{}][$gamma]//tuMatrixOrderedMultiply//expandDot[{toDot,{{a_}}->a},{},{},3];

];

If[level==3,(*lightcone variable\[Rule]average+deviation variable*)
$s0=e[33]//tuRuleInTermsOf[{\[Zeta],\!\(\*OverscriptBox[\(\[Theta]\), \(_\)]\)},\[Theta]];
$p={T[iP,"d",{"+"}],T[iP,"d",{"-"}],T[iP,"",{}]};
$p=tuRuleInTermsOf[{p,iP},#,{T,xIntegral}][e[4]]&/@$p;
$x={T[iX,"u",{"-"}],T[iX,"",{}]};
$x=tuRuleInTermsOf[{x,iX},#,{T,xIntegral}][e[4]]&/@$x;
$s1={$x,$p}//tuRule;
$s2=e[4]//tuRuleSelect[T[iX,"u",{"+"}]];
$slightcone={$s1,$s2,\[Theta]1->0,\[Theta]2->\[Theta] factor\[Theta],$s0,a_[\[Tau]]->a}//tuRule;

$=exp//expandDot[{$slightcone},{T},{tuDerivativeExpand[{factor\[Theta]}]},1(*CHECK for all cases*)];

$=$//expandDot[{Dot[]->1,a_[\[Tau]]->a},{factor\[Theta],T,\[Tau],x,p,\[Zeta],Tensor[p,_,_],Tensor[x,_,_]},{tuOpDistributeF[xIntegral],tuIntegralSimplify[{iX,iP,\[Theta]}]},3]//expandDot[];
$s=e[4,1]//tuRule//Select[#,tuHasAnyQ[#,xIntegral]&]&;
$s=tuRuleSolve[#,xIntegral[__]]&/@$s//tuRule;

$=$//expandDot[{$s,tuRuleSelect[tuDPartial[_,_]][e[4,1]](*,$factor\[Theta]*)},{tuDPartial[\[Zeta],_],T[p,"d",{_}]},{tuDerivativeExpand[{factor\[Theta]}]},4];
];

If[level==3.1,(*expand/simplify integrals*)
$=exp//expandDot[{Dot[]->1,a_[\[Tau]]->a,xIntegral[tuDPartial[_,\[Sigma]],\[Sigma]]->0,
xIntegral[1,\[Sigma]]->2\[Pi],
tuDPartial[xx_,\[Sigma]]:>0/;tuHasAnyQ[xx,{x,p,\[Tau],\[Alpha],\[Zeta]}]
},{factor\[Theta],T,\[Tau],x,p,\[Zeta],Tensor[p,_,_],Tensor[x,_,_]},{tuOpDistributeF[xIntegral],tuIntegralSimplify[{iX,iP,\[Theta]}]},5]//expandDot[{},{},{},2]
];

If[level==4,(*Fourier decomposition*)
$s={$sPplus,$sXminus,e[33]//tuRuleInTermsOf[{T[\[Theta],"d",{n}],xSum},\!\(\*OverscriptBox[\(\[Theta]\), \(_\)]\)],
e[12]//tuRuleSelect[{\!\(\*OverscriptBox[\(a_\), \(_\)]\)}]}//tuRule;
$=exp/.$s/.a_[\[Tau]]->a/.tuDPartial[x,\[Sigma]]->0;
];

If[level==5,(*Integrate over \[Sigma]*)
$=exp/.a_[\[Tau]]->a;
$=$//expandDot[{},{T,p,Exp[_],Tensor[p,_,_]},{Simplify},3];
$=$//(*tuOpSwitch[tuDPartial,xSum]//*)tuDerivativeExpand[{n,n1,n2,T}]//expandDot[{
tuDPartial[xx_,\[Sigma]]:>0/;tuHasAnyQ[xx,{x,p,\[Tau],\[Alpha],\[Theta],\[Zeta]}],tuDPartial[x_,\[Tau]]:>0/;MatchQ[x,\[Sigma]]
},{},{},1];
$=$/. Dot[xSum[a_,b_],xSum[a1_,b1_],xSum[a2_,b2_]]:>Dot[xSum[a,b],xSum[a1,b1]/.n->n1,xSum[a2,b2]/.n->n2]/.Dot[(c_:1)xSum[a_,b_],(c1_:1)xSum[a1_,b1_]]:>Dot[c xSum[a,b],c1 xSum[a1,b1]/.n->n1]/.Dot[xSum[a_,b_,c_],xSum[a1_,b1_]]:>Dot[xSum[a,b,c]/.n->n2,xSum[a1,b1]]/.Dot[xSum[a_,b_],xSum[a1_,b1_,c1_]]:>Dot[xSum[a,b],xSum[a1,b1,c1]/.n->n2];

$=$//expandDot[{},{T,p,Exp[_],Tensor[p,_,_]
},{tuOpDistributeF[xSum],Simplify,tuSumSimplify[{u,Subscript[u, 0],T,p,Tensor[p,_,_]}]},6];

$=$//expandDot[{tuOpDistribute[xSum],tuSumGatherR},{n,n1,n2,Exp[_],T},{},3];
$=$//Simplify//tuSumSimplify[{u,Subscript[u, 0],T,p,\[Zeta],Tensor[p,_,_]}];
];

If[level==6,(*Manipulate Sum,xIntegral for integration*)
$=tuIntegralSimplify[][Expand[exp]]//.tuOpDistribute[xIntegral]//tuIntegralSimplify[]//tuOpSwitch[xIntegral,xSum]//
tuIntegralSimplify[{}](*//tuRule1*);
];

If[level==7,(*Evaluate xIntegral over {\[Sigma],0,2\[Pi]}*)
$=exp/.xIntegral[a_,\[Sigma]]->xIntegral[a,{\[Sigma],0,2\[Pi]}]//Activate;
$=$/.(Exp[2I \[Pi] a_]-1)->a 2\[Pi] \[Delta][a]/.\[Delta][a_+b__:0]->T[\[Delta],"dd",{a,-b}]//tuSumKroneckerDelta[]
];

If[level==8 ,(*Break up \[CapitalSigma]'s {n,-\[Infinity],\[Infinity]}\[Rule]{n,1,\[Infinity]} 
order \[Alpha]'s, remove single \[Alpha]-type*)
$=exp//.$sumBreakUp//.$sumGather//Simplify;

$=$/.dd:Dot[T[a_,"d",{n1_}],T[a1_,"d",{n2_}]]:>Reverse[dd]/;OrderedQ[{n2,n1}]&&Length[dd]==2;

$=$/.dd:Dot[T[_,"d",{n1_}],T[_,"d",{n2_}],T[_,"d",{n3_}]]:>0/;Count[tuExtractPattern[\[Alpha]][dd],\[Alpha]]==3&&(Count[tuExtractPattern[\!\(\*OverscriptBox[\(\[Alpha]\), \(~\)]\)][dd],\!\(\*OverscriptBox[\(\[Alpha]\), \(~\)]\)]!=3&&Count[tuExtractPattern[\!\(\*OverscriptBox[\(\[Alpha]\), \(~\)]\)][dd],\!\(\*OverscriptBox[\(\[Alpha]\), \(~\)]\)]!=0
);
$=$/.Dot[T[a_,"d",{n1_}],T[a_,"d",{n2_}],T[a_,"d",{n3_}]]:>Apply[Dot,Map[T[a,"d",{#}]&,SortBy[{n1,n2,n3},-(Count[#/.Plus->List/.Times->List//Flatten,-1](.6-.1Depth[#]))&]]];

$=$//.dd:Dot[Tensor[\[Theta],_,_],Tensor[\[Alpha],_,_]]:>Reverse[dd];
$=$//.dd:Dot[Tensor[\[Theta],_,_],Tensor[\!\(\*OverscriptBox[\(\[Alpha]\), \(~\)]\),_,_]]:>Reverse[dd];

];
$
];
(**)




